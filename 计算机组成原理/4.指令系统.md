# 指令格式

CPU中控制器功能：

- 解析指令

- 根据指令指挥其它部件协调工作

指令：又称机器指令

是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。所有指令的集合构成指令系统，也成为指令集。

一台计算机只能执行自己指令系统中的指令，不能执行其它系统的指令。比如电脑是x86架构，电脑的软件不能运行在ARM架构的手机上。

指令 = 操作码 + 地址码

## 按指令中包含的地址码个数分类

### 零地址指令

`OP` OP是操作数

指令中不包含地址码，应用场景：

- 不需要操作数

    如空操作、停机、关中断等指令

- 堆栈计算机

    两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶(比如后缀表达式的计算)

### 一地址指令

`OP | A1`  A1指某个主存地址

指令中包含一个地址码

- 只需要单操作数

    如加1、减1、取反、求补等

    *指令含义：* OP(A1)-->A1, 从A1取出数据执行OP操作(加1，减1等)然后放回A1

- 需要两个操作数，但其中一个操作数隐含在某个寄存器内

    *指令含义：* (ACC)OP(A1)-->ACC, 将ACC中的数据与A1中的数据进行OP指明的运算，并放回ACC中

### 二地址指令

`OP | A1(目的操作数) | A2(源操作数)`

指令中包含两个地址码，运算结果放回A1中
    
- 常用于需要两个操作数的算术运算、逻辑运算相关指令

    *指令含义：* (A1)OP(A2)-->A1, 将A1和A2中的数据取出，执行OP操作后写回A1

### 三地址指令

`OP | A1 | A2 | A3(结果)`

指令中包含三个地址码，最后一个指明计算结果存放的位置

- 常用于需要两个操作数的算术运算、逻辑运算相关指令

    *指令含义：* (A1)OP(A2)-->A3  将A1和A2中的数据取出，执行OP操作后写回A3

### 四地址指令

`OP | A1 | A2 | A3(结果) | A4(下址)`

前面与三地址指令完全相同，最后一个指令指明下一条将要执行指令的地址

最后执行指令后将PC的值修改为A4所指的位置

在指令总长度固定不变的情况下，地址码的数量越多，每个地址码的长度就越短，寻址能力就越差

***

## 按指令长度分类

指令字长：是一条指令的总长度(可能会变)

根据指令长度是机器字长的多少倍

- 半字长指令

    指令长度是机器字长的一半

- 单字长指令

    指令字长等于机器字长

- 双字长指令

- ......

指令字长会影响取指令所需的时间

定长指令字结构：指令系统中所有指令的长度都相等

变长指令字结构：指令系统中各种指令的长度不等

## 按操作码长度分类

定长操作码：指令系统中所有指令的操作码长度都相同

控制器译码电路设计简单，但是灵活性低

可变长操作码：指令系统中各指令的操作码长度可变

## 按操作类型分类

### 1. 数据传送

数据传送类：进行主存与CPU之间的数据传送

- LOAD ： 把存储器中的数据放到寄存器中

- STORE：把寄存器中的数据放到存储器中

### 2. 算数逻辑操作

运算类

- 算数：加减乘除、增1、减1、求补、浮点运算、十进制运算

- 逻辑：与或非、异或、位操作、位测试、位清楚、位求反

### 3. 移位操作

运算类

算术移位、逻辑移位、循环移位(带进位和不带进位)

### 4. 转移操作

程序控制类：改变程序执行的顺序

实现程序执行流的变化，比如遇到if-else

本质就是改变PC的值

- JMP：无条件转移

- 条件转移

- CALL和RETURN：调用和返回

- Trap：陷阱和陷阱指令

### 5. 输入输出操作

输入输出类：进行CPU和I/O设备之间的数据传送

CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)

***

## 扩展操作码指令格式

定长指令字结构 + 可变长操作码

- 指令中所有指令的长度都相等

- 指令系统中各指令的操作码长度可变

指令格式的注意事项：

- 不允许短操作码是长操作码的前缀

    所以保留全1作为扩展使用

- 各指令的操作码一定不能重复

### 扩展操作码举例

指令字长16位，每个地址码占4位：

则前4位是基本操作码字段OP，另有3各4位长的地址字段A1、A2和A3

- 三地址指令：4位操作码，理论上有 2⁴ = 16 条(因为操作码有4位)，但是要将全1用作扩展，所以有15条

- 二地址指令：8位操作码，前4位全是1。也是15条，全1用作扩展

- 一地址指令：12位操作码，前8位全是1。共15条

- 零地址指令：16位操作码，前12位都是全1，共16条

### 另一个设计方案

指令字长固定为16位

- 有15条三地址指令：前4位表示操作码，后面12位表示三个地址码。

    `0000~1110 A1 A2 A3`

    留出了一种状态，下一层最多1 * 2^4 = 16 种状态

- 有12条二地址指令：4到8位只需要取12个来表示二地址指令

    `1111 0000~1011 A1 A2`

    前4位是1表示是二地址指令

    留出了`16-12 = 4`种状态，下一层最多4 * 2^4 = 64 种状态

- 有62条一地址指令：一地址只需要4位地址码，由于二地址指令留下了(1100,1101,1110,1111)没有用，而这四个指令前两位都是1，所以我们可以用前6位都是1标识一地址指令，再加上4位地址码，共剩余6位可以标识62条地址

    `111111 000000~111101(0~61) A3`

    留出`64 - 62 = 2`种状态，下一层最多 2 * 2^4 = 32 种状态

- 有32条零地址指令：当前11位全是1时，就超出一地址表示范围，剩下五位可以用来表示零地址指令

    `1111 1111 111 00000~11111`

设地址长度为n，上一层留出了m种状态，下一层可扩展出 m × 2^n 种状态

CPU解析指令：

读入16位指令

- 如果前4位不是全1，就按三地址解析

- 如果前四位全1，后两位不是全1，就按二地址解析

- 如果前六位全1，后五位不是全1，就按一地址指令解析

- 如果前11位全1，就按零地址指令解析

***
***

# 指令寻址 和 数据寻址

## 指令寻址

如何确定下一条指令的存放地址

包括顺序寻址 和 跳跃寻址
程序计数器PC：用于指明下一条指令存放的地址

### 顺序寻址——定长指令字结构

每条指令字长都相同

如果主存按字编址，则下一条指令的地址：(PC) + 1 --> PC

如果主存按字节编址，指令字长 = 存储字长 = 2B(即每条指令占两个字节)：(PC) + 2 --> PC

### 顺序寻址——变长指令字结构

每条指令所占字长不一样，不知道应该读多少

CPU先读入一个字，根据操作码判断这条指令的总字节数n，之后让PC的值+n：(PC) + n --> PC

### 跳跃寻址

根据 转移类指令 指出下条指令的位置

执行转移类指令，修改PC值

***

## 数据寻址

确定本条指令的地址码指明的真实地址

因为地址码的解释方式可能有很多种

可以在原有的指令结构的基础上加上几个比特位来标识我们应该按照什么规则寻址，即寻址特征

指令中包含的为形式地址(A)，求出的真实地址称为有效地址(EA)

### 直接寻址

指令中的形式地址A就是操作数的真实地址EA

EA = A

指令执行过程：共两次访存(不考虑运算结果的存储)

- 取指令：访存一次

- 执行指令：访存一次

*优点：* 简单，执行指令只需要一次访存

*缺点：* A的位数决定了该指令操作数的寻址范围较小，操作数的地址不易修改

### 间接寻址

指令中的地址字段存放的形式地址是操作数有效地址所在存储单元的地址(类似于放了一个指针)

EA = (A)

指令执行过程：共三次访存

- 取指令：访存一次

- 取出A中存放的真实地址EA：访存一次

- 访问EA：访存一次

可以套两次娃，就是两次间接寻址......

*优点：* 可扩大寻址范围(有效地址EA的位数大于形式地址A的位数)；便于编制程序

*缺点：* 指令在执行阶段要多次访存

### 寄存器寻址

指令字中直接给出操作数所在的寄存器编号Ri，其操作数在由Ri所指的寄存器内

EA = Ri

指令执行过程：一次访存

- 取指令：访存一次

- 执行指令：访存零次

*优点：* 执行执行阶段不访问主存只访问寄存器，指令字短且执行速度块，支持向量/矩阵运算

*缺点：* 寄存器价格昂贵，计算机中寄存器个数有限

### 寄存器简介寻址

指令中的地址A指明了一个寄存器编号Ri，寄存器中放的是操作数的主存地址

EA = (Ri)

指令执行过程：两次访存

- 取指令：访存一次

- 访问寄存器取到EA：访存零次

- 访问EA：访存一次

*特点：* 比一般间接寻址相比速度更快

### 隐含寻址

不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址

比如一地址指令中一个操作数隐含在累加寄存器ACC中

*优点：* 有利于缩短指令字长

*缺点：* 需增加存储操作数或隐含地址的硬件

### 立即寻址

形式地址A就是操作数本身，又称为立即数，一般采用补码形式

寻址特征为“#”

就是地址码部分存放的是操作数本身

只需要取指令时访存一次

*优点：* 指令执行时间最颠

*缺点：* A的位数限制了立即数的范围

## 数据寻址——偏移寻址

- 基址寻址：以程序的起始存放地址作为起点

- 变址寻址：程序员自己决定从哪里作为起点

- 相对寻址：以程序计数器PC所指地址作为起点

### 基址寻址

基址寄存器(BR,base address register)：用于存放程序的起始地址(其实就是重定位寄存器，翻译不同)。由操作系统负责管理

有的计算机采用通用寄存器作为基址寄存器，那指令中在指明寻址方式之后还需要指明寄存器编号

    程序员可以操作通用寄存器，
    但是如果指定为基址寄存器就不能操作

将BR中的内容加上指令中的形式地址A形成有效地址

EA = (BR) + A

优点：便于程序“浮动”，方便实现多道程序并发运行

程序运行前，CPU会将BR的值修改为该程序的起始地址，存在操作系统的PCB中

### 变址寻址

变址寄存器(IX,index register)

EA = (IX) + A

与基址类似

与基址的区别：

- 变址寄存器是面向用户的，即在程序执行过程中，变址寄存器的内容可由用户改变

- IX是作为偏移量的，A作为基地址，与基址刚好相反

在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可以访问数组的所有元素，适合编制循环程序

基址&变址复合寻址：

EA = (IX) + ((BR) + A)

### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A，形成操作数的有效地址，即EA = (PC) + A

其中A是位移量，可正可负，补码表示

操作数的地址随着PC的值变化而变化，便于程序浮动(一段代码在程序内部的浮动)

***

### 堆栈寻址

操作数存放在堆栈中，隐含使用堆栈指针(SP，Stack Pointer)作为操作数地址

堆栈可以是专用的寄存器(硬堆栈)，也可以是主存中划分出的一片区域(软堆栈)。SP也是一个寄存器，里面存储了当前栈顶元素

记栈顶单元为Msp，栈顶元素相加的过程为(栈顶在小地址)

- POP ACC：将栈顶元素放入ACC中

    (Msp) --> ACC

    (SP) + 1 --> SP

- POP X:将栈顶元素放入加数X中

    (Msp) --> X

    (SP) + 1 --> SP

- ADD Y:ACC与X中的值相加，放入Y中

    (ACC) + (X) --> Y

- PUSH Y：将运算结果入栈

    (SP) - 1 --> SP

    (Y) --> Msp

***
***

# 汇编语言指令基础

用高级语言写的源程序要先经过编译变成汇编语言(助记符)，再通过汇编变成机器语言(二进制代码)

汇编语言和机器语言都是机器级代码

只需要掌握x86汇编语言指令基础，x86中一个字=16bit

指令格式：操作码 + 地址码

- 操作码指明数据应该怎么处理

- 地址码中指明数据在哪儿

    - 在寄存器里

        在指令中给出寄存器名

    - 在主存里

        在指令中给出主存地址和读写长度

    - 在指令里

        也就是立即寻址

指明内存的读写长度：未指明读写长度默认32bit

- dword ptr——双字，32bit

- word ptr——单字，16bit

- byte ptr——字节，8bit

## 以mov指令为例

`mov 目的操作数d，源操作数s`

- d：destination，目的地

- s：source，来源、发源地

功能：将源操作数s复制到目的操作数d所指得位置

指令举例：

- mov **eax**，**ebx**

    将寄存器ebx中的值复制到寄存器eax

- mov **eax**，5

    将立即数5复制到寄存器eax

- mov **eax**，*dword ptr* [af996h]

    将内存地址af996h所指的32bit中的值复制到寄存器eax中

- mov *byte ptr* [af996h]，5

    将立即数5复制到内存地址af996h所指的一字节中

中括号一般放的是一个地址，表示要取中括号里的主存地址存放的数

- mov **eax**，*dword ptr* [ebx]

    说明寄存器ebx中存的是一个主存地址，要将ebx中的地址中的数取32bit到eax中，相当于寄存器间接寻址

## x86架构CPU中的寄存器

寄存器都以E开头，E=Extended=32bit。E开头的寄存器大小都是32bit

**通用寄存器：**

以X结尾，X=未知，也就是不知道存什么，什么都可以存。

- EAX

- EBX

- ECX

- EDX

如果把E去掉，也就是用AX，BX，CX，DX，就可以只使用寄存器的低16位。甚至可以只使用8位。但是只有通用寄存器能这么用

**变址寄存器**

以I结尾，I=Index。通常用于线性表、字符串的处理

- ESI

    S = Source

- EDI

    D = Destination

**堆栈寄存器**

用于实现函数的调用

- EBP

    堆栈基指针(栈底)，Base Pointer

- ESP

    堆栈顶指针(栈顶)，Stack Pointer

***

## 常用的x86指令

### 算术运算指令

d：destination，目的操作数。处理完的结果放回d所指的位置，所以d不可以是常量

s：source，来源地

加(add) —— `add d，s ` 计算d+s，结果存入d

减(subtract) —— `sub d，s ` 计算d-s，结果存入d

乘(multiply)

- `mul d,s` 无符号数d*s，乘积存入d

- `imul d,s` 有符号数d*s，乘积存入d(i=integer)

除(divide)

s是除数，被除数提前放入edx和eax中(因为被除数需要扩展，高32位存入dex，低32位存入eax中)，隐含寻址

- `div s` 无符号数除法 edx:eax/s，商存入eax，余数存入edx

- `idiv s` 有符号数除法 edx:eax/s，商存入eax，余数存入edx

取负数(negative) —— `neg d ` 将d取负数，结果存入d

自增++(increase) —— `inc d` 将d++，结果存入d

自减--(decrease) —— `dec d` 将d--，结果存入d

x86中不允许两个操作数都来自主存

### 逻辑运算指令

与 —— `and d,s` 将d和s逐位将与，结果放回d

或 —— `or d,s` 将d和s逐位将或，结果放回d

非 —— `not d` 将d逐位取反，结果放回d

异或(exclusive or) —— `xor d,s` 将d和s逐位异或，结果放回d

左移(shift left) —— `shl d,s` 将d逻辑左移s位，结果放回d(通常s是常量)

右移(shift right) —— `shr d,s` 将d逻辑右移s位，结果放回d(通常s是常量)

### 其它指令

用于实现分支结构、循环结构的指令：cmp、test、jmp、jxxx

用于实现函数调用的指令：push、pop、call、ret

用于实现数据转移的指令：mov

***

## 指令格式 —— AT&T格式和Intel格式

AT&T是Unix、Linux常用格式，Intel是Windows的常用格式

主要区别：

- 源操作数在左，目的操作数在右(Intel目的在左，源在右)

    `op s,d`也就是运算结果要放回左边右边操作数中

- 寄存器的表示，寄存器名前要加百分号 (Intex直接写寄存器名)

    `mov %ebx,%eax`

- 立即数的表示：立即数之前必须加 $ (Intel直接写立即数)

    `mov $985,%eax`

- 主存地址的表示：用小括号(Intel是中括号)

    `mov %eax,(af996h)`

- 读写长度表示：在指令后加b、w、l表示

    `movb &5,(af996h)`、`addw $5,(af996h)`

    - 指令后加b：读写长度为byte

    - 指令后加w：读写长度为word

    - 指令后加 l：读写长度为dword

    默认读写长度也是32bit

- 主存地址偏移量的表示

    - AT&T：`movl -8(%ebx),%eax` 偏移量(基址)；`movl 4(%ebx,%ecx,32),%eax` 偏移量(基址，变址、比例因子)

    - Intel：`mov eax,[ebx-8]` [基址+偏移量]；`mov eax,[ebx+ecx*32+4]`[基址+变址*比例因子+偏移量]

***

## 选择语句

在x86处理器中，程序计数器PC通常被称为IP(Instruction Pointer，指令指针)

### 无条件转移指令——jmp

`jmp<地址>` PC无条件转移至<地址>

- `jmp 128`：地址可以由常数给出

- `jmp eax`：地址可以来自于寄存器，跳转至eax中存储的地址

- `jmp [999]`：地址可以来自于主存

但是程序员不知道指令存放在哪个位置

可以用标号锚定要跳转的位置，标号的特征是有冒号，名字可以自己取

```
mov eax,7
mov ebx,6
jmp NEXT
mov ecx,ebx
NEXT:
mov ecx,eax
```

- `jmp NEXT`:地址可以用标号锚定

写汇编语言代码时，一般会以函数名作为标号，标注该函数指令的起始地址

### 条件转移指令——jxxx

一般要搭配cmp指令，compare

`cmp a,b`比较a和b两个数

```x86asm
cmp eax,ebx  # 比较寄存器eax和ebx里的值
jg NEXT  # 如果eax > ebx,则跳转到NEXT
```

- `je<地址>` jump when equal

    若 a == b 则跳转

- `jne<地址>` jump when not equal

    若 a != b 则跳转

- `jg<地址>` jump when greater than

    若 a > b 则跳转

- `jge<地址>` jump when greater than or equal to

    若 a >= b 则跳转

- `jl<地址>` jump when less than

    若 a < b 则跳转

- `jle<地址>` jump when less than or equal to

    若 a <= b 则跳转

选择语句示例：

```C++
if(a>b){
    c = a;
}else {
    c = b;
}
```

```x86asm
mov eax,7  # 假设变量a=7，将a存入eax中
mov ebx,6  # 假设b=6，将b存入ebx中
cmp eax,ebx  # 比较变量a和b
jg NEXT  # 若a>b，跳转到NEXT
mov ecx，ebx  # 用ecx存储变量c，将ebx的值复制到ecx中，即令b=c
jmp END  # 无条件转移到END
NEXT:
mov ecx，eax  # 令c=a
END:
```

***
## 循环指令

### 用条件转移指令实现循环

```C++
int result = 0;
for(int i=1; i<=100; i++){
    result += i;
}
```

```x86asm
mov eax,0  #用eax保存result，初值为0
mov edx,1  #用dex保存i，初始值为1
cmp edx,100  #比较i和100
jg L2  #如果i>100，不进入循环，直接跳到L2
L1:
add eax,edx  #实现 result+=i
inc dex  #inc自增指令，让i++
cmp edx,100  #i和100比较，看是否需要跳出循环
jle L1  #若i<=100继续循环，跳到L1执行
L2： #跳出循环主题
```

### 用loop指令实现循环

适用于循环轮数固定的循环

```C++
for(int i=500; i>0; i--){
    做某些处理
}
```

```x86asm
mov ecx,500  #用ecx作为循环计数器
Looptop:  #循环的开始
...
做某些处理
...
loop Looptop  #ecx--,若ecx！=0，跳转到Looptop

作用就等于
dec ecx  #ecx自减
cmp ecx,0
jne Looptop
```

只能用ecx寄存器作为循环计数器

理论上能用loop指令实现的功能一定能用条件转移指令实现

使用loop指令可能会使代码更清晰简洁

补充：loopx指令

循环的继续要额外判断一些条件

- loopnz——当ecx!=0 && ZF==0时，继续循环

    ZF为零标志位，即最近一次运算的结果不为0

- loopz——当ecx!0 && ZF==1 时，继续循环

    最近一次运算的结果为0

***
***

# CISC 和 RISC

指令系统的两种设计方向

## CISC

CISC：Complex Instruction Set Computer

复杂指令集

设计思路：一条指令完成一个复杂的基本功能

代表：x86架构，主要用于笔记本、台式机等

80-20规律：典型程序中80%的语句仅仅使用处理机中20%的指令

## RISC

RISC：Reduced Instruction Set Computer

精简指令集

设计思路：一条指令完成一个基本工作；多条指令组合完成一个复杂的基本功能

代表：ARM架构，主要用于手机、平板等




