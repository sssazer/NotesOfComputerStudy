# scanf/printf 
## scanf 
### **用法：读取的是标准输入**

`int scanf(const char *format , ... )`
- 返回值：成功赋值的变量的数量，发生错误时返回EOF`#define EOF (-1)`。

    - 发生错误的情况：光标在行首时输入(ctrl+Z + 回车) 三次
- 参数中的... 是可变参数，参数的数目与format中%的数目保持一致

scanf是阻塞函数，但是只有缓冲区为空的时候scanf才会阻塞

### **标准输入缓冲区原理**

行缓冲：我们输入的字符先存放在缓冲区中，当在输入中遇到换行符`\n`时，才执行真正的I/O操作。\
`\n`也算一个字符，不被读取的话就会一直存放在缓冲区中\
scanf在读取整型、浮点型、字符串类型时，会忽略`\n`、空格等字符(忽略是指scanf函数在读取上述类型数据时会首先删除缓冲区中的换行、空格，然后再阻塞)，但是读取`%c`字符型数据时不会忽略任何一个字符。

### **循环输入**
- 错误
    ```C
    int main(){
        int i;
        while(scanf("%d",&i)){
            printf("%d",i);
        }
    }
    ```
    此时如果输入一个不是整数的字符，比如'a'，就会无限循环打印i的值(如果之前通过正确输入赋过值的话)。因为scanf读取到'a'与%d不匹配，返回值是0，0！=1满足循环条件。它又没办法清除缓冲区内除了换行符和空格的字符，所以只能不断读取a，陷入死循环。

- 正确
    ```C
    int main(){
        int i;
        while(rewind(stdin),scanf("%d",&a)){
            print("%d",a);
        }
    }
    ```
    rewind(stdin)用于清空标准输入缓冲区，VS2012及以前用fflush(stdin)
    只有读取数字才用得到，想明白运行过程再清除缓冲区

    这个函数并不是c语言标准，只能在vs中用

### 混合输入
每次在%c之前加一个空格,

因为%c会匹配空格，如果scanf里没写空格输入数据时以空格分割，那%c就会读取那个空格导致后面的数据全部读取错误

`scanf("%d %c%f",&i,&c,&f);`
***
## printf
输出到标准输出

`int printf(const char* format, ... )`

返回值是打印的字符数，如果发生错误返回一个负值

标准输入输出流事实上都是字符，只不过编译器帮忙把字符转化为对应的数据类型


# gets/puts

用scanf函数输入字符串
`scnaf("%s",str);`
没办法匹配空格，导致如果输入的一行字符串里带有空格的话就没办法放入一个字符数组中

用gets读取缓冲区中的数据可以解决这一问题，因为gets遇到'\n'停止


`fgets(c,sizeof(c),sdtin)` fgets在读取标准输入时会读取\n并放入变量中，而gets不会

***
***

# 指针
## 指针自增自减运算
- *p++

    ```C++
    int a[3] = {1,7,9};
    int *p = a;
    int j = *p++;
    此时：a[0] = 1, j = 1, *p = 7;
    ```
    因为++和*运算符优先级相同，自右向左结合，即\*(p++)，指针右移一位之后取值

- (*p)++

    ```C++
    int a[3] = {1,7,9};
    int *p = a;
    int j = (*p)++;
    此时：a[0] = 2, j = 1, *p = 2;
    ```
    先*p取值再将\*p指向地址的值++，\*p的指向没有改变，指向的值+1 

## 数组名作为实参在传递的时候是弱化为指针的

`void func(char a[]);` 与 `void func(char* a);` 一模一样

因为是指针素以传递之后在函数中看不到数组的长度

## 字符串常量
```C
char *p = "helloworld";
printf("%c",p[0]);
p[0] = 'H'; // 程序崩溃，非法访问

char c[] = "helloworld";
printf("%c",c[0]);
c[0] = 'H';

p = "love";
c = "love"; // 编译报错，不可修改的左值
```

所有直接用双引号引起来的字符串都是字符串常量，放在常量区中，这里面的数据只可读不可写。

当我们给字符指针赋值为字符串常量的时候，这个字符指针就直接指向常量区中的那段字符，只可读不可写。即使预先给p分配好了空间，指针p也会在赋值时指向常量区。

而当我们给字符数组赋值为字符串常量的时候，系统会在栈上重新开辟数组的空间并把那段字符拷贝到栈中，所以可以正常修改。

**字符常量：**

用单引号括起来的一个字符是字符型常量

## 指针与动态内存申请

栈空间的大小在编译时是确定的，所以数组在创建时必须用常量指定大小。

**malloc函数：**

`void* malloc(size_t size);`

- 返回值是void*，不确定类型的指针，具体使用时强转为需要的指针即可
- size_t类型底层定义为`typedef unsigned int  size_t;`，其实就是一个整型变量

**free函数**

`void free(void* ptr);`
`ptr = NULL;`

- free之后ptr指针内存的数据是不会改变的，也就是说ptr依旧指向原来的空间，此时ptr就变成野指针。所以最好free之后将ptr置为NULL
- free之后ptr指向的内存空间的内容会被清除掉
- free里面传的ptr不能发生偏移，malloc之后ptr指向哪里free的时候也得指向哪里，如果中间进行过类似p++的操作，free的时候就会报错

    因为申请一段堆空间的时候，内核帮我们记录的是其实地址和大小，所以释放的时候内核用对应的首地址去匹配传进来的ptr，匹配不上程序就崩溃

**memcpy**

功能类似于strcpy，把一个数组拷贝到另一个数组中。
但是strcpy是遇到0就结束，而memcpy是指定拷贝的大小

`memcpy(nums1,nums2,sizeof(nums2));`

## 查看指定地址元素的内存中存储的数据

```C++
void show_memory(void* start,int memory_len){
    int i;
    char* p = (char*)start;
    printf("0x%p ",p);
    for(i=0;i<memory_len;i++){
        if(i%4==0){
            printf("0x%p ",p+i);
        }
        printf("%x",(p[i]&0x000000f0)>>4);
        printf("%x ",p[i]&0x0000000f);
        if((i+1%4)==0){
            printf("\n");
        }
    }
}

...

int i=0;
int arr[3] = {1,2,3};
show_memory(&i);
show_memory(arr));
```

***
***

# 补码

## 用原码表示正数

`int a=1;` 

在VS中的内存显示为 `01 00 00 00`

这是由于一个整型占4个字节

一个字节有4位，可以表示从0`0000`到15`1111`

内存是按16进制显示的，正好一个数字也可以表示0`(0)`~15`(f)`

所以一个数字对应4位，两个数字对应8位，也就是一个字节，四个字节一共八个数字

intel是CPU是小端，所以先显示低位后显示高位，实际上地址应该是`00 00 00 01`

二进制表示为：`00000000 00000000 00000000 00000001`

按位取反 得：`11111111 11111111 11111111 11111110`

再+1，得：`11111111 11111111 11111111 11111111`

这就是-1

## 用补码表示负数

`int b = -1;`

在VS内存显示为`ff ff ff ff`

负数没法直接看出是多少，得先转化为正数，当然可以直接-1再取反

一般 直接按位取反再+1，也能得到正数。利用数的反转特性 

二进制开头是1表示这是一个负数

***
***
# 数据类型

## 整型变量

**有符号整型：**

- 有符号整型变量 `(signed)int` 4个字节 

    因为第一位是表示符号的符号位，所以只有31位可以表示数据。-2^31~2^31-1，大概21个亿

- 有符号短整型 `(signed) short (int)` 2个字节  
    
    范围：-2^15~2^15-1  也就是(-32768~32767)


- 有符号长整型 `(signed) long (int)` 32位程序4个字节，64位的是8个字节

    `long long (int)` 是8个字节，可以用来解决整数溢出问题

**无符号整型：** 没有符号位，只能存储非负数(0和正数)，所以32位全部可以存数据，范围是0~2^32

使用`printf("%u",num);` 来输出无符号数

- 无符号整型变量 `unsigned int` 


- 无符号短整型 `unsigned short (int)`


- 无符号长整型 `unsigned long (int)`

## 浮点型变量

float 占4个字节

根据IEEE-754标准

第一位是符号位   后面八位是指数部分 (用E表示)  ， 再后面23位是小数部分 (用M表示)

`SEEE EEEE | EMMM MMMM | MMMM MMMM | MMMM MMMM `

计算时用小数部分乘指数部分

比如：4.5 

- VS内存中显示`00 00 90 40`

- 小端转为正常顺序 `40 90 00 00`

- 转化为二进制 `0100 0000 1001 0000 0000 0000 0000 0000`

- 符号位：`0` 指数部分：`100 0000 1` 小数部分：`001 0000 0000 0000 0000 0000`

    - 符号位表示整个浮点数的符号，0是正，1是负
    - 指数部分表示的是2的几次方，因为计算机进行X2运算非常方便，只需要向左移位即可。
        
        指数部分转化为10进制之后要减去127，这样的话也可以表示负指数

    - 小数部分省略了整数1，也就是说本来应该是 `1.xxxx`，而小数部分只表示了小数点后`xxx`的部分

- 转化为十进制：指数部分：`129-127 = 2 ` 小数部分：`1.001 00...`

- 运算：小数部分乘指数部分，乘2的2次方，左移两位变为`100.1 00...`

- 结果转化为十进制 ： 2^2 + 2^-1 = 4.5

**浮点型变量精度问题**

float的有效数字只有6~7位，之后的数据会发生精度丢失，即后面的数据不保证正确

## 混合运算

- 整型运算按四个字节进行

    ```C++
    long long l;
    l = 131072 * 131072;
    ```
    运算完之后输出l是0，就是因为运算的时候默认按四个字节运算，运算结束之后赋值之前的结果四个字节就已经放不下了，寄存器溢出变为0，所以l的空间再大也没用
    
    解决方案
    `l = (long)131072 * 131072`

- 浮点型常量默认按double型(8个字节)运算

## 结构体对齐

对于一个结构体中声明的所有数据

char型自身对齐值是1字节

short型是2字节

int，float，double是4字节，

也就是说结构体中如果有一个int，一个char，那一个结构体变量占8个字节，因为char型会对齐至4个字节

***
***
# 位运算

硬件有专门的移位器，位运算效率很高

## 左移(逻辑左移) << 

高位舍弃，低位补零。效果是乘二

高位舍弃也会舍弃符号位，所以可能正数变为负数，负数变为正数
一个变量移位之后本身不会发生变化，能让变量发生变化的操作只有赋值和自增自减

`j = i << 1;` i是不会发生变化的

## 右移(逻辑右移) >>

低位丢弃，正数的高位补0(无符号数认为是正数)，负数的高位补1，效果是除以2

对于偶数来说是除以二，对于奇数来说是先-1后除以2

## 按位与 &

二进制每一个对应位置进行与操作。两个都是1就是1，其它都是0

5：`0000 0101`

7：`0000 0111`

&：`0000 0101` 5

## 按位或 |

有一个是1就是1，其它都是0

5：`0000 0101`

7：`0000 0111`

|：`0000 0111` 7

## 按位取反 ~

每一位都取反 

如果是一个正数按位取反会得到对应的负数再-1，因为负数是按位取反+1，现在只是把+1操作去掉了

5：`0000 0101`
~：`1111 1010`

## 按位异或 ^

各位相同为0，不同为1

自己与自己异或是0，0与任何数异或是那个数本身

异或满足交换律，即a^b^c = a^c^b

5：`0000 0101`

7：`0000 0111`

^：`0000 0010` 2

## 关于位运算的使用例子：

- 如何不借助第三个值交换两个数值

    ```C++
    int i=5,j=7;
    i = i^j;
    j = i^j; // 此时i=i^j,那j=i^j^j=i,因为j^j=0,i^0=i
    i = i^j; // 此时j储存的是i原来的值了，那i=i^j^i=j
    ```

- 如何用位运算找到一个数的最低位为1的那一位(不可使用循环)

    就是把这个数中所有的1都去掉，只保留最后一个1，然后看看是多少

    `i & -i;` 运用补码会+1的特性

- 实现循环左移和循环右移



 