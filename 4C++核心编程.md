# C++核心编程
## 内存分区模型
*意义：不同区域存放的数据，赋予不同的声明周期，给我们更大空间的灵活编程*

   - 代码区：存放函数体的二进制代码，由操作系统进行管理\
    **特点**
     - 共享：打开多个exe程序内存中只有一份代码
     - 只读：防止程序意外地修改了它的指令

   - 全局区：存放**全局变量**和**静态变量**以及**常量**
     - **全局变量**：写在函数体中(包括main函数)的变量都是局部变量，函数体外的就是全局变量
     - **静态变量**：在普通变量前面加static\
     `static int s_a = 10;`
     - **常量**：包括字符串常量和其他常量（const修饰的变量） 
       - 字符串常量：双引号引起来的字符串都是字符串常量\
       `cout << &"hello world << endl;"`
       - const修饰的全局变量——全局常量
       - **const修饰的局部变量——局部常量（不存放在全局区）**
   - 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\
     **注意：不要返回局部变量的地址，因为栈区开辟的地址函数执行完就释放了** 
     ```C++
        int* func(){  // 形参数据也会放在栈区
            int a = 10;
            return &a;  //返回局部变量的地址
        }

        int main(){
            int *p = fun();

            cout<< *p << endl; // 第一次可以打印正确的数字，是因为编译器做了保留
            cout<< *p << endl;  // 第二次这个数据就不会保留了

            system("pause");
            return 0;
        }
     ```
   - 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
     - 在C++中主要利用new在堆区开辟内存，返回开辟内存的地址
     - 指针本质上也是局部变量，放在栈上，但是指针指向的数据是放在堆区
     ```C++
        int * func(){

            int *p = new int(10);  // new会返回开辟的内存空间的地址
            return p;
        }

        int main(){
            int *p = func();
            cout << *p << endl;
            cout << *p << endl;

            return 0;
        }
     ```
   - new操作符
     1. new的基本语法
          - `new 数据类型(默认值);`
          - `delete 指针;`
     2.  在堆区利用new开辟数组
         - `int * arr = new int[10];`  
         - `delete[] arr;`\
            不加中括号的话只会释放首地址
## 引用 
  1. 引用的基本使用
     - 本质：给变量起别名
     - 语法：`数据类型 &别名 = 原名;` \
        `int a = 10;`\
        `int &b = a;`
  2. 引用的注意事项
     1. 引用必须要初始化\
        `int &b;`错误
        
     2. 引用一旦初始化后，就不可以更改了\
        `b = c;` 这是赋值操作而不是更改引用 
  3. 引用做函数参数
     - 作用：函数传参时，可以利用引用来让形参修改实参的值
     - 可以简化指针修改实参
        ```C++
           int swap(int &a, int &b){//通过引用传参其实是给实参起了一个别名
               int temp = a;
               a = b;
               b = temp;
           } 
           int main(){
               int a = 10;
               int b = 20;
               swap(a,b);  // 引用传递形参会修饰实参
           }

        ``` 
  4. 引用做函数返回值
     1. 不要返回局部变量的引用
        ```C++
            int& test(){
                int a = 10;
                return a;  // 错误示范
            }
        ```
     2. 函数的调用可以作为左值（只有返回值类型是引用类型才可以）
        ```C++
            int& test(){
                static int a = 10;//静态变量，存放在全局区，整个程序结束由系统释放
                return a;
            }
            int main(){
                int &ref = test();
                test() = 1000;
                cout << ref << endl; // 打印出来是1000，修改的实际上是a的值
            }
        ```
  5. 引用的本质
     - 本质：引用的本质在C++内部实际上是一个指针常量,所以引用只可以修改指针指向的值不可修改指向
        - 代码写出来的：`int& ref = a;`
        - 编译器内部自动转换的：`int * const ref = &a;`
        - 代码写出来的：`ref = 20;`
        - 编译器内部自动转换的：`*ref = 20;`
  6. <span id="常量引用">常量引用</span>
  
     **作用**：常量引用主要用来修饰形参，防止误操作
     
      ***创建引用变量时***
       - `int & ref = 10;` 不合法，引用必须引一块合法的内存空间，而10是字面量，在常量池中
       - `const int & ref = 10;` 合法，因为实际上编译器将代码修改为\
        `int temp = 10; const int & ref = temp;`此时原名temp不知道，只能用别名ref操作这个变量了

        ***用于函数形参时***
     - 在函数形参列表中加const修饰形参，防止形参改变实参\
        `void print(const int &val);`\
        **和值传递比好处是不用申请额外空间来复制实参**

## 函数的高级用法
1. 函数的默认参数

   **语法：**`返回值类型 函数名 （参数 = 默认值）{}`\
   优先使用调用参数是传入的数据\
   \
   **注意事项**

   1. 如果某个位置已经有了默认参数，那么从这个位置
   往后的参数都必须有默认值(即默认实参必须在形参列表的结尾)
   ```C++
      int func(int a, int b = 10, int c = 30){
         return a+b+c;
      }
   ```
   2. 如果函数的声明有默认参数，那函数的实现就不能有默认参数了(声明和实现只能有一个位置存在默认参数)
   ```C++
      int func(int a = 10, int b = 10);

      int func(int a, int b = 10){ // 会报错：重定义默认参数
         reutrn a+b;
      }
   ```

2. 函数占位参数\
   \
   **语法：**`返回值类型 函数名(数据类型){}`只有数据类型没有变量名\
   调用的时候占位参数位置也要传相应类型的数据\
   \
   *目前阶段占位参数还用不到，因为没有变量名找不到这个参数，后面会用到*\
   \
   占位参数还可以有默认参数
   ```C++
   void func(int a, int = 10){
      cout << a << endl;
   }
   int main(){
      func(10,10);
   }
   ```

3. 函数重载\
   \
   函数重载的关键是你调用函数的时候得让编译器知道你调用的是哪个函数，不要出现歧义
   \
   **作用：** 函数名可以相同，提高复用性\
   \
   **函数重载需要满足的条件：**
      
      - 同一作用域下
      - 函数名称相同
      - 函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**\
      \
      **注意：** 函数的返回值不可以作为函数重载的条件
   ```C++
      void func(){
         cout << "func" << endl;
      }
      void func(int a){
         cout << a << endl;
      }
   ```
4. 函数重载的注意事项

   **引用作为重载的条件**\
   加不加const可以作为重载条件
   ```C++
      void func(int &a){
         cout << "int &a" << endl;
      }
      void func(const int &a){
         cout << "const int &a" << endl;
      }
      int main(){
         int a = 10;
         func(a);  // 调用第一个
         func(10);  // 调用第二个
      }
   ```
   [原因参照常量引用](#常量引用)

   **函数重载碰到默认参数**\
   函数重载尽量不要有默认参数
   ```C++
      void func(int a, int b = 0){
         return;
      }
      void func(int a){
         return;
      }
      int main(){
         func(10);  //错误，这时候上下两个函数都可以调用，出现二义性
      }
   ```

   


     