# 0. Install Java

Java有四个版本

- Java Standard Edition：JavaSE

  标准版本

- Java Enterprise Edition：JavaEE

  基于标准版本进行扩展，适用于开发超大工程

- Java Micro Edition：Java ME

  JavaSE的子集，用于开发移动设备软件

- Java Card

  用于smart card

## 0.1 jdk

jdk全称为Java Development Kit

jdk提供一个开发java程序的开发环境，包括编译器和可以被复用的java库代码，和java运行环境（jre，Java Runtime environment）等组件。

google `jdk download`即可在oracle官网下载

## 0.2 IDE

IDE使用Intellij IDEA

首先在JET BRAINS官网免费下载安装IDEA Communicate

打开Intellij IDEA，创建项目，设置项目名称，选择JDK即可创建一个Java项目

**安装VIM插件**

右上角打开设置 - Plugins - Marketplace - 找到IdeaVim - 安装

**快捷操作**

- move class member：选中field或者method名，右键 refactor （快捷键ctrl + alt + shift + T）- move member即可将其移动至另一个class中

- 更改函数声明信息（返回值、参数列表等）

  选中method - 右键refactor - change signature

  更改函数名直接在refactor菜单中选rename

- 添加Constructor、get/set、toStrong

  在class中任意地方右键 Generate（快捷键Alt + Insert）

# 1. HelloWorld

## 1.1 first program

```Java
package com.sazer;

public class Main {
    public static void main(String[] args){
        // 第一个Java程序
        // 输入sout即可智能补全
        System.out.println("Hello World");
    }
}
```

第一行声明的package可以理解为namespace

在Java中至少要有一个Mina类和一个main方法作为程序入口，所有的类和方法都有访问权限，main方法必须声明为static，否则不能运行

## 1.2 程序执行过程

### 1.2.1 编译Compilation

![](./1/1.2-1.png)

Java源代码文件需要先通过Java编译器（包含在jdk中）编译为.class二进制文件

这个二进制文件is platfrom independent，可以运行在安装了JRE（Java Runtime Environment）的Linux、Mac和Windows平台上

在Intellij中选中文件 - 工具栏 - view - ShowBytecode即可查看该文件编译后的文件

**编译**

- 在Intellij IDEA中右键文件名 - OpenIn - Terminal

  在Termial中输入`javac Main.java`

  之后ls即可看到编译后的Main.class文件

- 在Intellij IDEA中点击运行程序，之后在out - production - 项目名 - com - 包名 文件夹下即可看到对应的Main.class文件

### 1.2.2 运行Execution

![](./1/1.2.2-1.png)

编译得到的.class文件，会再经过JVM（包含在JRE中）变成不同平台的可执行代码。

**运行**

- 打开Terminal，`cd ..`两次退回到src目录下

  执行`java com.sazer.Main`或`java com/sazer/Main`

- 在Intellij中按下运行按钮时，会自动编译+运行

## 1.3 读入数据

`import java.util.Scanner;`

从命令行窗口读入数据：

```java
Scanner scanner = new Scanner(System.in);
// 读入指定类型的数据
byte age = scanner.nextByte(); //读入byte类型
double d = scanner.nextDouble(); // 读入double类型数据

// 读入字符串
string firstName = scanner.next(); // 读入一个token，即遇到空格就结束读取
scanner.fullName = scanner.nextLine(); // 读入一整行，以读取到\n结束读取
```

## 1.4 打包程序

如果想将写好的程序发给别人使用，需要将程序打包为jar(java archive) file，之后在安装了jre的电脑上就可以运行该package

**打包控制台程序**

工具栏 - file - project structure - artifacts - add(点击加号) - JAR - from modules with dependencies - 选择main class - 点击ok

工具栏 - build - build artifacts - 会弹出所有的jar file - 选择 - build

左侧project栏 - out - artifacts可以找到建好的.jar文件 - 右键点击 open in terminal（或者打开终端定位到该文件目录） - 在终端中使用`java -jar HelloWorld.jar`运行

# 2. 变量

在Java中声明变量需要指定变量类型，变量名一般使用小驼峰（首字母小写，其余单词首字母大写）

`int age1 = 18, age2 = 29;`

变量只能定义在block中，也就是说必须定义在一对大括号内，并且作用域限定在这对大括号内

```java
// 不允许这样定义b，因为这不在block中
if (a > 1) 
    int b = a;

// 这样定义是可以的
if (a > 1){
    int b = 1;
}
sout(b); // 编译错误，不能在外面访问b
```



## 2.1 Primitive Types

用于存储简单数据

每个primitive type都有对应的Reference type，称为其对应的wrapper class

| Type    | Bytes | wrapper class |
| :------ | :---- | ------------- |
| byte    | 1     | Byte          |
| short   | 2     | Short         |
| int     | 4     | Integer       |
| long    | 8     | Long          |
| float   | 4     | Float         |
| double  | 8     | Double        |
| char    | 2     | Character     |
| boolean | 1     | Boolean       |

**注意事项：**

- 数字可以用`_`分割以增加可读性，比如`int largeNum = 123_456_789;`

- long类型在定义时需要在数字末尾加L，否则编译器会认为是int`long longNum = 3_123_456_789L;`

- float类型在定义时需要在数字末尾加F，否则编译器会认为是double`float floatNum = 1.23F;`

- char类型用单引号，string用双引号

**内存分配：**

当用一个变量给另一个变量赋值时，两个变量之间没有任何联系，其中任何一个变量的修改不会影响到另一个变量

## 2.2 Reference Types

存储复杂的object

除了上面的8种primitive type其余都是Reference Type

当创建引用类型变量时必须使用 new 手动分配空间，而变量名中存放的是这片空间的地址

**内存分配：**

由于引用变量中存放的是一个地址，因此当使用一个引用变量给另一个变量赋值时，赋予的也是这个地址，也就是说现在两个变量名指向了同一个地址，因此两个变量会互相影响。

```Java
Point point1 = new Point(1, 1);
Point point2 = point2;
point1.x = 2; // 此时point2.x 也等于 2
```

![](./1/2.2-1.png)

## 2.3 String

String类在Java.lang中定义，但是使用时无需import

### 2.3.1 声明

String 虽然是reference type，但是创建变量时不用new，而是可以直接简写赋值

```java
String str = new String("HelloWorld"); // new String() is redundant

String str = "HelloWorld";
```

### 2.3.2 常用操作

String is unmutable，也就是说下面的函数都不会在原String对象上修改，而是会返回修改后的String

**连接字符串**

直接用+连接

```java
String str = "HelloWorld" + "!!";
String str1 = "Hello" + '!'; // 可以连接char
```

**判断字符串开头结尾**

返回true或false

`str.startWith("123");`

`str.endWith("123");`

**获取字符串长度**

`str.length();`

**寻找子串位置**

返回子串首次出现的下标（从0开始），未出现返回-1

```java
str.indexOf("o"); // 返回4
str.indexOf("123"); // 返回-1
```

**替换子串**

`String replace(charSequence target, char Sequence replacement);`

将target子串替换为replacement，返回替换后的字符串，原字符串不会修改。如果没有指定target则返回原字符串。

```java
String str1 = str.replace("!!", "*");
// str = Helloworld!!
// str1 = Helloworld*
```

**大小写转换**

`str.toLowerCase();`

`str.toUpperCase();`

返回转换后的字符串

**去除首尾空格**

`str.trim();`

返回去除首尾空格后的字符串

### 2.3.3 转义字符

escape sequence

用一个`\`转义字符，比如`String str = "\"Hello\""`，这个字符串打印后是`"Hello"`

用`\\` 来打印一个`\`

`\n`表示换行 `\t`表示制表符

## 2.4 Arrays

### 2.4.1 创建数组

**创建数组**

Array是Reference Type，创建时需要使用new

- 一维数组

  `int[] nums = new int[10];`

  也可以直接在创建时初始化数组`int[] numbers = {1, 2, 3, 4, 5};`

- 二维数组：

  `int[][] metrix = new int[2][3];`

  ```java
  int[][] numbers = {
      {1, 2, 3},
      {4, 5, 6},
      {7, 8, 9}
  }
  ```

  

- 三维数组：

  `int [][][] metrix = new int[5][5][5]`

使用index获取单个元素`numbers[0] = 1;`

使用`numbers.length`获取数组长度

### 2.4.2 Arrays类

**格式化数组**

如果直接打印数组，输出的是数组的地址

- 格式化一维数组：

  `String numsStr = Arrays.toString(nums);`

- 格式化多维数组：

  `String numsStr = Arrays.deepToString(metrix);`

**排序**

`Arrays.sort(nums);`

直接将原数组排序

## 2.5 constant -- final

使用final关键字来声明一个常量变量，即该变量声明后不可修改

`final float PI = 3.14F;`

一般使用大写字母命名常量

尽量避免在代码中直接使用大量数字，而是应以一个常量来代表这个数字并说明它在这里的意义

## 2.6 类型转换 casting

### 2.6.1 隐式类型转换

implicit casting

精度更小或范围更小的数据类型在与其他数据类型运算时会自动转换为更大的类型

`byte < short < int < long < float < doule` 左边可以隐式转化为右边

```java
short x = 2;
int y = x + 2; // 会将x自动转换为int类型

double x = 1.1;
double y = x + 2; // 会将2隐式转换为double类型
```

### 2.6.2 显示类型转换

explicit casting

只能在compatible types之间转换，比如数字类型之间可以相互转换，而String就不能转换为int

```java
double x = 1.1;
int y = (int)x + 2;
```

可以使用对应的wrapper class来进行incompatible转换

```java
String x = "123";
int xInt = Integer.parseInt(x);
```

# 3. 运算符

## 3.1 算数运算符

`+ - * / %`

当使用整数作除法运算时默认保留整数部分

```java
int i = 10 / 3;
// i = 3
```

支持自增、自减、`+= -= /= *= %=`  运算符

## 3.2 Math Class

**四舍五入**

`Math.round();`

```java
int result = Math.round(1.1F);
int result1 = (int)Math.round(1.1);
// result = 1;
```

传入float返回int类型，传入double返回Long类型

**向上、下取整**

`Math.ceil();`向下取整

`Math.floor();` 向上取整

返回double类型，结果需要做类型转换

```java
int result = (int)Math.ceil(1.1); // result = 2
result = (int)Math.floor(1.1); // result = 1
```

**两值比大小**

`Math.max();`

`Math.min();`

```java
int maxNum = Math.max(1, 2); // maxNum = 2
int minNum = Math.min(1, 2); // minNum = 1
```

**生成随机值**

生成一个0~1之间的随机值，double类型

`Math.random();`

```java
// 生成0~100的随机值
int rand = (int)(Math.randon() * 100)
```

**乘方**

`Math.pow(a, b);`

返回a的b次方

## 3.3 格式化数字

NumberFormat

`import java.text.NumberFormat`

NumberFormat is a abstract class， 所以不能直接用new来创建实例。事实上该类采用工厂模式

**金钱格式**

```java
NumberFormat currency = NumberFormat.getCurrencyInstance(); // 将数字格式化为现金格式
String money = currency.format(1234567.89);
sout(money); // $1,234,567.89
```

**百分比格式**

```java
NumberFormat percent = NumberFormat.getPercentInstance();
String rate = percent.format(0.1);
sout(rate); // 10%
```

## 3.4 比较运算符

`==  !=  >  >=  <  <=   `

## 3.5 逻辑运算符

`&&  ||  !`

## 3.6 instanceof

判断object是否属于某个class

```java
class A{
    
}

var a = new A();
boolean isA = a instanceof A;
```

# 4. 流程控制

## 4.1 if-statement

```jAVA
if(condition1){
    clause...
}
else if(condition2){
    clause...
}
else{
    clause...
}
```

**三元表达式**

ternary operator

`int maxVal = a > b ? a : b;`

## 4.2 Switch-statement

```java
switch (role) {
    case "admin":
        ...;
        break;
    case "moderator":
        ...;
        break;
    default:
        ...
}
```

## 4.3 for-statement

```java
for (int i = 0; i < 5; i++){
    sout(i);
}
```

## 4.4 while-statemtn

**while**

```java
int i = 0;
while (i < 5) {
    sout(i);
    i++;
}
```

**do-while**

```java
int i = 0;
do{
    sout(i);
    i++;
}while(i < 0)
// 至少会执行一次
```

## 4.5 for-each statement

用于遍历arrays or collections

```java
int nums = {1, 2, 3, 4};
for (int num : nums){
    sout(n);
}
```

# 5. Exception

当程序运行时出现异常时，Java会抛出异常对象，比如`java.lang.NullPointerException`，在对象中存储了异常的详细信息，比如stack trace，表明发生异常的具体函数以及调用到该函数的调用链

Java会在调用链中一层一层找有没有exception handler，如果都没有就终止程序

## 5.1 exception types

异常类的继承关系：

![](./1/5.1-1.png)

 ### 5.1.1 checked

checked 意思是java 编译器会在编译阶段检查该异常是否被处理，如果没有处理则编译不通过

比如读入文件的操作，有可能遇到文件路径不存在的异常，此时就必须处理该异常。

```java
var reader = new FileReader("file.txt"); // 这行会报编译错误
sout("File opened");
```

这类异常的处理通常是给出一句提示，文件路径不存在

### 5.1.2 Unchecked / runtime

unchecked exception 也叫 runtime exception

也就是说它是运行时出错的，不是编译阶段能检查出来的

包括：

- NullPointerException - 空指针异常
- ArithmeticException - 除以0
- IllegalArgumentException - 传入方法的参数错误
- IndexOutOfBoundsException - 数组越界
- IllegalStateException - 调用方法的对象状态异常

### 5.1.3 Error

一般是程序外部造成的错误，比如

- stackoverflow
- out of memory

## 5.2 异常处理

### 5.2.1 try - catch-finally

当使用try-catch捕获并处理异常后，程序遇到异常后执行完catch block会继续向下执行

```java
FileReader reader = null;
try{
    reader = new FileReader("file.txt");
    sout("File opened");
    var value = reader.read(); // IOException
}catch(FileNotFoundException ex){
    sout(ex.getMessage());
    ex.printStackTrace(); // 打印stack trace信息
}
catch(IOException e){
    sout("Could not read data.");
}
finally{
    if(reader != null){
        try{
            // close函数也有checked异常
            reader.close();
        }
        catch(IOException e){
            
        }
    }
    	
}
```

- catch后面要写明处理的异常类型

  注意，异常类中也有继承关系，父类的异常会将继承于它的异常类一并处理

  因此可以使用`Throwable` 或者 `Exception`类型来捕获所有异常

- ex是FileNotFoundException类的一个对象，里面包含了本次异常的详细信息

- 可以用多个catch块处理多个异常，也可以在catch中将多个类型直接用 `|` 隔开一起处理

  ```java
  catch(FileNotException | IOException ex){
      
  }
  ```

- finally block不管有没有遇到异常都一定会执行，一般用于清理对象

  finally访问不到try block中声明的对象

### 5.2.2 try with resources

可以在try中定义资源，这样遇到异常时java编译器会自动释放

```java
try(
var reader = new FileReader("file.txt");
var writer = new FileWriter("...");
){
    var value = reader.read();
}
catch(IOException e){
    
}
```

只有实现了AutoCloseable接口的类才能这么使用

## 5.3 throw exception

### 5.3.1 throw

defensive progarmming

一般只有接收来自用户或者外部的输入时才做防御性编程，而不是在每个method都检查参数。method之间对于传递的参数应该互相信任

**throw unchecked exception**

```java
public class Account{
    public void deposit(float amount){
        if (amount <= 0)
            throw new IllegalArgumentException();
    }
}
```

**throw checked exception**

```java
public class Account{
    public void deposit(float amount) throws IOException{
        if (amount <= 0)
            throw new IOEException();
    }
}


```

在throw checked exception时，编译器会报错未处理异常，但是此时应该在调用deposit函数的地方处理异常而不是在抛出异常的地方处理异常。

所以要在函数声明中写明该函数会抛出异常

### 5.3.2 rethrow

当我们使用try-catch捕获异常之后，遇到异常程序也会继续向下执行。

如果想让程序在此终止，可以在catch block中rethrow该异常，来让程序别的地方处理，或者最终让编译器处理

```java
public static void show() throws IOException{
    var account = new Account();
    try{
        account.deposit(-1);
    }catch(IOException e){
        // 将此错误记录在log中
        throw e; // 要记得在函数声明中也throws出去
    }
}
```

## 5.4 自定义异常

只需要继承Exception类就完成了自定义异常类

- Checked Exception 继承 Exception
- Unchecked（runtime）Exception 继承 RuntimeException

```java
public class CustomizedException extends Exception{
    public CustomizedException(String message){
        super(message);
    }
    
    public CustomizedException(){
        super("a customized exception occurred");
    }
    
    // 可以用子类异常构造父类异常，来说明引发该父类异常的具体原因
    // 称为chaining e，即一个异常是由另一个异常引发的，而该异常又有可能引发另一个异常
    public CustomizedException(Exception derivedException){
        super(derivedException);
    }
}
```

