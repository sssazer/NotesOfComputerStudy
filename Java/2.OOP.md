# 5. Class

class 是创建object的模板，object是class的一个实例

object都是reference type

在Java中，所有function都必须定义在class中，称为method

## 5.1 基本语法

### 5.1.1 定义类

java中每个class应该单独在一个文件中

java中类、属性和方法都应该有范围修饰符

属性有默认值，默认值和该数据类型对应的数组相同

```java
public class Test{
    public String text; // Field
    
    public void setTest(String text){ // method
        this.text = text;
    }
}
```

### 5.1.2 实例化object

```java
Test test1 = new Test();
// 或者
var test1 = new Test; // 简写形式，编译器会根据等号右边确定var具体是什么类型
```

### 5.1.3 get/set方法

在类中应当将field设置为private，提供get/set方法来让外界对field进行操作

```java
public class Employer{
    // 选中变量名按下alter+enter即可自动补全getter和setter方法
    private int salary;
    
    public int getSalary(int salary){
        this.salary = salary;
    }
    
    public int setSalary(){
        return salary;
    }
}
```

### 5.1.4 构造器constructor

构造函数与类同名

```java
public class Employer{
	public Employer(int salary){
        setSalary(salary);
    }
    public Employer(){
        this(0);
    }
}
```

在构造函数中可以通过`this()`调用构造函数，可以用在构造函数重载时调用另一个重载版本

可以在构造函数中通过`super()`调用父类构造函数

在一个构造器中以上二者只能选择一个进行调用

## 5.2 内存模型

### 5.2.1 创建对象

```java
class Person {
    String name;
    int age = 90;
}
```

`Person p = new Person();`

1. 先加载类的信息：包括属性信息和方法信息

   一个程序中只会加载一次类的信息

2. 在堆中为对象分配空间

3. 默认初始化：将成员属性先初始化为默认值

   name初始化为null，age初始化为0

4. 显式初始化：如果成员属性定义时有初始值，再进行显式初始化

   把age初始化为90

5. 构造器初始化：调用构造器，为属性进行初始化

6. 把对象在堆中的地址返回给栈中的变量

![](./2/5.2.1创建对象.png)

## 5.3 构建类的原则

### 5.3.1 封装Encapsulation

封装性指：

- 应该将field和操作它们的method封装在一个类中，而不是把它们作为参数传来传去

- 应该将field封装起来，在类外不能直接接触。

  将field的修饰符设置为private，再额外设置get/set方法来修改/获取field的值

### 5.4.2 Abstraction

Reduce complexity by hiding unnecessary details

没有必要将所有field都提供面向外界的接口（get/set方法），而应该尽量隐藏内部的具体实现

### 5.4.3 coupling

The level of dependency between classes

如果class A需要使用classB，我们说a is dependent or coupled to b

当一个类做修改时，与它有联系的类应该能继续正常使用，而不必修改与它有联系的所有类

所以要尽量减少类暴露出的接口，也就是尽量减少public method。暴露出的接口尽量不能修改用法。

修改一个类不仅需要修改其他类中的代码，还会重新编译用到该类的所有文件，所以应该尽量避免类之间的相互依赖

## 5.4 类中的修饰符

### 5.4.1 static

Java类中有两种fields和method

一种是属于instance的

一种是属于class的，即static member

一般用于所有instance共享，不单独属于某个对象的数据，比如创建实例的数量

```java
public class Employee{
    public static numberOfEmployees = 0;
    public Employee(){
        numberOfEmployee++;
    }
    
    public static void printNumber(){
        sout(numberOfEmployees);
    }
}

Employee.numberOfEmployees;
```

静态方法中只能访问静态成员

静态成员可以直接用类名访问，而无需实例化一个对象

因此Main方法定义为static，是的Java Runtime可以直接执行程序而不用再实例化一个Main对象出来

在工具类或者java内置库（library中），有很多静态方法

### 5.4.2 访问修饰符

- private：类外部不可访问，不可被继承。
- 默认：不加任何修饰符就是默认，在同类和同包中能被访问
- protected：在同类、同包、子类中可以被访问

- public：类外可访问，可继承

## 5.5 方法

### 5.5.1 方法重载

当方法实现的功能相同，只是参数的类型不同时，可以使用重载

方法可以被重载overloading

相同函数名不同参数即可实现重载

constructor也可以重载

### 5.5.2 可变参数

当方法实现的功能相同，每个参数的类型都相同，只是参数的个数不同时，可以用可变参数

**语法规则**

- `变量类型...`表示可变参数

  比如`int...`表示可以接收0个或任意多个int，也可以直接接收一个int数组

- 可变参数可以和普通参数一起使用，但是可变参数必须放在参数列表的最后

  并且参数列表中最多只能出现一个可变参数

- 方法内使用可变参数时，可以当作数组来使用

```java
public int sum(int... nums) {
    int result = 0;
    
    for (int i = 0; i < nums.length; i++) 
        result += nums[i];
    // 或者
    for (int num : nums) 
        result += num;
    
    return result;
}
```



## 5.5 需要重写的method

所有class都默认继承Object类，在Object类中定义了一些方法如果用到的话需要重新实现功能

### 5.5.1 hashCode

Object中的实现是，根据当前instance的地址，计算出一个hashcode，用于判断两个instance的引用是否指向同一个地址

`instance.hashCode();`

**重写hashcode**

可以重写为根据instance中的某些值计算hashcode

```java
@Override
public int hashCode(){
    return Objects.hash(val); // hash函数可以接收任意数量个参数
}
```

### 5.5.2 equals

默认是根据hashcode判断两个instance地址是否相同，可以重写为根据自定义信息判断，比如内容

`instance1.equals(instance2);`

**重写equals：**

可以直接打开generate菜单（alt+insert）自动生成

```java
@Override
public boolean equals(Object obj){ // 参数类型必须是Object
    if (this == obj) 
        return true;
    if (! obj instanceof ClassName)
        return false;
    
    var other = (ClassName) obj;
    return obj.val == this.val;
}
```

### 5.5.3 toString

`instance.toString();`

将instance转换为String格式，打印instance时会默认调用该函数，默认返回

`com.sazer.ClassName@16进制hashcode`

可以重写为想要的打印格式

重写toString

```java
@Override
public String toString(){
    return this.val;
}
```

### 5.5.4 compareTo

compareTo用于比较两个对象的大小

**重写方法**

这个方法并没有定义在Object类中，而是在Comparable接口中，也就是说我们的自定义类要实现Comparable接口，再重写compareTo函数

compareTo的返回值遵循以下规则：

- 如果当前对象大于传入的对象，返回正数
- 如果相等，返回0
- 如果小于传入对象，返回负数

```java
public class User 
    implements Comparable<User>{
    private int value;
    
    @Override
    public int compareTo(User u){
        return this.value - u.value;
    }
}
```

**调用方法**

实现了Comparable接口的类可以使用排序函数进行排序，但是使用时不能使用比较运算符（> 、<、==）

```java
var user1 = new User(1);
var user2 = new User(2);

if (user1.compareTo(user2) < 0){
    sout("user1 < user2");
} 
else if(user1.compareTo(user2) == 0){
    sout("user1 = user2");
}
else{
    sout("user1 > user2");
}
```

# 6. 继承

## 6.1 基本语法

```java
public class Base{
    int val;
    public Base(int val){
        this.val = val;
        sout("Base");
    }
}

public class Derived extends Base{
    public Derived(){
        super(0);
        sout("Derived");
    }
}

var derived = new Derived();
```

Java不支持多继承

### 6.1.1 访问权限

子类继承了父类中所有属性和方法，但是无法直接访问父类中的私有方法和属性

### 6.1.1 constructor

创建子类对象时会先调用父类的constructor再调用子类的constructor

在子类构造器中可以使用`super()`调用父类构造函数，但是必须放在构造器的第一行，即使不写也会在第一行默认调用`super()`。如果父类没提供无参构造器，那必须手动声明调用哪个构造器，否则编译出错

`super()`和`this()`都必须放在构造器的第一行，因此二者不能同时出现

### 6.1.2 overwrite 重写

重写时必须保证函数声明与父类完全相同（函数名、返回值类型、参数列表），在函数上方加上`@Override`，java编译器会帮忙检查函数声明

```java
@Override
public String toString(){
    return text;
}
```

## 6.2 内存模型

*子类中会继承父类中的所有属性和方法*

```java
class GrandPa{
    String name = "大头爷爷";
    String hobby = "旅游";
}

class Father extends GrandPa{
    String name = "大头爸爸";
    int age = 30;
}

class Son extends Father {
    String name = "大头儿子";
}
```

### 6.2.1 创建对象

`Son son = new Son();`

这句话的执行过程：

1. 在方法区中加载类的信息

   加载顺序为（从先到后）：Object - GrandPa - Father - Son

2. 在堆中为Son对象开辟空间

3. 在Son的空间中，首先创建GrandPa中的属性

   name = "大头爷爷";   hobby = "旅游";

4. 在Son空间中创建Father中的属性

   name = "大头爸爸" age = 39;

5. 在Son空间中创建Son中的属性

   name = "大头儿子";

6. 将Son在堆中的地址返回给栈中的变量

![](./2/6.2继承内存模型.png)

### 6.2.2 访问属性

当在子类中访问某个属性时：

1. 先在子类中寻找是否存在，如果存在直接返回

2. 如果子类中没有，去父类中寻找。如果找到就停止；找不到继续向上寻找

   如果找到，即使没有权限访问也会返回，只不过会报错。

   也就是说，假如GrandPa中有`public int age;` Father中有`private int age;` 。 如果用son访问age，那么会报错 `'age' has private access in Father`

## 6.2 uppcast downcast

在Java中，子类对象可以被自动转为父类类型；父类对象可以被强转为子类类型（但是父类其实不能转子类，所以编译通过运行报错）

```java
public static void show(Father father){
    if (father instanceof Son){
        father = (Son)father;
    }
    sout(father);
}

...Main...
var son = new Son();
show(son); // 会自动转化为Father类型
```

## 6.3 polymorphism多态

当父类引用指向子类变量时，可以执行子类重写的函数

```java
public class Shape{
    public void render(){
        cout << "render a shape" << endl;
    }
}

public class Round extends Shape{
    @Override
    public void render(){
        cout << "render a round" << endl;
    }
}

public class Rectangle extends Shape{
    @Override
    public void render(){
        cout << "render a round" << endl;
    }
}

Main:
Shape[] shapes = {new Round(), new Rectangle};
for (var shape : shapes){
    // 这里会根据实际类型调用不同的render函数
    shape.render();
}
```

## 6.4 abstract关键字

在上述情况中，应该将Shape改为abstract抽象类

- 当一个类被声明为抽象类时，就无法实例化对象
- 当一个函数被声明为抽象函数时，子类必须重写该函数，除非子类也是abstract

```java
public abstract class Shape{
    public abstract void render();
}
```

## 6.4 final关键字

- 使用final关键字修饰的class，无法被继承
- 使用final关键字修饰的method 无法被重写

```java
public final class Shape{
    public final void render();
}

public class MyShape extends Shape{ // 编译报错
    
}
```

Java中String类就是final class

# 7. Interfaces

use interface to build loosely-coupled, extendible, testable applications

在interfaces中没有对函数的代码实现，只有函数声明来定义class的规范，具体的实现交给继承Interface的class。所以Interface不能实例化。

也就是说Interface定义What should be done，Class定义How it should be done。

不同与class，interface可以实现多继承，因为这样不会造成歧义。

![](D:\CS_Source\myNote-of-ComputerStudy\Java\1\7.0-1.png)

A完全不知道B的存在，如果哪天B有问题，那直接随便换一个能实现Interface的类就可以了

## 7.1 创建Interface

在左侧目录树中右键 - 创建class - Kind中选择Interface

在Java中Interface一般用Can开头，比如`CanCalculator`，或者第一个单词用`able`结尾的形容词

由于interface中的所有函数都应该被其他类实现，因此所有函数都得是public，所以可以省略access modifier

实现Interface的类要使用`implements`关键字

```java
public interface CanTexCalculator{
    double calculateTax();
}

public class TaxCalculator2023 extends Object implements CanTexCalculator{
    int income;
    
    public TaxCalculator2023(int income){
        this.income = income;
    }
    
    @Override
    double calculateTax(){
        return 0.4 * income;
    }
}
```

## 7.2 Dependency Injection

使用接口的类内部不应该负责实例化 实现接口的那个对象，它都不应该知道接口是由哪个类实现的，它只需要负责调用接口。

所以具体使用的对象使用dependency injection的方式直接注入使用接口的类中，即依赖传递，把实现功能依赖的东西传递进去

### 7.2.1 constructor injection

在constructor函数中直接传入实例化好对象

```java
public class TaxReport{
    // TaxReport只知道接口的存在，而不知道具体实现
    private CanTexCalculator calculator;
    
    public TaxReport(TaxCalculator calculator){
        this.calculator = calculator;
    }
}

Main:
var calculator = new TaxCalculator2023(10_000);
// 到明年，可以直接把第一行代码换为 new TaxCalculator2024(10_000); 
// 而对TexReport类不会有任何影响
var report = new TaxReport(calculator);
```

当有很多类用到大量接口时，我们不可能在main函数中一个一个手动创建实例化对象并使用constructor injection，所以会用到一些专门负责这个的框架，比如Spring

### 7.2.2 setter injection

设置一个setter函数来传入实例化好的对象

这样做的好处是在函数执行过程中依然可以更改实例化对象

```java
public class TaxReport{
    // TaxReport只知道接口的存在，而不知道具体实现
    private CanTexCalculator calculator;
    
    public TaxReport(CanTaxCalculator calculator){
        this.calculator = calculator;
    }
    
    public void setTexCalculator(CanTaxCalculator calculator){
        this.calculator = calculator;
    }
}
```

### 7.2.3 Method Injection

在要用到接口的函数中，现传入一个实例化对象，随用随传

```java
public class TexReport{
    public double show(CanTaxCalculator calculator){
        var tax = calculator.calculateTax();
        sout(tax);
    }
}

Main:
var report = new TaxReport();
report.show(new TaxCalculator2018());
report.show(new TaxCalculator2019());
```

## 7.3 Segregation Principle

Divide big interfaces into smaller ones

这样当interfaces需要改变时，可以将影响降低到最小

**比如一个接口：**

```java
public interface UIWidget{
    void drag();
    void resize(int size);
    void render();
}

// 当一个类只是用drag功能时
public class Dragger{
    public void drag(UIWidget widget){
        widget.drag();
    }
}
```

当UIWidget类中的resize函数发生修改时，虽然表面上看影响不到Dragger类的使用，但是其实会recompile and rebuild所有用到了UIWidget接口的地方

**应该分成下面几个接口：**

注意分开之后每个interface都要在单独的文件中

```	java
public interface Draggable{
    void drag();
}

public interface Resizeable{
    void resize(int size);
}

public interface UIWidget 
    extends Draggable, Resizable{
    void render();
}
```

## 7.4 Interfaces新特性

大多是都是bad features，尽量不要使用

### 7.4.1 fields

在Interfaces中可以定义fields，不过它默认且必须是 public static final，也就是说这个值在Interface中被定义后就不能再被修改了

### 7.4.2 static method

Intefaces中可以定义static method，并且这些method中可以有实现

```java
public interface TaxCalculator{
    static double getTaxableIncode(double income, int expenses){
        return income - expenses;
    }
}
```

如果真的所有实现该接口的类都要用到这个函数，那就定义一个抽象类实现这个函数，再让所有类继承这个抽象类

### 7.4.3 private method

Interferce中可以定义private method

### 7.4.4 summary

在加入这些奇怪的features之后，interface和abstract class的界限越来越不清晰，并且很多编程者滥用interface去实现多继承。

