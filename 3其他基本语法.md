# 其他基本语法
## 判断语句
   1. if语句
      ```C++
      char ch;
      cin >> ch;
      if(ch == 'a'){
          cout >> 'A';
      }else if(ch == 'b'){
          cout >> 'B';
      }else if(ch == 'c'){
          cout >> 'C';
      }else{
          cout >> 'D';
      }

      ```
   2. 三目运算符
      - 语法：`表达式1 ？ 表达式2 : 表达式3;`
      - 基本用法：`max = a > b ? a : b;`，取a、b中的较大值
      - 三目运算符返回的是一个变量，可以继续赋值
      - `(a > b ? a : b) = 100;`意思是如果a>b就返回a，然后给a赋值100


   3. switch语句
       - 缺点：判断是只能是整型或者字符型，不能是一个区间（比如a>5）
       - 优点：结构清晰，执行效率高
       ```C++
       switch(表达式){
           case 结果1: 执行语句;break;
           case 结果2: 执行语句;break;
           case 结果3: 执行语句;break;

           ...

           default: 执行语句;break;
       }
       ```
       ```C++
       char ch;
       cin >> ch;
       switch(ch){
           case 'a': 
               cout >> 'A';break;
           case 'b':
               cout >> 'B';
               break;
           case 'c':
               cout >> 'C';
               break;
           default:
               cout >> 'D';
               break;
       }
       ```
## 循环语句
   1. while(循环语句)
       
       `while(循环条件){循环语句}`
       - 避免死循环，但有时可以巧用while(1)
   2. do...while(循环语句)
      
       `do{循环语句} while(循环条件)`
       - 与while区别在于do...while无论如何会执行一次循环语句
   3. for(循环语句)
      
       `for(起始表达式; 条件表达式; 末尾循环体) {循环语句}`
       ```C++
       //打印0~9
       for(int i=0; i<10 ; i++>){
           cout << i << endl;
       }
       ```

      C++11新增：
       ```C++
      int a[5] = {1,2,3,4,5};
      for(auto i : a){
         cout << i;
      }
       ```
## 跳转语句
   1. break关键字
      - 作用：用于跳出选择结构或者循环结构
      - 使用的时机：
        - switch语句中，终止case并跳出switch
        - 循环语句中，跳出当前循环
        - 嵌套循环中，跳出最近的内层循环语句
   2. continue关键字
      - 在循环语句中，跳过本次循环中未执行的语句直接开始下一次循环
   3. goto语句
      - 作用：可以无条件跳转语句 
      - 语法：`goto 标记;`  `goto FLAG;`
      - 标记：`FLAG:`  标记习惯用大写
      - 功能太强大，不推荐使用
        ```C++
        cout << "第1行" << endl;
        cout << "第2行" << endl;
        goto FLAG;
        cout << "第3行" << endl;
        cout << "第4行" << endl;
        FLAG:
        cout << "第5行" << endl;

        ```
## 数组
   1. 一维数组
      - 数组名是一个常量，不可以进行赋值操作

            `arr = 100;`会报错表达式必须是可修改的左值  
      - 定义的三种方式(定义数组时，必须有初始长度，而且初始长度不能是变量) 
        1. `数据类型 数组名[数组长度];`

            `int arr[5];` 
        2. `数据类型 数组名[数组长度] = {值1，值2，值3......};`

            `int arr2[5] = {1,2,3};`  如果在初始化数据的时候没有全部赋值，会用0来填补剩余的数据 
        3. `数据类型 数组名[] = {值1，值2，值3......};`  

            `int arr3[] = {1,2,3,4,5};` 数组长度为5
      - 数组名
        - 用途：
          1. 统计整个数组在内存中的长度  
             - `sizeof(arr);` 整个数组占用的内存空间
             - `sizeof(arr[0]);`  一个数组元素占用的内存空间
             - 元素个数=`sizeof(arr)/sizeof(arr[0])`
          2. 可以获取数组在内存中的首地址 
             - `cout << arr << endl;` 
             - `cout << &arr[0] << endl;`
             - 数组的首地址实际上就是数组第一个元素的地址
2. 二维数组
   - 四种定义方式
     1. `数据类型 数组名[行数][列数];` `int arr[2][3];`
     2. `数据类型 数组名[行数][列数] = {{数据1，数据2} , {数据3，数据4}};`
        ```C++
        int arr2[2][3] = {
            {1,2,3},
            {4,5,6}
        };
        ```   
     3.  `数据类型 数组名[行数][列数] = {数据1，数据2，数据3，数据4......};`

        `int arr3[2][3] = {1,2,3,4,5,6};`
     4.   `数据类型 数组名[][列数] = {数据1，数据2，数据3......}` (只能省略行数不能省略列数)

        `int arr4[][3] = {1,2,3,4,5,6};`    
   -  二维数组名称
      -  用途
         1. 查看占用内存空间大小
            ```C++
            int arr[2][3] = {
                {1,2,3},
                {4,5,6}
            };
            cout << "二维数组占用内存空间为：" << sizeof(arr) << endl;
            cout << "二维数组第一行占用内存为：" << sizeof(arr[0]) << endl;
            cout << "二维数组第一个元素占用内存为：" << sizeof(arr[0][0]) << endl;
            ``` 
         2. 查看二维数组的首地址
            - `cout << arr << endl;`
            - `cout << arr[0] << endl;`
            - `cout << &arr[0][0] << endl;` 
            - 二维数组首地址就是第一行的首地址，也是第一个元素的地址   
## 函数
   - 函数的定义
      1. 返回值类型
      2. 函数名
      3. 参数列表
      4. 函数体语句
      5. return表达式
        ```C++
        返回值类型 函数名（参数列表）{

            函数体语句

            return 表达式
        }
        int sum(int num1, int num2){
            return num1 + num2;
        }
        ``` 
   - 函数的调用 
     - 语法 `返回值 = 函数名称(参数);` `int sum = sum(num1,num2);`
     - 函数定义时的参数为形参，函数调用时传入的参数为实参

   - 值传递
     - 当我们做值传递的时候，函数的形参发生改变，并不会影响实参
   - 函数的声明
     - 提前告诉编译器函数的存在
     - `返回值类型 函数名(参数列表);`
     - 声明可以写多次，但是定义只能有一次
   - 函数的分文件编写
     - 作用：让代码结构更加清晰
     - 四个步骤
       1. 创建后缀名为.h的头文件
       2. 创建后缀名为.cpp的源文件
       3. 在头文件中写函数的声明
       4. 在源文件中写函数的定义
     - 示例
       ```C++
       // 创建一个swap.h头文件,放函数的声明
       #include<iostream>
       using namespace std;

       void swap(int a, int b);

       ```

       ```C++
       // 创建一个swap.cpp源文件，放函数的定义
       #include "swap.h"
       #include<iostream>
       using namespace std;

       void swap(int a, int b){
           int temp = a;
           a = b;
           b = temp;

           cout << "a=" << a << endl;
           cout << "b=" << b << endl;
       }
       ```     

       ```C++
       // 使用
       #include<iostream>
       #include<swap.h>
       using namespace std;

       int main(){
           int a = 10;
           int b = 20;
           swap(a,b);
           system("pause");
           return 0;
       } 
       ```

## 指针
   1. 指针基本定义
      - 指针的定义语法：`数据类型 * 指针变量名;`
      ```C++
        int a = 10;
        int *p = &a;
      ``` 
      - 指针的使用：`*p;`
        - 通过解引用的方式来找到指针指向的内存，指针前加“*”代表解引用，可以操作（修改或读取）指针指向的内存中的数据

   2. 指针占用的内存空间
      - 在32位操作系统下，所有指针类型都是占用4个字节空间，64位下占8个字节 

   3. 空指针和野指针
      - 空指针  `int *p = NULL;`
        - 空指针用于给指针变量进行初始化
        - 空指针是不可以进行访问的 
      - 野指针  `int *p = (int *)0x1100;` ``or`` `int *p;`不给p初始化，p会随机指向一个地址
        - 指针指向一个非法的地址

   4. const修饰指针
       1. const修饰指针——常量指针
          - `const int *p = &a;`
          - 特点：指针的指向可以修改`p = &b;(√)`\
                  但是指针指向的值不可以修改`*p = 20;(×)` 
       2. const修饰常量——指针常量
          - `int* const p = &a;` 
          - 特点：指针的指向不可以改 `p=&b(×)`\
            指针指向的值可以改 `*p = 20;(√)`
       3. const既修饰指针，又修饰常量 
          - `const int* const p = &a;`
          - 特点：指针的指向和指针指向的值都不可以改 
        - 理解（看const修饰的是谁，即const后面紧跟的是谁）
          - *第一个是常量指针，常量在前说明const在最前面，修饰整个指针(int \*p)，那\*p就不能修改，*
          - *第二个是指针常量，指针在前常量在后，const修饰p，则p不能修改*
          - 不能修改的东西会报错**表达式必须是可修改的左值**
   5. 指针和数组
      - `int *p = arr;`
      - `*p === arr[0];`
      - `*p++ === arr[-1];`  
   6. 指针和函数
      - 值传递（每次都会复制一份数据，占用大量空间）
      - 地址传递
        - 通过函数修改实参的值
## 结构体
   1. 结构体的定义
      - 自定义数据类型，本质是一些类型集合 
      - 语法：`struct 结构体名{结构体成员列表}`
      ```C++
        struct Student{
          string name;
          int age;
          int score;
          Student(){}   // 默认构造函数，如果提供自定义构造函数需要显式写出来
          Student(int age) : age(age){}
          Student(int age, int score) : age(age), score(score){}
        };
      ```
   2. 结构体的使用\
      &emsp;&emsp;**通过结构体创建变量的方式有三种** \
      *结构体创建时可以省略struct关键字*
      - struct 结构体名 变量名
      ```C++
        struct Student s1;  // Student s1;也可以
        s1.name = "张三";
        s1.age = 18;
        s1.score = 100;
      ```
      - struct 结构体名 变量名 = {成员1值，成员2值...}
      ```C++
        struct Student s2 = {"李四", 19, 80};
      ```
      - 定义结构体时创建变量\
      ```C++
        struct Student{
          string name;
          int age;
          int score;
        }s3;
        s3.name = "王五";
      ```  
      - 使用结构体构造函数创建变量

      ```C++
      struct Student s1(18, 100);
      ```
   3. 结构体数组\  
      **创建结构体数组的步骤** 
      1. 定义结构体
      2. 创建结构体数组
      ```C++
        struct Student stuArray[3] = {
          {"张三", 18, 100},
          {"李四", 28, 99},
          {"王五", 38, 100}
        };
      ```
      1. 给结构体数组中的元素赋值\
      `stuArray[2].name = "赵六";`
      1. 遍历结构体数组
   4. 结构体指针
       1. 创建学生结构体变量\
       `struct student s = {"张三", 18, 100};`
       1. 令指针指向结构体变量\
       `student *p = &s;`
       1. 通过指针访问结构体变量中的数据\
       `p->name;`  `p->age;`
   5. 结构体嵌套结构体
   6. 结构体做函数参数\
      `struct student s;`
      1. 值传递\
      `void printStudent(struct student s);`\
      `printStudent(s);`
      通过值传递无法修改实参结构体中的数据
      1. 地址传递\
      `void printStudent(struct student* s);`
      `printStudent(&s);`
   7. 结构体中的const使用场景
      - 作用：防止误操作 
        - 将函数中的形参改为指针，可以减少内存空间，因为不会复制新的副本出来
        - 使用地址传递的话函数体内可能会出现误修改结构体参数导致实参也被改变
      ```C++
         void printStudent(const student *s){
            //用const修饰后这个函数就只能读取结构体信息而不能修改
            cout >> infomation >> endl;
         }
      ``` 

## 随机数生成
- 生成随机数

   `rand()`生成一个范围是0~RAND_MAX (32767) 的随机数
   ```C++
   生成[100，500]之间的随机数:

   int val = rand()%401+100;
   ```
   ```C++
   生成[0,100000]之间的随机数：

   int val = 100000/RAND_MAX*rand(); // 取出来的数不是连贯的
   ```
   这样每次运行生成的随机数都是相同的，需要在main函数或者调用rand的函数中添加随机数种子

- 添加随机数种子

   - 包含头文件

      `#include<ctime>`

   - 根据系统时间生成随机数

      `srand((unsigned int) time(NULL));`

## C++静态类型转换

`double b = 10;`

`int a = static_cast<int>(b);`

尖括号中是转换的目标类型
      
         
     

    

    