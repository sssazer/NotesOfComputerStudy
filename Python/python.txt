 python

解释的过程耗费时间导致运行速度慢

注释
单行注释：#   快捷键ctrl+/  
多行注释：三个单引号'''或三个双引号"""
平台注释：只用于linux系统，写在py文件最前面
  #!/usr/bin/python3    指定python解析器的路径   #!开头 + 路径
编码注释：（同上）
  #--coding=utf-8 --     指定编码格式（python3默认utf-8）

变量
变量是一段有名字的连续存储的空间，我们可以通过定义变量在申请并命名这样的存储空间，并通过变量的名字来使用这段存储空间
不需要指定数据类型
变量就是用来存储数据的
定义：变量名=数据  数据必须要有
          a = 10
*先开辟一段连续的内存空间，将10放入其中，然后将内存地址赋予栈中的a
--函数：type() 用于查看数据类型     print(type(a))

运算符
算数运算符
 **指数   a**b   优先级比乘除高
 //地板除  a//b 相除取整
比较运算符
逻辑运算符:  and        or          not   优先级   （）> not > and > or
赋值运算符（算术运算的一个补充）: =    +=     -=     *=     /=   %=   **=   //=     不可以直接打印print(a+=b)


输入与输出
格式化输出
1. 占位符：'%'   %后面跟的是变量的类型     print('我是%s，我来自%s' %(name,place))  不想自动换行的话在后面设置end参数为空格  print('我是%s，我来自%s' %(name,place),end=" ")
2. .format    print('姓名:{}' .format(name))
输入
--函数input()   a=input("请输入您的姓名：")             input函数读取的均为str（字符串）类型，需要数据转换  age = int(input("请输入您的年龄："))


流程控制
顺序流程

选择流程：
if 条件表达式:
    python代码
    pass
elif 条件表达式:
    python代码
    pass
elif 条件表达式:
     …………
else:
    python代码
    pass

可以用pass（空语句）表明if语句结束或者直接下一行顶格写

随机数生成：   import random
	       a = random.randint(0,2)

循环流程
一、while 条件表达式:                适用于对未知的循环次数
    python代码

二、for 临时变量  in  容器:           适用于已知的循环次数【可迭代对象遍历】
     执行代码块
语法特点：遍历操作，依次的取集合容器中的每个值
--函数 range(起始，结束，步长)  步长默认为1，不能为零，范围左闭右开    用于生成一个数据集合列表 如range（1，100）
for data in range(1,101)：
print（data）   遍历 1到100

break和continue

for-----else 与  while------else结构
for 临时变量给 in 容器：
   执行代码块
else：
    print('在上面的循环中只要出现了break，else的代码不再执行')            可以用于所有遍历结束时反馈，如查找数据时找不到数据给用户反馈

高级数据类型
列表 元组 字典 

序列：序列就是一组按照顺序排列的值【数组】
	优点：支持索引和切片（下标越界会报错，切片越界不会报错，最多不返回数据）
	特征：第一个正索引为0时，指向的是左端，第一个索引为负数时，指向的是右端
	切片：【高级特性】根据下标来获取序列对象任意部分数据    list[start:end:step]中间以：分割
--函数 id()    用于查看数据的内存地址
--函数len()  查看数据个数	
三种内置的序列类型：
字符串：
常用函数：strA.find（）,strA.index()，strA.startswith（）/endswith() ,strA.lower()/upper/swapcase()
strA.capitalize(),strA.strip()/lstrip()/rstrip()

列表
list
特点：1、支持增删改查
2、列表中的数据可以变化，但列表的内存地址不会改变
3、用[]来表示列表类型，数据项之间用逗号来分割，数据项可以是任何类型的数据
4、支持索引和切片来进行操作（增删改查）
常用功能:
增：listA.append(),listA.insert(),listA.extend()
删:del listA[], listA.remove()【删除指定元素】,listA.pop()【删除指定位置的元素】;
改: listA[0] = 
查:listA[],	listA.index;

元组
tuple
特点：1、是一种不可变的序列，在创建之后不能做任何修改（不能进行增删改，只能查）
2、用（）创建元组类型，数据项用逗号分隔
3、可以是任何的类型
4、当元组中只有一个元素时，要加上逗号，不然解释器会当作整形处理
5、同样支持切片操作
元组不能修改，但是元组中的列表可以修改
元组中只有一个元素时，后面要加一个逗号才是元组类型，否则还是元素本身的类型  tupleA = (1,)
常用功能:
查找
tupleA[],	tupleA.index()

字典
dict
以键值对的方式储存，用大括号包裹{'key':'value'}，可以储存任意对象  键不能重复，值可以重复
字典不是序列，不能通过索引查找，只能通过键查找值（效率很高）
也可以用dict函数创建，dictA=dict(a=1,b=b),等号左边为键
特点：1、不是序列，没有下标的概念，是无序的键值集合，是python中内置的高级数据类型
2、用{}表示字典对象，键值对用逗号分隔
3、键必须是不可变的数据类型
4、每个键必定是唯一的，如果存在重复的键，后面的键的值会覆盖前面的键值
常用功能:
增：dictA[key] = value
查:   dictA[key]
删： del dict[key],       dictA.pop[key]
改:    dictA[key] = newValue
获取所有键/值：dictA.keys()/dictA.values()/dict.items()   
   得到的类型分别为 dict_keys/dict_values/dict_items
深度copy：a和b是两个字典，如果直接令b=a，则传递的是a的引用，即两个字典指向同一个地址，修改值会相互影响
	from copy import deepcopy
	b=deepcopy（a）  # 此时传递的是a的值，两个字典不会相互影响

函数
代码的复用最大化以及最小化冗余代码

def  函数名（）：
      代码块

函数的分类：（根据函数的返回值和函数的参数）
无参数无返回值：一般用于提示信息打印
无参数有返回值：多用在数据采集中，比如获取系统信息
有参数无返回值：多用在设置某些不需要返回值的参数设置
有参数有返回值：一般是计算型的，需要参数，最终也要返回结果

函数参数的分类：
必选参数、默认参数【缺省参数】、可选参数、关键字参数 
返回值：如果函数内部有return，就可以返回实际的值，否则返回None

局部变量：在函数内部定义的变量，作用域局限在函数内部
	不同的函数内部可以定义相同的局部变量，互不影响
	作用：为了临时的保存数据，当函数执行完之后内部变量就无意义了
全局变量：在函数外部定义的变量，作用域的范围不同，在整个py文件中都可以使用
	全局变量和局部变量名字相同时，程序会优先使用函数内部定义的变量【强龙难压地头蛇】
如果想在函数内部对全局变量进行修改，必须使用global关键字进行声明

引用：
python中万物皆对象，在函数调用的过程中，实参传递的就是对象的引用（传递的是实参对应地址）

匿名函数：使用lambda关键字创建
	a=lambda 参数1,参数2……,参数n:执行代码语句
	特点:匿名函数冒号后面的表达式有且只有一个（是表达式而不是语句）lambda的设计就是为了满足简单函数的场景，仅仅能封装有限的逻辑
	       匿名函数自带return，而这个return的结果就是表达式计算后的结果
	       要使用一个变量来接收匿名函数，并通过这个变量来调用   a(实参1，实参2……实参n)
	       表达式可以是三元表达式（输出最大值：lambda x,y:x if x>y else y）        三元表达式:用来代替双分支if-else结构
	       匿名函数可以直接调用   print( (lambda x,y:x if x>y else y) (12,10) ) 在后面直接加括号写参数

递归函数：自己调用自己，必须有一个出口

Python内置函数
	常用 数学运算函数：abs（）求绝对值； round（x，n）x为浮点数，n为要保留的小数位，对浮点数进行近似取值（不是严格的四舍五入或四舍六入）
	类型转换函数：int(); float(); str(); ord(); chr()[输入一个ascall码转换为对应的字符]; bool(); bin()[转换为二进制]; hex()[转换为十六进制]; oct()[转换为八进制]; list()[将元组转化为列表，参数只能是元组]; tuple(); dict(); bytes(); 
	序列操作函数：all()判断可迭代参数中是否所有元素都是True;	any()与all相反;	sorted()排序，sort只能应用在list上;	reverse();range();zip();enumerate();

集合：一种数据类型，无序且不重复  不支持索引和切片

面向对象编程：oop[object oriented programming]
类：包括类名，属性和方法

__init__函数（Java中的构造器）：1、是python自带的具有特殊功能的内置函数（魔术方法）
2、是一个初始化的方法，用来定义实例属性和初始化数据，在创建对象的时候自动调用
3、可以传参来自定义初始化属性
__new__函数：1、魔术方法 还是一个静态方法
2、会返回一个新实例对象，默认存在，如果显式定义该函数，需要return创建的新对象，否则创建不成功
3、创建新对象时先调用new函数后调用init函数
__del__函数：1、魔术方法
2、当程序结束时会自动调用以清理对象，释放内存空间，释放完毕后对象就不能使用，del方法在类中默认存在
3、也可以手动调用del 来手动销毁对象，一般用于资源回收

self：self只有在类中定义实例方法时才有意义，在调用的时候不必传入self参数，解释器会自动传入
self和实例对象指向同一个内存地址，可以认为指的是实例对象本身（相当于Java中的this）
self的名称可以更改 可以定义成其他的名字

继承：定义类时在类名后面的括号中写父类名字 class A(B)
多继承(Python特有)：子类可以继承多个类 class A(B,C,D)
当对象调用方法时，先从所属类中查找，之后按继承时声明父类的顺序在父类中查找，之后按继承时声明父类的顺序在父类的父类中查找，依次类推，即一层一层找（广度优先） 可以用__mro__看继承关系（类名.__mro__）
子类中重写的__init__方法必须显式的调用父类的__init__方法才能用父类中的属性，或者用super().__init__方法，super可以自动找到父类

多态：定义是的类型和运行时的类型不一样，此时就称为多态
python本身就是多态语言，弱类型语言。多态即不检验函数中传入的参数类型。

类属性与实例属性：
类属性在方法外定义，实例属性在方法内定义。类属性属于类，实例属性属于实例对象所有
通过实例对象能访问类属性和实例属性，通过类只能访问类属性
所有实例对象都有一个类对象指针（保存类对象的地址）指向同一类对象。实例属性在每个实例中独有一份，而类属性是所有实例对象中共有一份
通过实例对象不能修改类属性，而是在实例对象里重新声明了一个实例属性覆盖了类属性，通过类才能修改类属性

类方法：在方法前加装饰器@classmethod 第一个参数必须是类对象
静态方法：在方法前加装饰器@staticmethod 可以不传任何参数，属于类对象所有
	一般情况下不会，没必要通过实例对象去访问静态方法
	静态方法主要来存放逻辑性代码，本身和类以及实例对象没有交互，不会涉及到类中方法和属性的操作

私有化属性：属性名以两个下划线开头
	私有化的属性不能在外部直接访问，可以在类的内部使用，子类不能继承私有化属性
私有化方法：方法名以两个下划线开头
protected类型变量：名字以单下划线开头
	后面单下划线没有特殊含义，只是避免属性名与python关键字冲突

property属性函数:使在函数外部通过对象.属性的方式调用私有方法使自动调用函数内部设置好的get、set方法
	方式一：先写函数的get、set方法，最后加一句 变量名=property(get方法函数名，set方法函数名) 函数名不加括号  变量名即为外部调用时的变量名
	方式二：先写函数的get、set方法，在方法上加修饰器，get方法前写@property set方法前写@变量名.setter   get，set方法名即为变量名
	
单例模式：一个类只有一个实例存在     网站计数器，权限验证模块，windows资源管理器，系统回收站，数据库连接池

错误与异常处理：尽量处理捕获到的错误，不需要在每个可能出错的地方去捕获，只要在合适的层次捕获就可以了
try:
	可能出现错误的代码块
except 错误类型A as msg：                   （可以用Exception来捕获所有异常）
	出错之后执行的代码块
except 错误类型B as msg
	出错之后执行的代码块
else：
	没有出错的话执行的代码块
finally：      多用于释放文件、数据库链接的资源等
	不管有没有出错都执行的代码块
自定义异常：直接或间接继承Error或Exception类，通过raise抛出，抛出后还是要用try——exception结构给接收


动态添加属性和方法：在运行的过程中添加
添加属性：直接对象名.要添加的属性=值   就可以了
添加方法：1、需要导入 types 
	2、写好要绑定的方法 方法中的第一个参数必须为self（如果是类方法的话则必须是cls）
	3、与实例对象绑定：对象名.要绑定的方法名（可以与被绑定方法名不一样）=types.MethodType(被绑定的方法名,要绑定的对象名)
	还可以给类绑定类方法和静态方法，只需要在写方法的时候加修饰器（绑定类方法和添加属性差不多）
__slots__属性：限制动态添加的属性，只有__slots__中有的属性才能被动态添加，__slots__属性子类不会继承
	用法 ：在定义类时直接定义：   __slots__=('允许的属性名','允许的属性名')

**魔术方法 __call__ 让实例对象可以像函数一样被调用： 实例对象名（）  就会直接调用类中的__call__函数

文件：
打开文件：file1 = open（‘文件的完整路径’，‘打开模式’,encoding='utf-8'）会返回一个file对象，默认情况下写入的编码形式是gbk
	打开模式：w 写，会覆盖已有文件   wb 以二进制的形式写，需要把str转化为byte，即在‘写的内容’后加.encode('utf-8')    a追加  ab二进制形式追加
写入文件：file.write('写的内容')
读取文件：打开方式r  只读
	file.read(num) num是要读取的字符，不填的话读取全部，读完后光标会留在上次独到的地方
	file.readline() 是读取一行
	file.readlines(num) 是按行读取全部，会返回一个列表，num可以指定读取第几行
	打开方式 rb 以二进制只读，对于文字来说需要进行解码
	file.read().decode('utf-8')
with上下文管理对象：为了防止最后忘记关闭文件，格式：with open() as 文件对象名：
文件定位：tell（），查看现在光标所在的位置 在gbk编码下一个汉字占两个位置，utf-8一个汉字占三个位置
	truncate（num），对原文件进行截取操作，num是要保留的字符数量
	seek（offset，from） 用于指定指针位置 from是枚举类型，0代表开头，1代表当前，2代表结尾，offset正数代表向后移几个，负数代表像前移几个
	如果没有用二进制的形式打开文件，只允许从二进制的开头开始计算相对位置，即from只能设置为0

模块
1、通过import导入   会导入模块中所有的功能   可以在导入时加一个别名  import... as... 取完别名之后就只能用别名调用
第三方模块的安装位置：python安装目录下的lib/site-packages/目录下   如果不知道python安装目录可以在cmd中用where python查找
2、from ...(模块名) import ...（要导入的函数名）导入模块  可以由选择性的导入几个函数    用这种方式导入可以直接用函数而不用通过模块名.的方式

os模块 对系统层面的文件进行操作

模块定义：在python中，一个.py文件就是一个模块
作       用：可以以库的形式封装功能，让调用者去使用，可以定义函数、类、变量，也能包含可执行的代码
	不同的模块可以定义相同的变量名，但是每个模块中的变量名作用域只是在本模块中
__all__=[]魔术变量：只有在__all__变量中存在的变量才能被from ** import * 方式导入，而import方式导入不受影响

垃圾回收机制：引用计数机制为主，标记-清楚和分代收集两种机制为辐
引用计数机制：可以用sys.getrefcount()查看引用的次数，当引用次数为0时自动释放内存
标记-清除机制：首先标记对象（垃圾检测），然后清除垃圾（垃圾回收）

小整数池：[-5,256]范围内的整数是python早就创建好的，可以直接拿来使用而不用重新创建对象

正则表达式与re模块
正则表达式规则：

元字符：
.   :匹配任意一个字符除了换行符\n
[abc]:  匹配abc中的任意一个字符
\d ：匹配一个数字，即0-9
\D：匹配非数字，即不是数字
\s ：匹配空白，即空格，tab键
\S ：匹配非空白，除空格，tab键
\w ：匹配单词字符，即a-z、A-Z、0-9、_
\W：匹配非单词字符
\n :  匹配换行符
\   ：匹配前面引用的分组

匹配字符数量：
*:前一个字符规则出现0次或者无限次，即可有可无
+：前一个字符规则出现一次或者无限次，即至少要有一次
?：前一个字符出现一次或零次，即最多出现一次
{m}：前一个字符出现m次，精准m次匹配
{m，}：前一个字符至少出现m次
{n，m}：前一个字符出现从n到m次

^:限定以^后面的内容开头      还可以表示否定、取反  [^xyz]集合内的字符不允许出现
$：限定以$前面的内容结尾

分组匹配：
|：匹配竖线左边或右边的表达式，先匹配左边，匹配到了就不会匹配右边
():括号内的是一组表达式 分组之后就可以用group（组号）来获取相应组的数据 组号不填默认为0，即获取匹配到的全部元素


转义字符：\  python中如果要表示\必须用\\  输出路径时要尤其注意  可以在字符串开头（引号外面）写个r来表示不用转义
	正则表达式在匹配路径时要用四个\     \\\\   
re中的一些方法：
re.compile 将正则表达式编译成一个正则表达式对象
re.search 在全文中匹配一次，匹配到就返回
re.findall 在全文中匹配全部符合正则表达式的结果，返回一个列表
re.sub 将查找到的目标替换，返回替换后的新字符串
re.subn  将查找到的目标替换，返回替换后的字符串和替换的个数，元组形式
re.split 分隔字符串

贪婪模式与非贪婪模式：
Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符，非贪婪则相反，总是尝试匹配尽可能少的字符
在数量词*、？、+、{m，n}后面加上？，使贪婪变成非贪婪