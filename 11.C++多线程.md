# 1. WINDOWS线程基本操作

线程相关函数均可在[MicroSoft官网](https://learn.microsoft.com/)查询

## 1.1 创建线程

### 1.1.1 导入头文件

创建线程需要使用windows提供的API，调用WIN API需要导入库`#include<windows.h>`

### 1.1.2 调用CreateThread函数

```C++
#include<windows.h>

using namespace std;

DWORD WINAPI ThreadProc(PVOID pParam){
    while(1);
    return 0;
}

// 此时就会有两个线程，
// 因为主线程mian和子线程ThreadProc都在死循环
int main(){

    HANDLE h = CreateThread(NULL, 0, ThreadProc, 0, 0, 0);

    while(1);
    CloseHandle(h);
    return 0;
}
```

**返回值：** HANDLE类型，句柄——也就是内核对象，用于管理线程

**参数说明：**

1. 指向SECURITY ATTRIBUTES结构体的指针，设置为NULL即可

2. 用于新线程的初始堆栈的大小，默认为0

3. 回调函数ThreadProc，在其中写 要创建的子线程 要完成的操作

    ```C++
    // 格式与名称必须如下所示
    // typedef unsigned long DWORD
    // typedef void *PVOID
    DWORD WINAPI ThreadProc(PVOID pParam){

    }
    ```

    - 返回值为DWORD，实际上是无符号长整型
    - 参数为PVOID类型，实际上是void*空白指针

        通过这个参数实现线程间通信(通过参数的传递)，void*意味着我们可以传入任意类型的参数，只需要在函数内解引用即可

4. 传递给回调函数ThreadProc的参数，以此实现主线程与子线程的数据共享

5. 可以设置创建此线程时将线程置为挂起状态

    - 0表示不挂起

    - CREARTE_SUSPENDED表示改期

6. 通常置为0

## 1.2 终止线程

### 1.2.1 线程函数返回

当线程函数ThreadProc正确执行完并返回后，线程自动终止，这是确保线程的所有资源被正确清楚的唯一方法

当线程函数返回时，会发生如下情况：

- 在线程函数中创建的所有C++对象将通过它们的析构函数正确撤销

- 操作系统将正确释放线程的堆栈使用的内存

- 系统将线程的退出代码设置为线程函数的返回值

- 系统将线程内核对象的引用计数-1

### 1.2.2 ExitThread函数强制结束

在线程函数内部调用ExitThread函数，来强制终止自身线程的运行

`void ExitThread(DWORD dwExitCode);`

**参数：** 线程的退出代码

结束线程时不会：

- 执行任何析构函数

- 完成任何自动清理

## 1.3 线程的挂起

**函数原型：** `DWORD SuspendThread(HANDLE hThread);`

**功能：**

传入一个线程的句柄以挂起该线程，用于调试程序而不是线程的同步

每个线程都有一个暂停计数，这意味着可以将线程挂起多次

**返回值：**

- 如果挂起成功，返回执行挂起函数前的暂停计数，并将暂停计数+1

- 如果挂起失败，返回-1

## 1.4 线程的恢复

**函数原型：** `DWORD ResumeThread(HANDLE hThread);`

**功能:** 

传入一个句柄以恢复指定线程。

实际上是将线程的暂停计数-1，如果-1后还不为0，则线程依旧为挂起状态

返回值：

- 如果执行成功，返回执行函数前的暂停计数，之后将暂停计数-1(暂停计数>0的话)

    - 如果返回0，说明线程原本就不是挂起状态，不需要恢复

    - 如果返回1，说明线程原本是挂起状态，但是执行完ResumeThread函数后已经重启线程

    - 如果返回值大于1，说明线程处于挂起状态，且执行完ResumeThread函数后依旧为挂起状态

- 如果执行失败，返回-1

## 1.5 设置线程的优先级

**函数原型：** `BOOL SetThreadPriority(HANDLE hThread, int nPriority);`

**功能：**

设置线程的优先级，线程创建时有默认优先级，最好不要修改

**参数：**

1. 要设置优先级的线程的句柄

2. 设置的优先级

**优先级：**

|优先级等级|宏|
|---|---|
|DILE 最低|THREAD_PRIORITY_IDLE|
|LOWEST 低|THREAD_PRIORITY_LOWEST|
|BELOW_NORMAL 低于标准||
|NORMAL 标准||
|ABOVE_NORMAL 高于标准||
|HIGHEST 高||
|TIME_CRITICAL 最高||

**返回值：**

函数执行成功返回非零值(True)，执行失败返回0(False)

# 2. WINDOWS下线程的同步互斥

```C++
unsigned int g = 0;

DWORD WINAPI ThreadProc(PVOID pParam) {	
	for (int i = 0; i < 10000000; i++) {
		g++; // 临界区
	}
	return 0;
}

int main() {

	HANDLE h = CreateThread(NULL, 0, ThreadProc, 0, 0, 0);

	for (int i = 0; i < 10000000; i++) {
		g++; // 临界区
	}

    //等待子线程执行完成后再打印g
	WaitForSingleObject(h, INFINITE); 
	cout << g << endl;

	CloseHandle(h);
	return 0;
}
```

此时全局变量g就是临界资源，直接通过`g++;`实现+1可能会导致两个线程同时写入，从而导致数据覆盖，最终输出不是2千万

## 2.1 原子操作

将g++用以下函数替换

- `Long InterlockedIncrement(LONG volatile *Addend);`

    在多线程中将传入的参数以原子操作的方式+1。参数必须是long或者无符号类型，返回值为加1后的结果

    使用：`InterlockedIncrement(&g);`

- InterlockedDecrement

    对变量以原子操作方式-1

- ```C++
    LONG InterlockedExchange(
    [in, out] LONG volatile *Target,
    [in]      LONG          Value
    );
    ```

    以原子操作用value给变量赋值，返回变量原来的值

- ```C++
    LONG InterlockedAdd(
    [in, out] LONG volatile *Addend,
    [in]      LONG          Value
    );
    ```

    计算两数相加的结果并赋予第一个参数Addend，返回运算结果

    使用：`InterlockedAdd(&g, 1);`

## 2.2 设置临界区CriticalSection

临界区只能用于同步单个进程中的线程

1. 实例化临界区对象

    `CRITICAL_SECTION g_sec;`

2. 在主函数中初始化临界区对象

    - `InitializeCriticalSection(&g_sec);`

    - `InitializeCriticalSectionAndSpinCount(&g_sec, dwSpinCount);`

        在单处理机下，第二个参数无效
        
        在多处理机下，如果临界区此时无法进入，
        则线程会在进入wait之前先继续占用CPU并自转d一段时间（由dwSpinCount规定）

        如果在自转的时间内临界区被释放，则该进程直接进入，无需wait

3. 进入临界区

    - `EnterCriticalSection(&g_sec);`

        如果临界区不可使用则将线程阻塞

    - `TryEnterCriticalSection(&g_sec);`

        此函数永远不会阻塞线程

        如果临界区可用，则返回True并进入临界区；如果临界区不可用，则返回False并继续往下执行(事实上往下执行的也是临界区)

        所以必须用if判断来确定是否应该让线程继续执行下去



4. 临界区代码......

5. 释放临界区

    `LeaveCriticalSection(&g_sec);`

6. 释放临界区对象

    `DeleteCriticalSection(&g_sec);`

## 2.3 Mutex

使用一个Mutex对象来实现不同进程间的同步互斥

Mutex对象是一个内核对象，任何时刻都处于两种状态之一：Signaled(信号态)和Nonsignaled(非信号态)

1. 定义一个HANDLE类型全局变量用于接收Mutex对象的句柄

    `HANDLE hMutex;`

2. 创建Mutex对象

    ```C++
    HANDLE CreateMutexA(
    [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,
    [in]           BOOL                  bInitialOwner,
    [in, optional] LPCSTR                lpName
    );

    hMutex = CreateMutex(NULL, FALSE, NULL);

    参数一：指向SECURITY_ATTRIBUTES结构体的指针
    参数二：创建Mutex对象的线程是否初始拥有该Mutex的使用权
            置为TRUE则拥有，同时Mutex对象引用计数为1，需要释放，
            FALSE则不拥有
    参数三：该Mutex对象的名字，可以没有名字(与控制Mutex对象的句柄变量名不是一个概念)

    返回值：控制Mutex对象的句柄
    ```

3. 申请Mutex

    等待单个线程/信号量
    ```C++
    DWORD WaitForSingleObject(
    [in] HANDLE hHandle,
    [in] DWORD  dwMilliseconds
    );

    WaitForSingleObject(hMutex, INFINIT);

    参数一：要等待的对象的句柄
            可以是Mutex对象的句柄，
            也可以是一个线程的句柄
    参数二：最大等待时间，单位是毫秒
            如果是INFINIT则无限等待
            0则不等待，函数总会立即返回

    返回值：返回 导致函数返回的事件 的编号
    ```

    成功申请到hMutex后会使其引用计数加一

    等待多个线程/信号量

4. 临界区代码......

5. 释放Mutex

    `ReleaseMutex(hMutex);`

    线程首先要有对目标Mutex对象的拥有权才能成功释放

    如果函数执行成功返回非0，执行失败返回0。
    
    执行成功后hMutex的引用计数-1，这并不意味着会释放hMutex。只有引用变量为0之后才会释放

6. 程序结尾要释放Mutex对象

    `CloseHandle(hMutex);`


# 3. C++11线程库——线程基本操作
