# 1. QuickStart

MyBatis是一个基于Java的持久层框架，原名ibatis

可以说是JDBC的封装，使用简单的XML或注解完成对数据库数据的操作

## 1.1 搭建开发环境

### 1.1.1 引入MyBatis依赖

```xml
<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.7</version>
</dependency>
```

### 1.1.2 创建MyBatis核心配置文件

文件名可以自定义，习惯上命名为 mybatis-config.xml，存放在`src/main/resources`目录下

整合Spring后这个配置文件可以省略

主要用于配置连接数据库的环境以及MyBatis的全部配置信息

这个配置文件的内容可以在官方文档中复制，官方文档可以在github中查看

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/mybatistest?serverTimezone=UTC"/>
        <property name="username" value="root"/>
        <property name="password" value="wangyize201"/>
      </dataSource>
    </environment>
  </environments>
<!--  引入mybatis的映射文件-->
  <mappers>
    <mapper resource="mappers/UserMapper.xml"/>
  </mappers>
</configuration>
```

在映射文件中写具体的mysql语句，因此需要将映射文件配置到核心配置文件中

### 1.1.3 创建mapper接口

mapper接口相当于以前的DAO层，区别在于mapper接口无需实现。mybatis会创建代理实现类，来将接口与配置文件中的sql语句相关联

接口命名规则：要操作的实体类+Mapper，比如UserMapper

```java
package com.sazer.ssm.mapper;

public interface UserMapper {
    int insertUser();
}
```

### 1.1.4 创建MyBatis映射文件

ORM：Object Relationship Mapping 对象关系映射 

比如一个pojo类对应一张表、一个属性对应一个字段（列）、一个对象对应一条记录（行）

**映射文件和mapper接口的映射：**

一个映射文件对应一个mapper接口，最好和对应的接口同名

- 同时需要保证mapper标签的namespace和mapper接口的全类名一致
- sql语句标签的id值要和对应的接口名一致

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sazer.ssm.mapper.UserMapper">
<!--    int insertUser();-->
    <insert id="insertUser">
        insert into t_user values(null, 'admin', '123456', 23, '男', 'admin@qq.com')
    </insert>
</mapper>
```

### 1.1.5 执行sql语句

1. 获取核心配置文件的输入流

   ```java
   InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
   ```

2. 获取sqlSessionFactoryBuilder对象

   顾名思义，用于sqlSessionFactory对象的构造

3. 获取sqlSessionFactory对象

   顾名思义，是sqlSession的工厂，用于生产sqlSession

4. 获取sqlSession对象

   sql会话对象，是MyBatis提供的操作数据库的对象

5. 获取mapper接口的代理实现类对象

   接口没办法直接创建对象，所以获取mapper对象是mybatis底层创建了实现类

6. 调用mapper接口中的方法操作数据库

7. 手动提交事务

   使用sqlSession默认是回滚，不会自动提交

   可以在创建sqlSession对象时设置自动提交

   ```java
   SqlSession sqlSession = sqlSessionFactory.openSession(true);
   ```

8. 关闭sqlSession

```java
@Test
public void testInsert() throws IOException {
    // 1. 获取核心配置文件输入流
    InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
    // 2. 获取SqlSessionFactoryBuilder对象
    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
    // 3. 获取sqlSessionFactory对象
    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
    // 4. 获取sqlSession对象
    SqlSession sqlSession = sqlSessionFactory.openSession();
    // 5. 获取mapper接口的代理对象
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    // 6. 指定对应方法操作数据库
    int result = mapper.insertUser();
    System.out.println(result);
    // 7. 提交事务
    sqlSession.commit();
    // 8. 关闭sqlSession对象
    sqlSession.close();
}
```

还有一种通过sqlSession对象，直接找到对应方法名进行执行的方法（getMapper底层也是调用这个方法）

```java
int result = sqlSession.insert("com.sazer.ssm.mapper.UserMapper.insertUser");
```

## 1.2 执行查询操作

**查询单个用户**

- UserMapper

```java
User getUserById();
```

- 映射文件

  需要使用resultType属性，指定查询结果的类型，即查询的结果要转化为的实体类

```xml
<!-- User getUserById()-->
<select id="getUserById" resultType="com.sazer.ssm.pojo.User">
	select * from t_user where id = 1
</select>
```

- 执行操作

```java
User user = mapper.getUserById();
```

**查询所有用户**

- UserMapper

```java
List<User> getAllUsers();
```

- 映射文件

  和查询单个用户相同

```java
<!-- User getAllUsers()-->
<select id="getAllUsers" resultType="com.sazer.ssm.pojo.User">
	select * from t_user
</select>
```

- 执行操作

```java
List<User> list = mapper.getAllUser();
```

## 1.3 核心配置文件

配置文件中标签的配置顺序是有要求的 顺序为：properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?

配置文件的内容可以在idea中创建一个模板，在settings - File and Code Templates，右边选择Files下添加模板

**environments**

在这个标签内部使用environment标签 配置连接数据库的环境，可以配置多个

使用default标签来表明当前要连接的数据库

**typeAliases**

设置类型别名，即为某个具体的类设置一个别名，在MyBatis范围中就可以使用别名表示一个具体的类型

如果不指定alias属性，则别名默认为类名，且不区分大小写

还可以使用package标签指定一个类名，则指定包下的所有类型将全部拥有默认别名（即类名，且不区分大小写）

```xml
<typeAliases>
    <typeAlias type="com.sazer.ssm.pojo.User" alias="abc"></typeAlias>
    <package name="com.sazer.ssm.pojo" />
</typeAliases>

<!-- 使用别名-->
<select id="getAllUser" resultType="abc">
	select * from t_user
</select>
```

**mappers**

引入mybatis的映射文件

由于每个mapper接口都要对应一个映射文件，配置起来比较麻烦

因此可以通过package标签来将一个目录下的映射文件全部自动配置

但是要保证 映射文件的位置 和mapper接口的位置一样。比如mapper接口在 main/java/com/sazer/ssm/mapper 目录下，则映射文件也要放在 resources/com/sazer/ssm/mapper目录下。并且mapper接口的名字和映射文件的名字必须一致

放在同一目录下之后，打包之后就在同一文件夹下了

```xml
<mappers>
	<package name="com.sazer.ssm.mapper" />
</mappers>
```

**properties**

可以使用properties标签引入配置文件，这样就可以在标签中通过`${变量名}`使用配置文件的内容

```xml
<properties resource="jdbc.properties" />

<environments default="development">
    <environment id="development">
        <transactionManager type="JDBC"/>
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.Driver}"/>
            <property name="url" value="${jdbc.url}"/>
            <property name="username" value="${jdbc.username}"/>
            <property name="password" value="$"/>
        </dataSource>
    </environment>
</environments>
```

# 2. 获取sql语句的参数

MyBatis提供了两种方式来为sql语句注入参数，`${}`和`#{}`，前面的本质是字符串拼接，后面的本质是占位符赋值

## 2.1 获取单个变量

比如通过用户名查询用户

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User getUserByUsername(String username);
}
```

**MyBatis映射文件**

其实在{}中可以通过任意字符来获取参数，但是建议使用形参的名字

```xml
<select id="getUserByUsername" resultType="User">
	select * from t_user where username = #{username}
</select>
```

如果使用${}也就是字符串拼接时，要手动加单引号

```xml
<select id="getUserByUsername" resultType="User">
	select * from t_user where username = '${username}'
</select>
```

**调用函数实现功能**

```java
User user = mapper.getUserByUsername("admin");
```

## 2.2 获取多个变量

### 2.2.1 使用多个形参

比如通过用户名和密码验证登录

需要多个变量时，MyBatis会将参数放在map集合中，以两种key来保存

- arg0、arg1、arg2......
- param0、param1、param2......

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User checkLogin(String username, String password);
}
```

**MyBatis映射文件**

由于在{}中可以通过任意字符来获取参数，所以其实就是不能使用形参名来获取参数

可以使用arg0，arg1或者param0，param1来获取指定位置的参数

```xml
<select id="checkLogin" resultType="User">
	select * from t_user where username = #{arg0} and password = ${arg1}
</select>
```

${}依然需要加单引号

**调用函数实现功能**

```java
User user = mapper.getUserByUsername("admin", "123456");
```

### 2.2.2 使用Map集合

也可以手动传入一个map集合来作为参数，这样的话就可以使用自定义的键来获取参数

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User checkLogin(Map<String, String> map);
}
```

**MyBatis映射文件**

由于在{}中可以通过任意字符来获取参数，所以其实就是不能使用形参名来获取参数

可以使用arg0，arg1或者param0，param1来获取指定位置的参数

```xml
<select id="checkLogin" resultType="User">
	select * from t_user where username = #{username} and password = #{password}
</select>
```

${}依然需要加单引号

**调用函数实现功能**

```java
Map<String, String> map = new HashMap<>();
map.put("username", "admin");
map.put("password", "123456");
User user = mapper.getUserByUsername("admin", "123456");
```

### 2.2.3 使用注解命名参数

可以使用@Param注解在value属性中指定键，来让MyBatis创建map集合时使用指定的键

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User checkLogin(@Param("username") String username, @Param("password") String password);
}
```

## 2.3 获取实体类变量

比如添加用户时，需要传入一个User实体类对象

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    void insertUser(User user);
}
```

**MyBatis映射文件**

可以直接使用属性名访问对应属性

```xml
<select id="checkLogin" resultType="User">
	insert into t_user values(null, #{username}, #{password}, #{age}, #{gender}, #{email})
</select>
```

${}依然需要加单引号

**调用函数实现功能**

```java
User user = new User(属性值);
User user = mapper.getUserByUsername(user);
```

# 3. 查询操作

## 3.1 查询一行数据

**mapper接口**

查询一行数据时，返回的应该是一个实体类对象

```java
public interface UserMapper {
    User getUserById(@Param("id") Integer id);
}
```

**MyBatis映射文件**

需要指定返回值类型为User类型

```xml
<select id="getUserById" resultType="User">
	select * from t_user where id = #{id}
</select>
```

**调用函数实现功能**

```java
User user = mapper.getUserById(0);
```

## 3.2 查询多行数据

**mapper接口**

查询多行数据时，返回的应该是一个List集合

```java
public interface UserMapper {
    List<User> getAllUsers(@Param("id") Integer id);
}
```

**MyBatis映射文件**

只需要指定返回值类型为User类型

```xml
<select id="getAllUsers" resultType="User">
	select * from t_user
</select>
```

**调用函数实现功能**

```java
List<User> users = mapper.getAllUsers();
```

## 3.3 查询一个数据值

**mapper接口**

查询一个数据时，返回的结果类型应该是那个数据的类型

```java
public interface UserMapper {
    Integer getCount();
}
```

**MyBatis映射文件**

只需要指定返回值类型为int类型

这个int实际上是MyBatis提前设置好的别名，原本应该写 java.lang.Integer

```xml
<select id="getCount" resultType="int">
	select count(*) from t_user
</select>
```

**调用函数实现功能**

```java
Integer count = mapper.getCount();
```

## 3.4 查询多个数据值

当查询的结果为多个数据时，比如查询员工总数、工资总和、工资平均值，或者查询的一行数据没有对应的实体类时，就像将这一行数据保存为一个map

则可以将数据保存在一个map集合中

### 3.4.1 保存为一个map

在表没有对应实体类的情况下，查询一行数据时，也可以将这一行数据保存为一个map，属性（字段）名就是key，值就是value。查询多行数据时，可以将多个User对象保存为map集合，每行对应一个map

**mapper接口**

```java
public interface UserMapper {
    Map<String, Object> getUserById(@Param("id") Integer id);
}
```

**MyBatis映射文件**

这个map实际上是MyBatis提前设置好的别名

```xml
<select id="getUserById" resultType="map">
	select * from t_user where id = #{id}
</select>
```

**调用函数实现功能**

```java
Map<String, Object> map = mapper.getUserById();
sout(map); //{password=123456, gender=男, id=1, age=23, email=admin@qq.com, username=admin}
```

### 3.4.2 保存为map集合

**mapper接口**

```java
public interface UserMapper {
    List<Map<String, Object>> getAllUsers();
}
```

**MyBatis映射文件**

这个map实际上是MyBatis提前设置好的别名

```xml
<!--    Map<String, Object> getUserById(@Param("id") Integer id);-->
<select id="getUserById" resultType="map">
    select * from t_user where id = #{id}
</select>
```

**调用函数实现功能**

```java
List<Map<String, Object>> res = mapper.getAllUsers();
System.out.println(res);
/* [{password=123456, gender=男, id=1, age=23, email=admin@qq.com, username=admin}, 
{password=123456, gender=男, id=2, age=23, email=admin@qq.com, username=admin}, 
{password=123456, gender=女, id=3, age=12, email=Tom@153.com, username=Tom}] */
```

### 3.4.2 保存为map嵌套map

一行数据对应一个map，在获取多行数据时，也可以将对应的map作为value保存，此时需要再将某个字段的值指定为key

**mapper接口**

```java
public interface UserMapper {
    @MapKey("id") // 指定key为数据中的id值
    Map<String, Object> getAllUsersToMap();
}
```

**MyBatis映射文件**

这个map实际上是MyBatis提前设置好的别名

```xml
<!--    Map<String, Object> getAllUsersToMap();-->
<select id="getAllUsersToMap" resultType="map">
    select * from t_user
</select>
```

**调用函数实现功能**

```java
Map<String, Map<String, Object>> res = mapper.getAllUsersToMap();
System.out.println(res);
/*{1={password=123456, gender=男, id=1, age=23, email=admin@qq.com, username=admin}, 
 2={password=123456, gender=男, id=2, age=23, email=admin@qq.com, username=admin}, 
 3={password=123456, gender=女, id=3, age=12, email=Tom@153.com, username=Tom}} */
```

# 4. 特殊SQL执行

## 4.1 模糊查询

模糊查询就是使用LIKE关键字，来找到符合匹配规则的记录

比如要查询用户名中包含指定字母的记录

**mapper接口**

```java
public interface UserMapper {
    List<User> getUserByLike(@Param("like") String like);
}
```

**MyBatis映射文件**

如果使用#{}来获取参数，也就是`like '%#{like}%'` ，由于#{}在单引号中，因此它会被当做字符串的一部分，而不会被当作是一个占位符来解析，因此无法完成赋值，有三种方式可以解决

1. 但是用${}是可以的，因为${}被当作字符串拼接

2. 或者用mysql中提供的字符串拼接函数concat

3. 用双引号 + #{}

```xml
<select id="getUserByLike" resultType="User">
    select * from t_user where user like '%${like}%'
</select>

<select id="getUserByLike" resultType="User">
    select * from t_user where user like concat('%', #{mohu}, '%')
</select>

<select id="getUserByLike" resultType="User">
    select * from t_user where user like "%"#{mohu}"%"
</select>
```

**调用函数实现功能**

找用户名中包含字母a的用户

```java
List<User> list = mapper.getUserByLike("a");
```

## 4.2 批量删除

`delete from t_user where id in (7,8)`

**mapper接口**

```java
public interface UserMapper {
    void deleteMultiUser(@Param("deleteId") String deleteId);
}
```

**MyBatis映射文件**

如果使用#{}，它会自动为获取的参数加上单引号，也就是变成 `delete from t_user where id in('9,10')`，无法执行

所以只能使用${}

```xml
<select id="getUserByLike" resultType="User">
    delete from t_user where id in (${deleteId})
</select>
```

**调用函数实现功能**

```java
mapper.deleteMultiUser("9,10");
```

## 4.3 动态设置表名

对于一个查询请求，可能有时候要从普通用户表中查询，有时候要从vip用户表中查询，因此需要动态指定表名

此时只能使用${}指定表名，因为表名不能加单引号

## 4.4 获取自增主键

在完成一个插入操作之后，获取刚刚插入的那条对应的id（因为id是自增自动分配的，而不是手动指定的）

**mapper接口**

自增主键不能作为方法返回值，因为对于更新操作，方法返回值只能是受影响的行数

```java
public interface UserMapper {
    void insertUser(User user);
}
```

**MyBatis映射文件**

通过useGeneratedKeys属性获取自增id

通过keyProperty属性设置将获取到的自增id保存在参数的哪个属性中，比如保存在传入的User参数的id属性中

```xml
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    insert into t_user values(null, #{username}, #{password}, #{age}, #{gender}, #{email})
</insert>
```

**调用函数实现功能**

```java
User user = new User(null, "Tom", "123456");
mapper.insertUser(user);
Integer id = user.getId(); // 创建该对象时没有id，但是添加完成之后，就将自增的id存入了user对象中
```

# 5.  映射关系（多表查询）

## 5.0 字段名映射

MySQL的命名规则是下划线，而java的命名规则是驼峰，名称不同会发生无法直接完成映射的情况

### 5.0.1 使用全局配置

在MyBatis的核心配置文件中设置一个全局配置，将下划线映射为驼峰

全局配置使用settings标签，settings标签的位置在properties标签之后

开启之后可以自动将mysql字段名 emp_id 映射为 empId

```xml
<settings>
	<setting name="mapUnderscoreToCamelCase" value="true" />
</settings> 
```

### 5.0.2 resultMap自定义映射

在MyBatis核心配置文件的标签中，不使用resultType指定返回类型，而是使用resultMap指定映射

**resultMap标签**

指定映射关系

- type属性：标明这个映射关系处理的是哪个实体类的映射关系
- id标签：处理主键和实体类中属性的映射关系
- result标签：处理普通字段和实体类中属性的映射关系

```xml
<resultMap id="empResultMap" type="Emp"> // type标明这是关于Emp类的映射
	<id column="emp_id" property="empId"></id> // id标签指定主键的映射关系
    <result column="emp_name" property="empName"></result> //result标签指定普通字段的映射关系
    <result column="age" property="age"></result>
</resultMap>
```

**select标签**

在resultMap属性中指定要使用的resultMap的id

```xml
<select id="getEmpById" resultMap="empResultMap">
	select * from t_emp where emp_id = #{empId}
</select>
```

## 5.1 多对一关系

多个员工在同一个部门中就是多对一关系，如果想在员工对象中保存该员工所在的部门信息，就需要使用一个 Dept 类型的属性

因此多对一关系就对应一个实体类对象

**需求：**

查询员工信息，并将员工所在的部门也查询出来保存在员工对象的属性中

如果想在查询员工信息时将Emp对象中的Dept属性也进行赋值，就需要进行多表查询，将员工所在部门信息也查到并注入成为一个Dept对象。

```xml
对应的查询语句：

<select id="getEmpById" resultMap="empAndDeptResultMap">
	select * from t_emp 
    left join t_dept on t_emp.dept_id = t_dept.dept_id
    where emp_id = #{empId}
</select>
```

现在要解决的问题就是将查到的Dept字段属性注入到Emp的一个Dept类型的属性中。

resultType肯定无法完成这个映射，只能使用resultMap

### 5.1.1 使用级联

**resultMap**

将dept中的字段，直接和emp的dept属性中的字段进行映射

```xml
<resultMap id="empAndDeptResultMap" type="Emp">
    <!--emp中的属性-->
	<id column="emp_id" property="empId"></id>
    <result column="emp_name" property="empName"></result>
    <!--dept中的属性-->
    <result column="dept_id" property="dept.deptId"></result>
    <result column="dept_name" propert="dept.deptName"></result>
</resultMap>
```

### 5.1.2 association标签

association标签专门用于处理多对一映射，也就是属性为实体类属性时

- property属性：指定要处理的属性名
- javaType属性：指定要处理的属性名对应的实体类

```xml
<resultMap id="empAndDeptResultMap" type="Emp">
    <!--emp中的属性-->
	<id column="emp_id" property="empId"></id>
    <result column="emp_name" property="empName"></result>
    <!--dept中的属性-->
    <association property="dept" javaType="Dept">
    	<id column="dept_id" property="deptId"></id>
        <result column="dept_name" property="deptName"></result>
    </association>
</resultMap>
```

### 5.1.3 分步查询

用多个语句分步查询，实际上就是用另一个查询的结果来填充一些属性值

比如先查出来员工，再根据员工表的部门id去部门表中查出部门信息

1. 通过员工id查询员工信息

   ```java
   public interface EmpMapper {
       Emp getEmpAndDeptByStepOne(@Param("empId") Integer empId);
   }
   ```

   在association中，用select指定要调用哪个查询语句来获得填入dept属性的信息，column表示要填入查询语句的参数

   ```xml
   <resultMap id="empAndDeptByStepResultMap" type="Emp">
       <!--emp中的属性-->
   	<id column="emp_id" property="empId"></id>
       <result column="emp_name" property="empName"></result>
       <!--dept中的属性-->
       <association property="dept"        select="com.sazer.ssm.mapper.DeptMapper.getEmpAndDeptByStepTwo"
                    column="dept_id">
       	
       </association>
   </resultMap>
   
   <select id="getEmpAndDeptByStepOne" resultMap="empAndDeptByStepResultMap">
   	select * from t_emp where emp_id = #{empId}
   </select>
   ```

2. 通过员工所在的部门id查询部门信息

   可以写在一个方法或者一个接口中，但是最好保持一张表对应一个mapper接口

   ```java
   public interface DeptMapper {
       Dept getEmpAndDeptByStepTwo(@Param("deptId") Integer deptId);
   }
   ```

   ```xml
   <select id="getEmpAndDeptByStepTwo" resultType="Dept">
   	select * from t_dept where dept_id = #{deptId}
   </select>
   ```

### 5.1.4 延迟加载

分步查询的一个好处是可以实现延迟加载

比如要查询带有部门属性的员工信息，如果开启延迟加载，则只会查询员工信息。只有使用到部门属性时（`emp.dept`），才会执行第二步去部门表中查询并给员工对象的dept属性赋值

**开启延迟加载**

需要在配置文件中设置两个属性

- lazyLoadingEnabled：延迟加载的全局开关

  默认为false，开启之后所有对象都会延迟加载

- aggressiveLazyLoading

  默认为false，开启时，所有方法的调用都会加载该对象的所有属性（也就是不延迟加载）

```xml
<!--需要将lazyLoadingEnabled设置为true，同时aggressiveLazyLoading设置为false才能开启延迟加载-->
<settings>
	<setting name="lazyLoadingEnabled" value="true"></setting>
    <setting name="aggressiveLazyLoading" value="false"></setting>
</settings>
```

**控制单个属性的延迟加载**

在开启全局延迟加载之后，还可以在单独的sql语句中指定是延迟加载还是立即加载

在association标签的fetchType属性中指定，lazy表示延迟加载、eager表示立即加载

```xml
<resultMap id="empAndDeptByStepResultMap" type="Emp">
    <!--emp中的属性-->
	...
    <!--dept中的属性-->
    <association property="dept" fetchType="eager"        select="com.sazer.ssm.mapper.DeptMapper.getEmpAndDeptByStepTwo"
                 column="dept_id">
    	
    </association>
</resultMap>
```

## 5.2 一对多关系

一个部门对应多个员工就是一对多关系，如果想在部门对象中保存部门中所有的员工，就需要使用 `List<Emp>` 

因此一对多关系就对应集合

**需求：**

根据部门id查询部门信息，并将该部门中的所有员工作为List集合保存在部门对象的属性中

查询语句：

```xml
<!--Dept getDeptAndEmpByDeptId(@Param("deptId") Integer deptId)-->
<select id="getDeptAndEmpByDeptId" resultMap="deptAndEmpResultMap">
	select * from t_dept 
    left join t_emp on t_dept.dept_id = t_emp.dept_id
    where t_dept.dept_id = #{deptId}
</select>
```

### 5.2.1 collection标签

专门用于一对多映射关系，即处理集合类型的属性

- property属性表示给对象中的哪个属性赋值

- ofType表示集合中保存的元素的类型

```xml
<resultMap id="deptAndEmpResultMap" type="Dept">
	<id column="dept_id" property="deptId"></id>
    <result column="dept_name" property="deptName"></result>
    <collection property="emps" ofType="Emp">
    	<id column="emp_id" property="empId"></id>
        <result column="emp_name" property="empName"></result>
    </collection>
</resultMap>
```

### 5.2.2 分步查询

1. 根据部门id查询对应的id

   ```xml
   <resultMap id="deptAndEmpResultMap" type="Dept">
   	<id column="dept_id" property="deptId"></id>
       <result column="dept_name" property="deptName"></result>
       <collection property="emps" 
                   select="com.sazer.ssm.mapper.EmpMapper.getDeptAndByStepTwo"
                   column="dept_id">
       	<id column="emp_id" property="empId"></id>
           <result column="emp_name" property="empName"></result>
       </collection>
   </resultMap>
   
   <!--Dept getDeptAndEmpByStepOne(@Param("deptId") Integer deptId)-->
   <select id="getDeptAndEmpByStepOne" resultMap="deptAndEmpResultMap">
   	select * from t_dept where t_dept.dept_id = #{deptId}
   </select>
   ```

2. 根据部门id查询部门内的员工

   ```xml
   <!--List<Emp> getDeptAndByStepTwo(@Param("deptId") Integer deptId)-->
   <select id="getDeptAndByStepTwo" resultType="Emp">
   	select * from t_emp where dept_id = #{deptId}
   </select>
   ```


# 6. 动态SQL

解决拼接SQL语句字符串的难题

## 6.1 if - 多条件查询

多条件查询，就是有多个where条件使用and连接

如果服务器传来了这个参数，就要加上这个条件，如果没有传来这个参数（此时值为null或者""空字符串），就不加这个条件查询

**if标签**

test属性表示如果满足test的表达式，就将if标签内的语句拼接到SQL语句中。在test属性中可以直接通过属性名访问参数

为了避免所有条件都不成立时，sql语句变为 `select * from t_emp where`，可以在where后面加一个恒成立的条件

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp where 1=1
    <if test="empName != null and empName != ''">
    	and emp_name = #{empName}
    </if>
    <if test="age != null and age !=''">
    	and emp_age = #{empAge}
    </if>  
</select>
```

**where标签**

也可以使用where标签解决上面条件不成立时多一个where的问题

可以实现的功能

- 有条件成立时，自动加上where关键字
- 没条件成立时，自动去除where关键字
- 当拼接的语句前有多余的and时，可以去除（只能去除语句前的and，语句后去不掉）

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp
    <where>
        <if test="empName != null and empName != ''">
            emp_name = #{empName}
        </if>
        <if test="age != null and age !=''">
            and emp_age = #{empAge}
        </if> 
    </where>
</select>
```

**trim标签**

用于在字符串前后添加或去掉前后缀

- prefix/suffix：在标签内容前/后 添加指定内容
- prefixOverrides/suffixOverrides：在标签内容前/后 去掉指定内容

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp
    <trim prefix="where" suffixOverride="and">
        <if test="empName != null and empName != ''">
            emp_name = #{empName} and
        </if>
        <if test="age != null and age !=''">
            emp_age = #{empAge}
        </if> 
    </trim>
</select>
```

**choose、when、otherwise**

when和otherwise标签是choose标签的子标签，相当于if-else if-else

当找到test属性为true的when标签之后，就不会继续判断下面的when标签，所以最多只会添加一个查找条件

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp
    <where>
		<choose>
        	<when test="empName != null and empName != ''">
            	emp_name = #{empName}
            </when>
            <when test="age != null and age != ''">
            	age = #{age}
            </when>
        </choose>
    </where>
</select>
```

## 6.2 foreach

用于遍历集合类型的参数，有以下属性

- collection：要遍历的集合

  如果参数由@Param修饰，则使用@Param指定的值访问

  如果没有，则默认要填 list

- item：声明一个变量名，用于表示集合中遍历到的数据

- separator：foreach拼接的语句之间的分隔符

- open：拼接的字符串以什么开始

- close：拼接的字符串以什么结束

- index：获取当前遍历到的下标

### 6.2.1 批量添加

```xml
<!--void insertMultiEmp(@Param("emps") List<Emp> emps)-->
<insert id="insertMultiEmp">
	insert into t_emp values
    <foreach collection="emps" item="emp" separator=",">
    	(null, #{emp.empName}, #{emp.age})
    </foreach>
</insert>
```

执行完之后拼接好的sql语句为 `insert into t_emp values (null, "Tom", 18),(null, "Jerry", 25),(null, "Mary", 30)`

### 6.2.2 批量删除

**使用 in 关键字**

```xml
<!--void deleteMultiEmp(@Param("empIds") Integer[] empIds);-->
<delete id="deleteMultiEmp">
	delete from t_emp where emp_id in
    <foreach collection="empIds" item="empId" separator="," open="(" close=")">
        #{empId}
    </foreach>
</delete>
```

拼接之后的sql语句为：`delete from t_emp where emp_id in(1, 2, 3)`

**使用 or 关键字**

```xml
<!--void deleteMultiEmp(@Param("empIds") Integer[] empIds);-->
<delete id="deleteMultiEmp">
	delete from t_emp where 
    <foreach collection="empIds" item="empId" separator="or">
        emp_id = #{empId}
    </foreach>
</delete>
```

拼接之后的sql语句为：`delete from t_emp where emp_id = 1 or emp_id = 2 or emp_id = 3`

## 6.3 sql标签

可以用sql标签来记录一个sql语句片段，之后在需要使用的地方用include标签来引入

比如将表中所有字段名记录下来，就可以代替 * 

```xml
<sql id="empColumns">
	emp_id, emp_name, age, gender
</sql>

<select id="getAllEmp" resultType="Emp">
	select <include refid="empColumns"></include> from t_emp
</select>
```

# 7. 缓存

将查询到的数据进行缓存，这样下次执行相同的查询时，就可以直接返回结果，而不用再去数据库中查询

## 7.1 一级缓存

一级缓存是SqlSession级别的，即通过同一个SqlSession查询的数据会被缓存。一级缓存默认开启

下次使用相同的SqlSession查询相同的数据，才会从缓存中直接获取

**一级缓存失效的情况**

使用不同的SqlSession进行查询 或者 同一个SqlSession但是查询条件不同 时，不符合缓存条件

- 同一个SqlSession两次查询期间执行了任意一个增删改操作

- 手动清除缓存

  `sqlSession.clearCache();`

## 7.2 二级缓存

二级缓存是SqlSessionFactory级别，即通过同一个SqlSessionFactory创建的SqlSession查询的结果都会被缓存。二级缓存默认不会开启

**开启二级缓存**

1. 在核心配置文件中，设置全局配置属性cacheEnabled为true

   这个默认就是true，不需要设置

2. 在mapper映射文件中设置标签 `<cache/>`

   就在映射文件写上  `<cache />` 即可

3. 二级缓存必须在SqlSession关闭或提交之后有效

   一个SqlSession完成查询之后，会先把结果保存至一级缓存中。此时必须关闭（调用close函数）该SqlSession才会将结果上传至二级缓存。

4. 查询的数据所转换的实体类类型必须实现序列化接口

   ```java
   public class Emp implements Serializable {
       
   }
   ```

**二级缓存失效情况**

二级缓存不能手动清除

- 两次查询期间执行了任意一个增删改操作（会使一级和二级缓存同时失效）

