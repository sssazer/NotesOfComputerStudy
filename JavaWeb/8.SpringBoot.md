# 1. QuickStart

SpringBoot是一个高级框架，用于整合Spring技术栈

## 1.1 HelloWorld

1. 创建Maven程序

   需要在POM.xml配置文件中指定一个父项目，用于依赖管理

   ```xml
   <parent>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-parent</artifactId>
       <version>2.3.0.RELEASE</version>
   </parent>
   ```

2. 配置依赖

   SpringBoot提供了一系列starter依赖，只需要导入这一个依赖即可解决实现该功能所需所有依赖

   ```xml
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
   </dependencies>
   ```

3. 编写主程序类

   即整个SpringBoot程序的入口

   ```java
   package com.sazer.boot;
   
   @SpringBootApplication
   public class MainApplication {
       
       public static void main(String[] args){
           ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
       }
   }
   ```

   写法固定，返回值是一个IOC容器，可以通过这个IOC容器来获得其中的所有组件，比如

   `MyConfig bean = run.getBean(MyConfig.class);`

4. 编写控制器代码

   **注意：** controller包或者说Controller类一定要和主程序类在一个包下，否则Spring的组件扫描会扫描不到controller类，从而导致无法完成映射，报404错误

   ```java
   package com.sazer.boot.controller;
   
   // @Controller
   // @ResponseBody 表示该类中所有方法都带有@ResponseBody注释，该注释表示方法返回值直接返回给浏览器
   
   @RestController // 这个注解相当于上面两个注解相加
   public class HelloController {
   
       @RequestMapping("/hello")
       public String hello() {
           return "Hello SpringBoot2!";
       }
   
   }
   ```

5. 启动项目并测试

   无需配置Tomcat服务器，SpringBoot中已经整合完成

   只需要执行main方法即可

## 1.2 依赖管理

SpringBoot项目需要继承一个父项目spring-boot-starter-parent，该项目又继承于spring-boot-dependencies，这个项目的主要作用就是依赖管理，在其中导入了开发所需要的大多数依赖，并已经做好了版本控制。

我们只需要导入对应场景的starter依赖（命名为`spring-boot-starter-*`，*表示对应的开发场景），即可导入全部相关依赖，并自动做好版本控制。

如果需要对于某个依赖进行单独的版本指定，则需要到spring-boot-dependencies中找到对应的依赖，并找到指定其版本的属性名，之后在自己项目的pom.xml中重新指定这个属性即可

```xml
比如mysql的依赖
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>${mysql.version}</version>
    <exclusions>
        <exclusion>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
        </exclusion>
    </exclusions>
</dependency>

则我们可以在自己项目的配置文件中重新设置该属性
<properties>
	<mysql.version>5.1.43</mysql.version>
</properties>
```

## 1.3 自动配置

**已有组件的开启**

SpringBoot集成了很多组件，并自动实现了一些默认配置，比如：

- SpringMVC的常用组件

  比如DispatcherServlet、CharacterEncoding

- 开启组件扫描component-scan

  默认将主程序所在的包开启了组件扫描，也就是和主程序在同一个包下的类都能被扫描到

  也可以手动指定要扫描的包，在主程序类的@SpringBootApplication注解中使用scanBasePackages属性

  `@SpringBootApplication(scanBasePackages="com.sazer")`



除此之外，SpringBoot还将所有应用的配置都集成到了一个配置文件中 `application.properties`，通过修改这一个配置文件，就可以修改所有的配置

比如更改Tomcat服务器启动端口

```properties
server.port=8989
```

具体支持更改的配置可以参考 [官网文档](https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/appendix-application-properties.html#server-properties)

**自定义组件**

自定义SpringMVC功能组件的入口都是自定义配置类WebMvcConfigurer，只需要给容器中添加WebMvcConfigurer即可

WebMvcConfigurer接口中提供了自定义功能组件的各种方法，只需要创建这个接口的对象（并添加到容器中）并对自定义组件对应的方法进行重写即可。

```java
@Configuration
public class WebConfig{ // springboot配置类
    // 定制化SpringMVC的功能
    @Bean
    public WebMvcConfigurer webMvcConfigurer(){
        return new WebMvcConfigurer() {
            // 在这里面重写对应的方法以定制对应的功能
        }
    }
}
```



# 2. @SpringBootApplication详解

这个注解相当于以下三个注解

```java
@SpringBootConfiguration // 就相当于@Configuration注解
@EnableAutoConfiguration
@ComponentScan("com.sazer.boot") // 组件扫描注解，默认将主程序类所在的包开启组件扫描
```

下面主要讲解一下@EnableAutoConfiguration注解的底层原理

## 2.1 底层用到的注解

### 2.1.0 @Configutaion

给一个类加上@Configuration注解，这个类就是Spring的配置类，用于代替Spring的配置文件

```java
@Configuration
public class MyConfig {
}
```

### 2.1.1 proxyBeanMethods属性

@Configuration注解中有一个proxyBeanMethods属性，通过这个属性来设置是否保存代理对象

- true（默认）：Full模式，MyConfig对象中会保存代理对象
- false：Lite模式，不会保存代理对象

```java
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
MyConfig myConfig = run.getBean(MyConfig.class); // 获得myConfig对象
User user1 = myConfig.user01(); 
User user2 = myConfig.user01(); 
```

在Full模式中，user1和user2会返回同一个对象。这是因为每次调用方法SpringBoot都会进行检查，看IOC容器中是否有该对象。

在Lite模式中，user1和user2每次调用都会创建新的对象。也就是说SpringBoot不会检查，启动就比较快。

**应用场景**

组件依赖，当存在组件依赖时，要使用Full模式，也就是设置为true

不存在组件依赖时，可以设置为false减少判断和检查

### 2.1.2 @Bean 注册对象

（和直接在类上使用@Component、Controller、Service标签功能相同）

在配置类中，给方法加上@Bean标签来注册一个对象到IOC容器中

- 对象ID默认是方法名，也可以在@Bean注解中使用value属性指定
- 返回值即为注册的Bean对象
- 注册的bean对象依然是单实例

```java
@Configuration
public class MyConfig {
    @Bean("zhangsan")
    public User user01() {
        return new User("zhangsan", 18);
    }
}
```

**获取bean对象**

主程序入口的SpringApplication.run函数返回值是一个IOC容器，可以通过IOC容器来获取这个bean对象

```java
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
User zhangsan = run.getBean("zhangsan", User.class);
```

### 2.1.3 @Import 注册对象

使用@Import可以自动创建指定类的对象（无参构造器创建）并注册到IOC容器中

```java
@Import({User.class})
@Configuration
public class MyConfig {

}
```

### 2.1.4 @ConditionOn条件装配

@ConditionalOn*** 注解：当满足条件时才注册组件，否则不注册组件

其中***是具体类型的条件

可以加在类和方法上

- 加在类上：满足条件时类才生效
- 加在方法上：满足条件时注册方法的组件

在springboot底层大量使用了这个注解，因此当想要开启某个功能（组件）时，就需要在底层查看组件的开启条件

### 2.1.5 配置绑定

将properties配置文件中的属性注入到指定对象中，需要将属性信息写在SpringBoot的核心配置文件application.properties中

```properties
mycar.name=BYD
mycar.price=100000
```

**方法一**

在要注入的对象上使用@ConfigurationProperties组件，必须将该对象也注册到IOC容器中才行

```java
@Component
@ConfigurationProperties(prefix = "mycar") // 指定前缀
public class Car{
    String name;
    int price;
}
```

**方法二**

依然要指定前缀，不过这次在Config类上使用注解给指定类开启配置绑定功能

这个注解可以开启配置绑定功能并将指定类的对象注册到IOC中

```java
@EnableConfigurationProperties(Car.class)
public class MyConfig{
    
}
```

# 3. yaml配置文件

YAML：YAML（Yet Another Markup Language） Ain't Markup Language，薛定谔的标记语言

通常用于编写配置文件

## 3.1 基本语法

**语法规则**

使用`k: v` k冒号空格v表示一个键值对

使用缩进的空格表示层级关系，缩进的空格数不重要，相同层级元素左对齐即可

使用`#`注释

**数据表示案例**

- 字面量：即基本变量，单个不可再分的值

  直接写在v中即可，字符串无需在引号中。

  如果加引号，则双引号不会转义，单引号会转义。比如`a \n b`，双引号会输出换行，单引号会输出`\n`

- 对象：对象，或者map，可以表示为键值对的集合

  行内写法（json写法）

  ```yaml
  k: {k1:v1, k2:v2}
  ```

  yaml写法

  ```yaml
  k:
    k1: v1
    k2: v2
  ```

- 数组：比如array、list等按次序排列的值

  行内写法

  ```yaml
  k: [v1,v2,v3]
  ```

  yaml写法

  ```java
  k:
    - v1
    - v2
    - v3
  ```

# 4. web开发

在web开发场景中，用到的依然是spring和springMVC中的东西，springboot只是对经常用到的场景进行了自动配置，可以被看作是框架的框架

## 4.1 常用场景

### 4.1.1 静态资源访问

将静态资源放在项目根目录下的`/static` `/public` `/resources` `/META-INF/resources` 文件夹下，即可使用`ip:port/静态资源名`访问到静态资源

原理是springboot自动配置了一个Dispatcher，对/**请求进行静态映射，即全部请求。当浏览器发送请求时优先检验controller中配置好的动态请求，如果匹配不到就去寻找对应的静态资源。

**修改静态资源访问前缀**

默认前缀是/**，即直接使用`/静态资源名`访问，可以在yaml配置文件中进行配置修改

```yaml
spring:
  mvc:
    static-path-pattern: /resources/**
```

配置完成后访问静态资源就需要使用`ip:port/resources/静态资源名`  进行访问

注意：修改前缀会导致index页面和Favicon功能失效

### 4.1.2 index欢迎页

即访问项目根路径时，默认展示index页面

要实现上面的功能，springboot提供两种方式

- 在静态资源路径下放一个index.html
- 在controller中配置处理`/index`请求

### 4.1.3 网站图标Favicon

直接将网站图标`favicon.ico`（必须以这个名字命名）放在静态资源路径下

## 4.2 请求处理

用springboot如何处理浏览器发来的请求

### 4.2.1 REST映射

REST风格请求就是将 查/增/删/改 四种类型请求分别用GET/POST/DELETE/PUT请求表示

其中浏览器发送DELETE和PUT请求需要用到hiddenmethodfilter来进行转换，但是客户端（比如用POSTMAN模拟请求发送）可以直接发送请求PUT和DELETE请求，就无需开启hiddenmethodfilter

**在springboot中开启hiddenmethodfilter**

springboot底层配置了这个过滤器，但是增加了条件装配，需要手动在配置文件中配置才能开启

```yaml
mvc:
  hiddenmthod:
    filter:
      enabled: true
```

**页面表单发送REST请求**

在表单中加入一个隐藏域_method，在这个域的值中指定发送请求的类型

DELETE请求：

```html
<form action="/user" method="post">
    <input name="_method" type="hidden" value="DELETE" />
    <input value="REST-DELETE 提交" type="submit" />
</form>
```

PUT请求：

```html
<form action="/user" method="post">
    <input name="_method" type="hidden" value="PUT" />
    <input value="REST-DELETE 提交" type="submit" />
</form>
```

**Controller接收REST请求**

在RequestMaping注解中指定method属性

```java
@RequestMapping(value = "/user", method = RequestMethod.PUT)
public String putUser(){
    return "put-张三";
}
```

spring中也派生了方法对应的注解

```java
@PutMapping("/user")
public String putUser(){
    return "put-张三";
}
```

### 4.2.2 参数解析

解析并填充Controller中定义的参数，Controller中定义的参数可以用来获取浏览器发来的请求中的信息，如请求的参数，请求头等

参数解析的底层原理大致是，根据注解和参数类型找到对应的参数解析器HandlerMethodArgumentResolver，再调用对应参数解析器解析出参数

**获取浏览器传参**

- REST风格传参

  REST风格传参是指用`/`分隔将参数直接放在url中返回给服务器，比如`/car/1/owner/zhangsan`

  这种情况可以使用@PathVariable注解获取参数

  ```java
  // 根据参数名单独获取
  @RequestMapping("/car/{id}/owner/{username}")
  public String getCar(@PathVariable("id") Integer id,
                      @PathVariable("username") String name){
      
  }
  
  // 将所有参数封装到一个Map集合中
  @RequestMapping("/car/{id}/owner/{username}")
  public String getCar(@PathVariable Map<String, String> parameters){
      parameters.get("id") == 1;
      parameters.get("username") == "zhangsan";
  }
  ```

- queryStri方式传参

  是指在url后面使用`?key=value&key=value`的方式传参

  这种情况使用@RequestParam注解获取参数

  ```java
  // 请求url：localhost:8080/car?age=18&interests=basketball&interests=game
  // 根据参数名单独获取
  @RequestMapping("/car")
  public String getCar(@RequestParam("age") Integer age,
                      @RequestParam("interests" List<String> interests)){
  	// 由于interests对应多个值，因此使用list接收
  }
  
  // 获取所有参数
  @RequestMapping("/car")
  public String getCar(@RequestParam Map<String, String> params){
  }
  ```

- 获取POST请求的请求体

  使用@RequestBody注解

  ```java
  @PostMapping("/save")
  public Map postMethod(@RequestBody String content) {
      // content中以json字符串格式包含了请求体中所有信息
  }
  ```

- 获取矩阵变量

矩阵变量也是在url中传递参数的一种方式，不如queryString常见

开启矩阵变量：

springboot默认禁用，需要手动开启

```java
// WebConfig为自定义配置类
// springboot默认配置的路径解析器在WebMvcConfigurer中，因此要实现该接口并重写里面的方法
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    // 默认的路径解析器为urlPathHelper，它有一个属性叫removeSemicolonContent，即是否移除分号后面的内容，默认为true，改为false即可
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        UrlPathHelper urlPathHelper = new UrlPathHelper();
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    }
}
```

解析矩阵变量：

矩阵变量可以出现在任何路径片段中，每一个矩阵变量用分号隔开，一个矩阵变量的多个值用逗号隔开，比如：`localhost:8080/car/sell;low=34;brand=byd,benz`，其中`/car/sell`是路径，后面的是矩阵变量

```java
// /car/sell;low=34;brand=byd,benz
@RequestMapping("/car/{path}") // 矩阵变量绑定在路径中，因此要用url变量{path}代替/car/后面内容
public String carSell(@MatrixVariable("low") Integer low,
                     @MatrixVariable("brand") List<String> brands)
```

- 数据绑定：pojo封装参数

  将浏览器发来的参数（GET/POST请求都可以）直接封装到对应的Pojo对象中，要求参数名和属性名相同

  ```java
  @PostMapping("/saveuser")
  public User saveuser(User user) {
      
  }
  ```

  

**获取浏览器信息**

- 获取请求头

使用@RequestHeader获取请求头

```java
// 获取指定请求头
@RequestMapping("/car/{id}/owner/{username}")
public String getCar(@RequestHeader("User-Agent") String userAgent){
}

// 获取所有请求头
@RequestMapping("/car/{id}/owner/{username}")
public String getCar(@RequestHeader Map<String, String> header){
}
```

- 获取cookie值

使用@CookieValue获取cookie值

**获取Request域中数据**

一般是当别的请求转发过来时，获取保存在Request域中的数据

使用@RequestAttribute获取，也可以直接用HttpServletRequest对象接收

```java
// 比如在上一个Controller中往Request域中存了一些数据
HttpServletRequest request = new HttpServletRequest();
request.setAttribute("msg", "abc");

// 使用@RequestAttribute注解获取指定数据
@RequestMapping("transfer")
public String transferredPage(@RequestAttribute("msg") String msg) {
    
}

// 直接获取整个HttpServletRequest对象
@RequestMapping("transfer")
public String transferredPage(HttpServletRequest request) {
    
}
```

## 4.3 返回响应数据

服务器接收到浏览器发来的请求之后，经过一些处理返回给浏览器需要的数据，就是返回响应数据

在简单开发场景中，可以直接返回一个页面；在前后端分离业务中，大多只返回数据，比如返回json数据

### 4.3.1 返回json数据

springboot已经集成了返回json数据功能，底层使用jackson库进行json字符串转化

只需要在Controller方法上添加@ResponseBody注解（或在Controller类上使用@RestController注解），并在Controller方法中返回Pojo类型，即可自动转化为json返回给浏览器

```java
@RestController
public class ResponseTestController {
    @GetMapping("/test/person")
    public Person getperson() {
        return new Person();
    }
}
```

**底层原理**

springboot底层使用returnValueHandlers来处理对应类型的返回值。

对于标注了@ResponseBody的注解，会使用RequestResponseBodyMethodProcessor处理器处理

Processor处理器接下来会找到合适的MessageConverter进行处理，MessageConverter的作用就是把一种类型的数据转化为另一种类型，在当前场景就是把Controller返回值类型转化为媒体类型（和浏览器进行内容协商确定媒体类型）

Jackson2HttpMessageConverter能处理所有类型的返回值数据，只支持转化为json类型数据，符合要求，因此由它负责把Person转化为json

### 4.3.2 内容协商

根据客户端接收能力不同，返回不同媒体类型的数据。内容协商的关键步骤是寻找合适的MessageConverter进行类型转换。

通过内容协商机制，可以让Controller方法根据不同客户端请求返回不同类型的数据

客户端能接收的数据类型在请求头中的Accept字段声明

**客户端返回数据完整流程**

以标注了@ResponseBody注解的Controller为例，@ResponseBody注解使用RequestResponseBodyMethodProcessor处理器处理

处理器使用MessageConverterMethodProcessor来找到合适的MessageConverter进行处理

1. 首先获得acceptableTypes（浏览器可以接收的媒体类型，在请求头的Accept字段）和producibleTypes（当前服务器中所有MessageConverter都支持把Person对象转化为什么类型）
2. 将这两个List进行最佳匹配（双重for循环），找到一个浏览器能接收且服务器能转换的媒体类型
3. 找到能够将Person转化为对应媒体类型的MessageConverter，并进行转化

**客户端发送数据指定接收媒体类型**

默认是用请求头方式，此时在请求头的Accept字段中

也可以将想要接收的媒体类型放在url中发送给服务器

**自定义MessageConverter**

在WebMvcConfigurer对象中重写extendMessageConverters方法  

```java
@Bean
public WebMvcConfigurer webMvcConfigurer(){
    return new WebMvcConfigurer() {
        @Override
        public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
            converters.add(new MyMessageConverter);
        }
    }
}
```

```java
// 泛型中指定能处理的数据类型
public class MyMessageConverter implements HttpMessageConverter<Person> {
    
}
```

## 4.4 视图解析

如果想要在接收请求之后让浏览器跳转到一个页面，就需要给浏览器返回一个页面，此时就需要用到视图解析技术，将数据动态填充到html页面中并返回

springboot不支持jsp，可以使用thymeleaf，和jsp语法类似

### 4.4.1 thymeleaf

首先引入spring-boot-starter-thymeleaf依赖

springboot已经自动配置好了Thymeleaf，配置值在ThymeleafProperties中，SpringTemplateEngine和ThymeleafViewResolver也配置好了

默认前后缀为`classpath:/templates/` 和 `.html`

## 4.5 拦截器

拦截器在处理请求前执行，拦截指定规则的请求以在请求前后进行一些操作

1. 创建拦截器

   ```java
   public class LoginInterceptor implements HandlerInterceptor{
       // 重写preHandle、postHandle和afterCompletion方法
   }
   ```

2. 配置拦截器

   ```java
   @Configuration
   public class WebConfig implements WebMvcConfigurer {
       @Override
       public void addInterceptors(InterceptorRegistry registry) {
           registry.addInterceptor(new LoginInterceptor())
               .addPathPatterns("/**") // 配置拦截路径规则，/**表示拦截所有请求，包括静态资源
               .excludePathPatterns("/", "/login", "/css**", "/fonts/**", "/images/**", "/js/**"); // 配置不拦截的请求
       }
   }
   ```

## 4.6 文件上传

获取用户上传来的文件

- 前端form表单

  ```html
  <form role="form" th:action="@{/upload}" method="post" enctype="multipart/form-data">
      <!-- 单文件上传 -->
      <div class="form-group">
          <label for="exampleInputFile">头像</label>
          <input type="file" name="headerImg" id="exampleInputFile">
      </div>
      <!-- 多文件上传，在input标签中添加一个multiple -->
      <div class="form-group">
          <label for="exampleInputFile">生活照</label>
          <input type="file" name="photos" multiple>
      </div>
  </form>
  ```

- 后端controller处理请求获取文件

  ```java
  @PostMapping("/upload")
  public String upload(@RequestPart("headerImg") MultipartFile headerImg,
                      @RequestPart("photos") MultipartFile[] photos) {
      // 保存文件到服务器
      if (!headerImg.isEmpty()) {
          String originalFilename = headerImg.getOriginalFilename();
          headerImg.transferTo(new File("H:\\" + originalFilename));
      }
      if (phtots.length > 0) {
          for (MultipartFile phtot : phtots) {
              if (!photo.isEmpty()) {
                  // 同上
              }
          }
      }
  }
  ```

- 配置文件上传属性

  比如可上传的最大单个文件、上传的文件数量

  在application.properties中修改

  ```properties
  spring.servlet.multipart.max-file-size=10MB // 可上传的最大单个文件大小
  spring.servlet.multipart.max-request-size=100MB // 一次请求中能上传的总文件大小
  ```

## 4.7 异常处理

默认情况下，Springboot提供/error处理所有错误的映射，对于机器客户端（如POSTMAN）它将返回json格式错误信息，对于浏览器，会响应一个whitelabel错误视图

springboot同时也提供了自定义异常处理的方法

### 4.7.1 异常处理底层

springboot在ErrorMvcAutoConfiguration中自定配置了异常处理规则

在这个配置类中向容器里注册了一些组件

- DefaultErrorAttributes，它实现了HandlerExceptionResolver接口，这个接口用于异常处理，即决定发生异常之后跳转到哪里

- BasicErrorController

  处理默认/error路径的请求，会返回一个响应页面 `new ModelAndView("error", model)`

  并最终跳转到默认错误页或返回错误json数据

- DefaultErrorViewResolver

  以HTTP状态码作为视图错误页面地址，比如error/404.html，error/5xx.html，渲染错误页面

**springboot异常处理流程**

1. DispatcherServlet：处理所有请求的起点

   在doDispatcher中使用try-catch捕获处理请求过程中的所有异常。如果捕获到了异常，就将这些异常封装为dispatchException，并将此次请求标记为完成

   无论是否捕获到异常，都会进入视图解析流程 

   ```java
   processDispatchResult(precessedRequest, response, mappedHandler, mv, disptchException);
   ```

   在processDispatchResult方法中，如果有异常，就会调用processHandlerException方法处理异常，并返回一个ModelAndView

2. processHandlerException处理异常

   遍历所有handlerExceptionResolvers，看谁能处理当前异常。如果有人能处理异常就返回一个ModelAndView，如果不能处理异常就返回null。

   默认没有任何处理器能处理异常，所以异常会被抛出，到DispatcherServlet中

   如果此次请求结束之后异常也没有得到处理，那么tomcat会发送一个/error请求，而BasicErrorController专门处理/error请求

3. BasicErrorController

   BasicErrorController中会获取所有的错误信息

   之后解析错误视图，遍历所有的ErrorViewResolver，看谁能解析错误视图。默认是DefaultErrorViewResolver，它会拿到错误状态码，并去寻找`/error/错误状态码.html`页面作为错误页面返回

### 4.7.2 自定义异常处理

- 自定义错误页

在static静态资源文件夹或template模板引擎文件夹下，创建error文件夹。其中如果有以错误码命名的.html文件（比如404.html）就会在发生相应错误时精确匹配，如果没有就进行模糊匹配，比如在有以5xx.html时，就会在错误码以5开头时跳转到这个页面

- 自定义异常处理器ExceptionHandler处理全局异常

使用@ControllerAdvice和@ExceptionHandler注解

所有的异常处理器都要返回一个modelAndView对象

```java
@ControllerAdvice
public class MyExceptionHandler {
    @ExceptionHandler({ArithmeticException.class, NullPointerExceptionException}) // 里面填写能处理的异常类型
    public String handlerMathException(Exception e) {
        log.error("异常是{}",e);
        return "errorPage"; // 返回视图地址
    }
}
```

- 自定义异常

使用@ResponseStatus注解来自定义异常，在注解中使用value指定发生异常时的状态码，reason指定异常信息

```java
@ResponseStatus(value=HttpStatus.FORBIDDEN, reason="testError")
public class MyException extends RuntimeException {
    public MyException(String msg) { // 构造器
        super(msg);
    }
}
```

- Spring底层的异常

比如浏览器传来的参数不匹配等框架底层抛出的异常，此时会交友DefaultHandlerExceptionResolver处理

- 自定义异常解析器HandlerExceptionResolver

由于异常处理时会依次判断使用哪个异常解析器，我们可以使用@Order注解来指定自定义异常解析器的优先级（数字越小优先级越高）

如果把优先级调到最高，那么和自定义异常处理器ExceptionHandler差不多

```java
@Order(value = Ordered.HIGHEST_PRECEDENCE)
@Component
public class MyHandlerExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Object handler,
                                        Exception ex) {
        response.sendError(511, "自定义的错误"); // 手动发送/error请求
        // 如果能处理异常，就返回一个ModelAndView对象
        return new ModelAndView();
    }
}
```

## 4.8 spring原生组件注入



# 整合MyBatis

## 整合MyBatis

**配置文件+注解**

1. 引入starter依赖

   MyBatis是第三方包，所以依赖名为 mybatis-spring-boot-starter

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.2</version>
</dependency>
```

2. 创建mybatis mapper映射文件

   以及核心配置文件 mybatis-config.xml （这个配置文件中的配置都可以在springboot核心配置文件中直接写）

3. 在springboot核心配置文件中配置mybatis

   可以引入外部的mybatis核心配置文件，也可以直接写配置（建议），但是这两种配置方式不能共存

   ```yaml
   mybatis:
   	mapper-locations: classpath:mybatis/mapper/*.xml
   	config-location: classpath:mybatis/mybatis-config.xml # 配置文件和下面的直接指定配置不能同时存在
   	configuration: # 在这里进行mybatis的配置，可以代替mybatis配置文件
   		map-underscore-to-camel-case: true
   ```

4. 编写mapper接口

   注意mapper接口上要加上 @Mapper 注解

**纯注解开发**

可以直接省略mybatis mapper映射文件和mybatis-config.xml核心配置文件

1. 引入starter依赖

2. 在springboot核心配置文件中配置mybatis

3. 编写mapper接口

   直接在注解中写SQL语句，就可以省略mapper映射文件

   ```java
   @Mapper
   public interface UserMapper {
       
       @Select("select * from t_user where id=#{id}")
       public User getUserById(Long id);
   }
   ```

注解和mapper文件可以混合使用，对于比较复杂的SQL语句也可以直接写在mapper文件中

## 整合MyBatisPlus

