# 1. QuickStart

SpringBoot是一个高级框架，用于整合Spring技术栈

## 1.1 HelloWorld

1. 创建Maven程序

   需要在POM.xml配置文件中指定一个父项目，用于依赖管理

   ```xml
   <parent>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-parent</artifactId>
       <version>2.3.0.RELEASE</version>
   </parent>
   ```

2. 配置依赖

   SpringBoot提供了一系列starter依赖，只需要导入这一个依赖即可解决实现该功能所需所有依赖

   ```xml
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
   </dependencies>
   ```

3. 编写主程序类

   即整个SpringBoot程序的入口

   ```java
   package com.sazer.boot;
   
   @SpringBootApplication
   public class MainApplication {
       
       public static void main(String[] args){
           ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
       }
   }
   ```

   写法固定，返回值是一个IOC容器，可以通过这个IOC容器来获得其中的所有组件，比如

   `MyConfig bean = run.getBean(MyConfig.class);`

4. 编写控制器代码

   **注意：** controller包或者说Controller类一定要和主程序类在一个包下，否则Spring的组件扫描会扫描不到controller类，从而导致无法完成映射，报404错误

   ```java
   package com.sazer.boot.controller;
   
   // @Controller
   // @ResponseBody 表示该类中所有方法都带有@ResponseBody注释，该注释表示方法返回值直接返回给浏览器
   
   @RestController // 这个注解相当于上面两个注解相加
   public class HelloController {
   
       @RequestMapping("/hello")
       public String hello() {
           return "Hello SpringBoot2!";
       }
   
   }
   ```

5. 启动项目并测试

   无需配置Tomcat服务器，SpringBoot中已经整合完成

   只需要执行main方法即可

## 1.2 依赖管理

SpringBoot项目需要继承一个父项目spring-boot-starter-parent，该项目又继承于spring-boot-dependencies，这个项目的主要作用就是依赖管理，在其中导入了开发所需要的大多数依赖，并已经做好了版本控制。

我们只需要导入对应场景的starter依赖（命名为`spring-boot-starter-*`，*表示对应的开发场景），即可导入全部相关依赖，并自动做好版本控制。

如果需要对于某个依赖进行单独的版本指定，则需要到spring-boot-dependencies中找到对应的依赖，并找到指定其版本的属性名，之后在自己项目的pom.xml中重新指定这个属性即可

```xml
比如mysql的依赖
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>${mysql.version}</version>
    <exclusions>
        <exclusion>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
        </exclusion>
    </exclusions>
</dependency>

则我们可以在自己项目的配置文件中重新设置该属性
<properties>
	<mysql.version>5.1.43</mysql.version>
</properties>
```

## 1.3 自动配置

SpringBoot集成了很多组件，并自动实现了一些默认配置，比如：

- SpringMVC的常用组件

  比如DispatcherServlet、CharacterEncoding

- 开启组件扫描component-scan

  默认将主程序所在的包开启了组件扫描，也就是和主程序在同一个包下的类都能被扫描到

  也可以手动指定要扫描的包，在主程序类的@SpringBootApplication注解中使用scanBasePackages属性

  `@SpringBootApplication(scanBasePackages="com.sazer")`



除此之外，SpringBoot还将所有应用的配置都集成到了一个配置文件中 `application.properties`，通过修改这一个配置文件，就可以修改所有的配置

比如更改Tomcat服务器启动端口

```properties
server.port=8989
```

具体支持更改的配置可以参考 [官网文档](https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/appendix-application-properties.html#server-properties)

# 2. @SpringBootApplication详解

这个注解相当于以下三个注解

```java
@SpringBootConfiguration // 就相当于@Configuration注解
@EnableAutoConfiguration
@ComponentScan("com.sazer.boot") // 组件扫描注解，默认将主程序类所在的包开启组件扫描
```

下面主要讲解一下@EnableAutoConfiguration注解的底层原理

## 2.1 底层用到的注解

### 2.1.0 @Configutaion

给一个类加上@Configuration注解，这个类就是Spring的配置类，用于代替Spring的配置文件

```java
@Configuration
public class MyConfig {
}
```

### 2.1.1 proxyBeanMethods属性

@Configuration注解中有一个proxyBeanMethods属性，通过这个属性来设置是否保存代理对象

- true（默认）：Full模式，MyConfig对象中会保存代理对象
- false：Lite模式，不会保存代理对象

```java
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
MyConfig myConfig = run.getBean(MyConfig.class); // 获得myConfig对象
User user1 = myConfig.user01(); 
User user2 = myConfig.user01(); 
```

在Full模式中，user1和user2会返回同一个对象。这是因为每次调用方法SpringBoot都会进行检查，看IOC容器中是否有该对象。

在Lite模式中，user1和user2每次调用都会创建新的对象。也就是说SpringBoot不会检查，启动就比较快。

**应用场景**

组件依赖，当存在组件依赖时，要使用Full模式，也就是设置为true

不存在组件依赖时，可以设置为false减少判断和检查

### 2.1.2 @Bean 注册对象

（和直接在类上使用@Component、Controller、Service标签功能相同）

在配置类中，给方法加上@Bean标签来注册一个对象到IOC容器中

- 对象ID默认是方法名，也可以在@Bean注解中使用value属性指定
- 返回值即为注册的Bean对象
- 注册的bean对象依然是单实例

```java
@Configuration
public class MyConfig {
    @Bean("zhangsan")
    public User user01() {
        return new User("zhangsan", 18);
    }
}
```

**获取bean对象**

主程序入口的SpringApplication.run函数返回值是一个IOC容器，可以通过IOC容器来获取这个bean对象

```java
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
User zhangsan = run.getBean("zhangsan", User.class);
```

### 2.1.3 @Import 注册对象

使用@Import可以自动创建指定类的对象（无参构造器创建）并注册到IOC容器中

```java
@Import({User.class})
@Configuration
public class MyConfig {

}
```

### 2.1.4 @ConditionOn条件装配

@ConditionalOn*** 注解：当满足条件时才注册组件，否则不注册组件

其中***是具体类型的条件

可以加在类和方法上

- 加在类上：满足条件时类才生效
- 加在方法上：满足条件时注册方法的组件

在springboot底层大量使用了这个注解，因此当想要开启某个功能（组件）时，就需要在底层查看组件的开启条件

### 2.1.5 配置绑定

将properties配置文件中的属性注入到指定对象中，需要将属性信息写在SpringBoot的核心配置文件application.properties中

```properties
mycar.name=BYD
mycar.price=100000
```

**方法一**

在要注入的对象上使用@ConfigurationProperties组件，必须将该对象也注册到IOC容器中才行

```java
@Component
@ConfigurationProperties(prefix = "mycar") // 指定前缀
public class Car{
    String name;
    int price;
}
```

**方法二**

依然要指定前缀，不过这次在Config类上使用注解给指定类开启配置绑定功能

这个注解可以开启配置绑定功能并将指定类的对象注册到IOC中

```java
@EnableConfigurationProperties(Car.class)
public class MyConfig{
    
}
```

# 3. yaml配置文件

YAML：YAML（Yet Another Markup Language） Ain't Markup Language，薛定谔的标记语言

通常用于编写配置文件

## 3.1 基本语法

**语法规则**

使用`k: v` k冒号空格v表示一个键值对

使用缩进的空格表示层级关系，缩进的空格数不重要，相同层级元素左对齐即可

使用`#`注释

**数据表示案例**

- 字面量：即基本变量，单个不可再分的值

  直接写在v中即可，字符串无需在引号中。

  如果加引号，则双引号不会转义，单引号会转义。比如`a \n b`，双引号会输出换行，单引号会输出`\n`

- 对象：对象，或者map，可以表示为键值对的集合

  行内写法（json写法）

  ```yaml
  k: {k1:v1, k2:v2}
  ```

  yaml写法

  ```yaml
  k:
    k1: v1
    k2: v2
  ```

- 数组：比如array、list等按次序排列的值

  行内写法

  ```yaml
  k: [v1,v2,v3]
  ```

  yaml写法

  ```java
  k:
    - v1
    - v2
    - v3
  ```

# 4. web开发

在web开发场景中，用到的依然是spring和springMVC中的东西，springboot只是对经常用到的场景进行了自动配置，可以被看作是框架的框架

## 4.1 常用场景

### 4.1.1 静态资源访问

将静态资源放在项目根目录下的`/static` `/public` `/resources` `/META-INF/resources` 文件夹下，即可使用`ip:port/静态资源名`访问到静态资源

原理是springboot自动配置了一个Dispatcher，对/**请求进行静态映射，即全部请求。当浏览器发送请求时优先检验controller中配置好的动态请求，如果匹配不到就去寻找对应的静态资源。

**修改静态资源访问前缀**

默认前缀是/**，即直接使用`/静态资源名`访问，可以在yaml配置文件中进行配置修改

```yaml
spring:
  mvc:
    static-path-pattern: /resources/**
```

配置完成后访问静态资源就需要使用`ip:port/resources/静态资源名`  进行访问

注意：修改前缀会导致index页面和Favicon功能失效

### 4.1.2 index欢迎页

即访问项目根路径时，默认展示index页面

要实现上面的功能，springboot提供两种方式

- 在静态资源路径下放一个index.html
- 在controller中配置处理`/index`请求

### 4.1.3 网站图标Favicon

直接将网站图标`favicon.ico`（必须以这个名字命名）放在静态资源路径下

## 4.2 请求处理

用springboot如何处理浏览器发来的请求

### 4.2.1 REST映射

REST风格请求就是将 查/增/删/改 四种类型请求分别用GET/POST/DELETE/PUT请求表示

其中浏览器发送DELETE和PUT请求需要用到hiddenmethodfilter来进行转换，但是客户端（比如用POSTMAN模拟请求发送）可以直接发送请求PUT和DELETE请求，就无需开启hiddenmethodfilter

**在springboot中开启hiddenmethodfilter**

springboot底层配置了这个过滤器，但是增加了条件装配，需要手动在配置文件中配置才能开启

```yaml
mvc:
  hiddenmthod:
    filter:
      enabled: true
```

**页面表单发送REST请求**

在表单中加入一个隐藏域_method，在这个域的值中指定发送请求的类型

DELETE请求：

```html
<form action="/user" method="post">
    <input name="_method" type="hidden" value="DELETE" />
    <input value="REST-DELETE 提交" type="submit" />
</form>
```

PUT请求：

```html
<form action="/user" method="post">
    <input name="_method" type="hidden" value="PUT" />
    <input value="REST-DELETE 提交" type="submit" />
</form>
```

**Controller接收REST请求**

在RequestMaping注解中指定method属性

```java
@RequestMapping(value = "/user", method = RequestMethod.PUT)
public String putUser(){
    return "put-张三";
}
```

spring中也派生了方法对应的注解

```java
@PutMapping("/user")
public String putUser(){
    return "put-张三";
}
```

### 4.2.2 参数解析

解析并填充Controller中定义的参数，Controller中定义的参数可以用来获取浏览器发来的请求中的信息，如请求的参数，请求头等

参数解析的底层原理大致是，根据注解和参数类型找到对应的参数解析器HandlerMethodArgumentResolver，再调用对应参数解析器解析出参数

**获取浏览器传参**

- REST风格传参

  REST风格传参是指用`/`分隔将参数直接放在url中返回给服务器，比如`/car/1/owner/zhangsan`

  这种情况可以使用@PathVariable注解获取参数

  ```java
  // 根据参数名单独获取
  @RequestMapping("/car/{id}/owner/{username}")
  public String getCar(@PathVariable("id") Integer id,
                      @PathVariable("username") String name){
      
  }
  
  // 将所有参数封装到一个Map集合中
  @RequestMapping("/car/{id}/owner/{username}")
  public String getCar(@PathVariable Map<String, String> parameters){
      parameters.get("id") == 1;
      parameters.get("username") == "zhangsan";
  }
  ```

- queryStri方式传参

  是指在url后面使用`?key=value&key=value`的方式传参

  这种情况使用@RequestParam注解获取参数

  ```java
  // 请求url：localhost:8080/car?age=18&interests=basketball&interests=game
  // 根据参数名单独获取
  @RequestMapping("/car")
  public String getCar(@RequestParam("age") Integer age,
                      @RequestParam("interests" List<String> interests)){
  	// 由于interests对应多个值，因此使用list接收
  }
  
  // 获取所有参数
  @RequestMapping("/car")
  public String getCar(@RequestParam Map<String, String> params){
  }
  ```

- 获取POST请求的请求体

  使用@RequestBody注解

  ```java
  @PostMapping("/save")
  public Map postMethod(@RequestBody String content) {
      // content中以json字符串格式包含了请求体中所有信息
  }
  ```

- 获取矩阵变量

矩阵变量也是在url中传递参数的一种方式，不如queryString常见

开启矩阵变量：

springboot默认禁用，需要手动开启

```java
// WebConfig为自定义配置类
// springboot默认配置的路径解析器在WebMvcConfigurer中，因此要实现该接口并重写里面的方法
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    // 默认的路径解析器为urlPathHelper，它有一个属性叫removeSemicolonContent，即是否移除分号后面的内容，默认为true，改为false即可
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        UrlPathHelper urlPathHelper = new UrlPathHelper();
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    }
}
```

解析矩阵变量：

矩阵变量可以出现在任何路径片段中，每一个矩阵变量用分号隔开，一个矩阵变量的多个值用逗号隔开，比如：`localhost:8080/car/sell;low=34;brand=byd,benz`，其中`/car/sell`是路径，后面的是矩阵变量

```java
// /car/sell;low=34;brand=byd,benz
@RequestMapping("/car/{path}") // 矩阵变量绑定在路径中，因此要用url变量{path}代替/car/后面内容
public String carSell(@MatrixVariable("low") Integer low,
                     @MatrixVariable("brand") List<String> brands)
```

- 数据绑定：pojo封装参数

  将浏览器发来的参数（GET/POST请求都可以）直接封装到对应的Pojo对象中，要求参数名和属性名相同

  ```java
  @PostMapping("/saveuser")
  public User saveuser(User user) {
      
  }
  ```

  

**获取浏览器信息**

- 获取请求头

使用@RequestHeader获取请求头

```java
// 获取指定请求头
@RequestMapping("/car/{id}/owner/{username}")
public String getCar(@RequestHeader("User-Agent") String userAgent){
}

// 获取所有请求头
@RequestMapping("/car/{id}/owner/{username}")
public String getCar(@RequestHeader Map<String, String> header){
}
```

- 获取cookie值

使用@CookieValue获取cookie值

**获取Request域中数据**

一般是当别的请求转发过来时，获取保存在Request域中的数据

使用@RequestAttribute获取，也可以直接用HttpServletRequest对象接收

```java
// 比如在上一个Controller中往Request域中存了一些数据
HttpServletRequest request = new HttpServletRequest();
request.setAttribute("msg", "abc");

// 使用@RequestAttribute注解获取指定数据
@RequestMapping("transfer")
public String transferredPage(@RequestAttribute("msg") String msg) {
    
}

// 直接获取整个HttpServletRequest对象
@RequestMapping("transfer")
public String transferredPage(HttpServletRequest request) {
    
}
```

## 4.3 返回响应数据

服务器接收到浏览器发来的请求之后，经过一些处理返回给浏览器需要的数据，就是返回响应数据

在简单开发场景中，可以直接返回一个页面；在前后端分离业务中，大多只返回数据，比如返回json数据

### 4.3.1 返回json数据

springboot已经集成了返回json数据功能，底层使用jackson库进行json字符串转化

只需要在Controller方法上添加@ResponseBody注解（或在Controller类上使用@RestController注解），并在Controller方法中返回Pojo类型，即可自动转化为json返回给浏览器

```java
@RestController
public class ResponseTestController {
    @GetMapping("/test/person")
    public Person getperson() {
        return new Person();
    }
}
```

**底层原理**

springboot底层使用returnValueHandlers来处理对应类型的返回值。

对于标注了@ResponseBody的注解，会使用RequestResponseBodyMethodProcessor处理器处理

Processor处理器接下来会找到合适的MessageConverter进行处理，MessageConverter的作用就是把一种类型的数据转化为另一种类型，在当前场景就是把Controller返回值类型转化为媒体类型（和浏览器进行内容协商确定媒体类型）

Jackson2HttpMessageConverter能处理所有类型的返回值数据，只支持转化为json类型数据，符合要求，因此由它负责把Person转化为json

### 4.3.2 内容协商



# 整合MyBatis

## 整合MyBatis

**配置文件+注解**

1. 引入starter依赖

   MyBatis是第三方包，所以依赖名为 mybatis-spring-boot-starter

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.2</version>
</dependency>
```

2. 创建mybatis mapper映射文件

   以及核心配置文件 mybatis-config.xml （这个配置文件中的配置都可以在springboot核心配置文件中直接写）

3. 在springboot核心配置文件中配置mybatis

   可以引入外部的mybatis核心配置文件，也可以直接写配置（建议），但是这两种配置方式不能共存

   ```yaml
   mybatis:
   	mapper-locations: classpath:mybatis/mapper/*.xml
   	config-location: classpath:mybatis/mybatis-config.xml # 配置文件和下面的直接指定配置不能同时存在
   	configuration: # 在这里进行mybatis的配置，可以代替mybatis配置文件
   		map-underscore-to-camel-case: true
   ```

4. 编写mapper接口

   注意mapper接口上要加上 @Mapper 注解

**纯注解开发**

可以直接省略mybatis mapper映射文件和mybatis-config.xml核心配置文件

1. 引入starter依赖

2. 在springboot核心配置文件中配置mybatis

3. 编写mapper接口

   直接在注解中写SQL语句，就可以省略mapper映射文件

   ```java
   @Mapper
   public interface UserMapper {
       
       @Select("select * from t_user where id=#{id}")
       public User getUserById(Long id);
   }
   ```

注解和mapper文件可以混合使用，对于比较复杂的SQL语句也可以直接写在mapper文件中

## 整合MyBatisPlus

