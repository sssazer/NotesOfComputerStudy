# 1. 常见业务场景

## 1.1 二维码登录

通过已经登录的手机APP扫描web端二维码，实现扫码登录操作

原理就是，浏览器生成的二维码携带自己的客户端id，手机扫描二维码就可以得到这个id，然后向服务器发请求允许这个id对应的客户端登录。

### 1.1.1 客户端生成二维码

二维码可以理解为字符串的一种表现形式，即它可以存储信息，扫描二维码就可以得到这个信息

并且二维码的复杂度和存储的信息量有关

![image-20241206191144023](images/13.业务场景题/image-20241206191144023.png)

1. 浏览器向服务器端发起请求，请求生成用于用户登录的二维码

   这个请求中会携带浏览器对应的设备信息（用于表示想要登录的设备）

2. 服务端收到请求之后，生成二维码ID，并返回给客户端

   服务器端中会将二维码ID和浏览器设备信息进行绑定

3. 客户端根据收到二维码ID生成二维码并进行展示

4. 为了即时知道二维码状态（是否被扫描，是否确认登录），客户端会不断轮询服务器查询登录状态

   其实也可以使用WebSocket，这样的话响应会比较及时。但是从兼容性和复杂度考虑大部分方案还是会选择轮询

### 1.1.2 APP扫码登录

带登录确认功能

![image-20241206191212878](images/13.业务场景题/image-20241206191212878.png)

1. 手机APP扫描二维码，通过二维码内容获取到其中的二维码ID。然后将二维码ID和APP登录token发给服务器

2. 服务器接收到之后，将APP设备身份信息与二维码ID绑定，生成临时token，发给APP

   这一步是为了APP端的登录确认功能，如果无需登录确认，可以直接跳转到第四步，即直接生成浏览器端的登录token

   临时token是确保扫码和登录两步操作是同一部手机发出的

   此时二维码状态发生了改变，由于浏览器端一直在轮询，因此可以检测到这个变化，可以在界面上把二维码状态更新为已扫描

3. 手机端接收到临时token后弹出确认登录界面，用户点击确认后，APP携带临时token向服务器发送请求

4. 服务端收到确认之后，根据二维码ID绑定的浏览器信息和APP登录的账户信息，生成浏览器端登录的token

5. 此时浏览器端的轮询查询到二维码状态变为已确认，并且获取到用户登录的token

6. 登录成功，浏览器端可以拿获取的token进行登录认证

### 1.1.3 微信扫码登录

微信扫码登录和APP直接扫码登录的区别就是，此时二维码不能直接由服务器生成，而是得从微信那里获取

![image-20241209165303645](images/13.业务场景题/image-20241209165303645.png)

1. 用户发起微信登录请求
2. 服务器端接收请求之后，携带自己从微信那里获取的App I D和AppSecret，以及自己的回调域名参数，请求微信OAuth2.0授权登录
3. 第二步请求通过之后，微信会返回服务器一个二维码，这个二维码中包含了对服务器端的标识，服务器将这个二维码返回给前端用户展示
4. 用户扫码授权之后，会直接将请求发到微信，微信验证成功之后携带临时code回调服务器的相关接口
5. 服务器端获得这个code后，再带上自己的AppID和AppSecret，以及这个code调用微信接口，获取用户的基本信息

# 2. 限流器

限流器用于控制客户端发送流量的速率，即客户端在一定时间内被允许发送的请求数量，超出阈值的请求就会被拦截

限流器实现方案：

1. 在客户端实现

   但是由于客户端请求可以被伪造，因此不是一个可靠的强制限流实现位置

2. 在服务器端实现

3. 使用中间件实现

   在客户端和服务器端之间放一个限流中间件，比如在API网关中添加限流规则

## 2.1 限流算法

### 2.1.1 令牌桶算法

Amazon和Stripe使用此算法对API请求进行限流

![image-20241214140018974](images/13.业务场景题/image-20241214140018974.png)

令牌桶算法使用令牌桶进行速率限制。这个算法存在一个令牌桶主机，每次请求时，会从该主机中的令牌桶中获取令牌，如果获取成功则接收请求，如果没有令牌可获取则拒绝请求。同时会有重新注入装置不断向令牌桶中注入令牌。

在该算法中有两个需要确定的参数，即令牌桶的容量和自动补充令牌的速度。

桶的数量和配置和需要限流的业务场景有关，比如限制一个用户一秒只能发100个请求，那么每个用户都会对应一个桶，这个桶容量是100，每秒补充100；如果基于IP进行流量限制，则每个IP需要一个桶；再比如限制服务器每秒接收流量，则需要一个全局令牌桶。

令牌桶最大的特点是允许很短时间内出现突发流量，只要令牌桶中还有令牌可用。

### 2.1.2 漏桶算法

Shopify公司使用漏桶算法

![image-20241214143805679](images/13.业务场景题/image-20241214143805679.png)

漏桶算法通常使用队列实现

当一个请求到达时，会先检查桶是否已满，如果满了则丢弃请求，如果没满则将该请求加入桶队列中。同时服务器会定期从桶队列中取出请求并进行处理，为新请求腾出空间。

漏桶算法的桶配置和令牌桶类似，也是根据场景分配桶的数量。

漏桶算法最大的特点是按照固定速率处理请求，所以很适合要求出栈速度稳定的场景。

### 2.1.3 固定窗口计数器算法

很简单，就是如果每秒允许三个，就把当前秒超过三个的请求都丢了

将时间轴分成固定大小的时间窗口，并给每个时间窗口分配一个计数器，在该时间窗口内每到达一个请求就把计数器值+1，如果计数器值到达上限则新请求就会丢弃，直到开始一个新的时间窗口

![image-20241214151115053](images/13.业务场景题/image-20241214151115053.png)

比如每秒最多通过三个请求，则在每个1秒的时间窗口中，超过三个的请求就会被丢弃

这个算法的主要问题是，如果时间窗口边界出现流量爆发，则实际请求数会超过阈值



![image-20241214152653986](images/13.业务场景题/image-20241214152653986.png)

比如每分钟允许5个请求，每分钟零秒时刷新计数器，那么如果上一分钟请求集中在后30s，下一分钟请求集中在前30s，则会存在在60s的时间有10个请求。

即如果我们将每分钟最大消息数设为10，我们就不希望在59秒时收到10条消息，又在1秒时收到10条消息

### 2.1.4 滑动窗口日志算法



### 2.1.5 滑动窗口计数器算法





