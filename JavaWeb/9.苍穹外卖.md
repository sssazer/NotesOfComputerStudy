# 1. 前置知识

## 1.1 Nginx反向代理

Nginx用于反向代理

即客户端浏览器发来的请求先发给Nginx服务器，再由Nginx服务器转发给后端Tomcat服务器

优点：

- 提高访问速度，因为Nginx可以进行缓存
- 进行负载均衡
- 保证后端服务安全

Nginx的配置文件为nginx.conf文件，在Nginx安装目录下

**Linux安装Nginx**

`sudo apt install nginx`

Nginx默认端口为80，安装完成之后访问`localhost:80`即会出现Nginx默认欢迎页面

### 1.1.1 反向代理配置

```nginx
server{
    listen 80;
    server_name localhost;
    
    location /api/{
        proxy_pass http://locaohost:8080/admin/;  # 配置反向代理转发规则
    }
}
```

这个配置表示，当客户端发来的请求满足 /api/ 时，就映射为 /admin/ 再转发给服务器

比如 `localhot/api/employee/login` 转发到Tomcat服务器的地址就为 `localhost:8080/admin/employee/login`

### 1.1.2 负载均衡配置

```nginx
upstream webservers{
    server 192.168.100.128:8080;
    server 192.168.100.128:8080;
}

server{
    listen 80;
    server_name localhost;
    
    location /api/{
        proxy_pass https://webservers/admin/;  # 配置负载均衡
    }
}
```

当匹配到 /api/ 地址时，就会根据策略转发到配置的两台后端服务器上

## 1.2 对用户密码进行md5加密

用户密码在数据库中不应该明文保存，而应该进行加密保存。在用户登录时，应该将用户密码进行加密之后再和数据库中存储的密文密码进行比较验证

用spring提供的工具类来进行md5加密

```java
password = DigestUtils.md5DigestAsHex(password.getBytes());
```

## 1.3 Yapi接口管理

设计阶段使用的工具，用于帮助前后端开发人员管理和维护接口

在前后端分离的开发模式中，需要确定前后端之间的接口（比如前端需要发送给后端什么数据，后端返回前端什么数据），前后端开发人员才能一起并行开发

接口的定义可以使用YApi等接口管理平台进行管理

打开yapi.pro，新建项目，之后在数据管理中将接口文件拖入即可

## 1.4 Swagger

开发阶段使用的工具，帮助后端开发人员做后端的接口测试

用于生成接口文档，以及生成在线接口调试页面帮助后端调试，这个调试页面可以模拟发送请求给相应的接口，并显示服务器返回的数据

Knife4j是对Swagger的进一步封装，为MVC框架集成Swagger

### 1.4.1 使用

1. 导入knife4j依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/com.github.xiaoymin/knife4j-spring-boot-starter -->
   <dependency>
       <groupId>com.github.xiaoymin</groupId>
       <artifactId>knife4j-spring-boot-starter</artifactId>
       <version>3.0.3</version>
   </dependency>
   ```

2. 在配置类（自建的加了@Configuration注解的类）中加入knife4j相关配置

   主要是要设置扫描的包，比如本次设置为controller包，之后就会扫描这个包（及子包）下的所有类并利用反射生成接口文档和调试工具

   ```java
   /**
        * 通过knife4j生成接口文档
        * @return
        */
   @Bean
   public Docket docket() {
       ApiInfo apiInfo = new ApiInfoBuilder()
           .title("苍穹外卖项目接口文档")
           .version("2.0")
           .description("苍穹外卖项目接口文档")
           .build();
       Docket docket = new Docket(DocumentationType.SWAGGER_2)
           .apiInfo(apiInfo)
           .select()
           .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
           .paths(PathSelectors.any())
           .build();
       return docket;
   }
   ```

3. 设置静态资源映射（用于访问接口文档页面）

   写在配置类中

   这里的映射地址都是固定的，Swagger会自动将接口文档生成在默认路径下

   ```java
   /**
        * 设置静态资源映射
        * @param registry
        */
   protected void addResourceHandlers(ResourceHandlerRegistry registry) {
       registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
       registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
   }
   ```

4. 启动服务器，输入`localhost:8080/doc.html`访问接口文档页面

   在左侧菜单栏中就可以看到根据controller类中的方法生成的接口文档

### 1.4.2 常用注解

使用常用注解可以控制生成的接口文档，使接口文档拥有更好的可读性

注解在Controller类中使用，控制该类对应的接口文档

- @Api

  对这个类的描述

  ```java
  @Api(tags = "员工相关接口")
  public class Employee Controller{
      
  }
  ```

- @ApiOperation

  对类中某个方法的描述

  ```java
  @Api(tags = "员工相关接口")
  public class Employee Controller{
      @PostMapping("/logout")
      @ApiOperation(value = "员工退出登录")
      public Result<String> logout {return Result.success();}
  }
  ```

- @ApiModel

  对DTO数据类（pojo类）的描述

- @ApiModelProperty

  对数据类中属性的描述

  ```java
  @Data
  @ApiModel(description = "员工登录时传递的数据模型")
  public class EmployeeLoginDTO implements Serializable {
  
      @ApiModelProperty("用户名")
      private String username;
  
      @ApiModelProperty("密码")
      private String password;
  
  }
  ```

## 1.5 Lombok

用于简化Pojo类的开发

首先导入Lombok依赖，之后在实体类上添加@Data注解，即可自动生成构造器、getter/setter等方法

```java
@Data
class Person{
    String name;
    int ag
}
```



# 2. 项目结构

项目名为sky-take-out（项目父工程），进入之后有三个子文件夹（三个子模块）

- sky-common：存放公共类，如工具类、常量类、异常类
- sky-pojo：存放实体类
- sky-server：存在后端服务，存放配置文件、Controller、Service、Mapper等

## 2.1 sky-pojo

pojo子模块中主要存放项目中对应的实体对象

各种实体对象都属于pojo，即有属性和对应getter/setter方法的普通java对象，但是根据用途不同，又进行了细分

![](./9/pojoModel.png)

**DTO**

数据传输对象DTO（Data Transfer Object），是用于各层之间来传递数据的

是面向前端的数据传输对象，比如前端在传回登录、注册数据和后端向前端回传要展示的数据时，可能并不会包括实体类中的所有属性。

此时就可以传输一个DTO对象，这个DTO对象只包含前端需要的所有属性，这样就不用每次都传输整个Entity对象。

优点：

- 避免暴露后端数据库表结构
- 前后端解耦：DTO类对接前端显示界面，Entity实体类对接数据库表

**VO**

视图对象（View Object），显示层对象，用于前端视图中的数据展示，比如需要展示一个表单、表格时，后端就可以将数据封装为一个VO对象来给前端进行展示

一般是Controller层向view层传递

**Entity**

实体对象，通常与数据库中的表对应

## 2.2 sky-service

存放controller、service、mapper等业务处理部分

一个业务的处理流程大致如下

![](./9/springbootFlowChat.png)

# 2. 开发过程

## 2.1 员工操作

### 2.1.1 新增员工

**开发过程**

1. controller

   在controller中添加新增员工的接口 save，参数为EmployeeDTO

   在其中调用service层的save方法

   ```java
   @PostMapping
   @ApiOperation("添加用户")
   public Result save(@RequestBody EmployeeDTO employeeDTO) {
       employeeService.save(employeeDTO);
       return Result.success();
   }
   ```

2. service

   service层将DTO对象转化为Entity对象（相同属性直接复制，不同的属性单独赋值），之后调用mapper层存入数据库

   可以使用`BeanUtils.copyProperties()`函数来进行属性复制，前提是两个类之间属性名要相同

   ```java
   @Override
   public void save(EmployeeDTO employeeDTO) {
       Employee employee = new Employee();
       BeanUtils.copyProperties(employeeDTO, employee);
   	// 设置employee的其他属性
   
       employeeMapper.insert(employee);
   }
   ```

3. mapper

   mapper接口将传来的employee对象存入数据库

### 2.1.2 JWT认证

**JWT认证**

JWT（Json Web Token）是一种服务器向客户端发送令牌的认证方式

当客户端进行登录操作，服务器认证登录成功之后，会生成一个json对象返回给客户端。之后客户端再与服务器端进行通信时，发送请求都会带着这个JSON对象，服务器则完全靠这个对象认定用户身份，为了防止用户篡改数据，服务器在生成对象时会加上签名。

发送的JSON对象就类似于下面，实际上是一串字符Token

```json
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
```

这样的话服务器就可以不保存session数据了，比较容易实现扩展。

认证流程如下图

![JWT流程](.\9\JWT流程.png)

**登录成功时生成JWT令牌**

在负责处理登录请求的Controller方法中生成jwt令牌并返回给前端

```java
@PostMapping("/login")
@ApiOperation("员工登录")
public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
	// 调用service中的登录方法执行登录操作
    Employee employee = employeeService.login(employeeLoginDTO);

    //登录成功后，生成jwt令牌
    // claims中放自己想要保存的信息
    Map<String, Object> claims = new HashMap<>();
    claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
    String token = JwtUtil.createJWT(
        jwtProperties.getAdminSecretKey(),
        jwtProperties.getAdminTtl(),
        claims);
	
    // 将生成的jwt令牌放入VO对象中返回给前端浏览器
    EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
        .id(employee.getId())
        .userName(employee.getUsername())
        .name(employee.getName())
        .token(token)
        .build();

    return Result.success(employeeLoginVO);
}
```

**收到请求时验证jwt令牌**

在Interceptor中拦截所有请求并进行令牌验证

prehandle方法：

```java
//1、从浏览器请求头中获取令牌
String token = request.getHeader(jwtProperties.getAdminTokenName());

//2、校验令牌
try {
    // 校验令牌
    Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
    // 得到令牌中保存的信息
    Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
    log.info("当前员工id：", empId);
    // 将当前登录用户的id保存在LocalThread中
    BaseContext.setCurrentId(empId);
    //3、通过，放行
    return true;
} catch (Exception ex) {
    //4、不通过，响应401状态码
    response.setStatus(401);
    return false;
}
```

### 2.1.3 ThreadLocal

ThreadLocal并不是一个Thread线程，而是Thread中的局部变量

ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果。可以在里面保存数据（只能保存一个变量），只有在线程内才能获取到对应的数据。

ThreadLocal常用方法：

- public void set(T value)

  设置当前ThreadLocal变量中保存的变量

- public T get() 

  获取当前ThreadLocal变量中存储的变量

- public void remove()

  移除当前ThreadLocal变量中存储的变量

对于浏览器客户端发送的每次请求，Tomcat都会为这个请求分配一个单独的线程。

因此ThreadLocal可以用于在一次请求中共享数据，在具体使用时会对其进一步封装。

```java
// 该工具类用于保存当前登录用户的用户ID
public class IdContext {
    public static ThreadLocal<Long> threadlocal = new ThreadLocal<>();
    // 保存id
    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }
    // 获取id
    public static Long getCurrentId() {
        return threadLocal.get();
    }
    // y
    public static void removeCurrentId() {
        threadlocal.remove();
    }
}
```

### 2.1.4 格式化日期

后端的Pojo对象中以LocalDataTime格式存储的日期对象，在以json格式返回给前端时，会变成数组形式，进而前端会显示为数组直接拼接的结果

所以我们需要在后端对日期类型进行格式化

有两种方法

1. 在日期类型变量上加入@JsonFormat注解指定格式（只能作用于单个对象）

   ```java
   @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
   private LocalDateTime updateTime;
   ```

2. 在WebMvcConfiguration配置类中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理（全局配置，推荐）

在配置类中注册消息转换器：

```java
@Override
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
    // 创建一个消息转换器对象
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
    // 为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
    converter.setObjectMapper(new JacksonObjectMapper());
    // 将创建好的消息转换器对象加入容器中
    converters.add(0, converter);
}
```

其中JacksonObjectMapper对象指定了LocalDataTime对象的格式化规则，使用时直接复制下面代码即可

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

### 2.1.5 公共字段自动填充

在数据库中有一些公共字段，即每张表都有，比如创建时间、创建人id、修改时间、修改人id。如果在每个方法中都手动填入这些字段，就会造成代码冗余。

可以通过切片来拦截需要修改这些字段的方法，并对这些方法进行自动填充。

**实现思路**

1. 自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法（即需要执行insert和update的方法）
2. 在Mapper中涉及insert和update的方法加上AutoFill注解
3. 自定义切面类AutoFillAspect，统一拦截加入了AutoFill注解的方法，并为公共字段赋值

