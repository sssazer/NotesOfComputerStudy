# 4. xml

xml是可扩展的标记性语言

xml可用于：

- 保存数据，并且这些数据具有自我描述性

  ```xml
  <!-- 
  比如保存两个Student类型的对象
  Student[id=1, name="张三"]
  Student[id=2, name="李四"]
  -->
  
  <students>
      <student>
          <id>1</id>
          <name>张三</name>
      </student>
      <student>
          <id>2</id>
          <name>李四</name>
      </student>
  </students>
  ```

- 作为项目的配置文件

- 作为网络传输数据的格式（现在以json格式为主）

## 4.1 xml文件格式

### 4.1.1 文档声明

```xml
<?xml version="1.0" encoding="UTF-8"?>
```

- version——使用的xml的版本
- encoding——编码方式

### 4.1.2 注释

和html注释一样

```xml
<!-- 注释 -->
```

### 4.1.3 元素（标签）

xml的元素，指 开始标签到结束标签的部分（包含开始和结束标签），格式和html中的标签很类似

元素中可包含子元素、文本，元素可以拥有属性

xml文档必须有且只有一个根元素 （根元素就是顶级元素，即没有父标签的元素）

```xml
<?xml version="1.0" encoding="UTF-8"?>

<books> <!-- 根元素，有且只有一个 -->
    <book sn="SN123124234"> <!-- 元素中可以有属性 -->
        <name>时间简史</name>
        <author>霍金</author>
        <price>75</price>
    </book>
        <book sn="SN123124233">
        <name>时间简史</name>
        <author>霍金</author>
        <price>75</price>
    </book>
    <!-- xml中可以有单行元素 -->
	<book sn="SN1232342" name="Linux" author="Linus" price="123" />
</books>
```

### 4.1.4 文本区域（CDATA区）

xml中有很多特殊符号，当内容中有很多特殊符号时转义起来比较麻烦

此时可以将文本内容放在CDATA区中，告诉xml编译器这是纯文本内容不用解析

格式为`<![CDATA[要放置的文本]]>`

```xml
<books>
    <![CDATA[
		<<<<<<<这里的内容不用解析>>>>>>>>>>>>
	]]>
</books>
```

## 4.2 xml文件解析

xml和html一样是标记型文档，可以使用w3c组织制定的dom技术来解析，即将每个元素（标签）都解析为一个dom对象

**解析技术：**

- dom：w3c组织制定

- SAX：（Simple API for XML）是sun公司在jdk5对dom解析技术的升级
- jdom：在dom基础上进行封装
- dom4j：对jdom进行封装
- pull：用于Android手机开发

### 4.2.1 dom4j解析

[下载](https://dom4j.github.io/)dom4j的jar包  dom4j-version.jar

以解析下面xml文件为例

```xml
<?xml version="1.0" encoding="UTF-8"?>

<books> <!-- 根元素，有且只有一个 -->
    <book sn="SN123124234"> <!-- 元素中可以有属性 -->
        <name>时间简史</name>
        <author>霍金</author>
        <price>75</price>
    </book>
        <book sn="SN123124233">
        <name>时间简史</name>
        <author>霍金</author>
        <price>75</price>
    </book>
    <!-- xml中可以有单行元素 -->
	<book sn="SN1232342" name="Linux" author="Linus" price="123" />
</books>
```

**使用流程：**

1. 将jar包放入项目路径中并add as Library导入项目

2. 创建相应的book类

   ```java
   public book {
       String SN;
       String name;
       String author;
       double price;
       // 提供空参构造器和全参构造器
       // 提供get/set方法
       // 提供toString方法
   }
   ```

3. 创建saxReader对象

   ```java
   SAXReader saxReader = new SAXReader();
   ```

4. 读取xml配置文件生成Document对象

   ```java
   Document document = saxReader.read("./books.xml");
   ```

5. 通过Document对象获取根元素

   即获取\<books>标签

   ```java
   Element rootElement = document.getRootElement();
   ```

6. 通过根元素获取子元素

   ```java
   // 有多个子元素时使用elements
   List<Element> books = rootElement.elements("book"); // 这里是元素标签名
   
   // 只有一个子元素时使用element
   Element book = rootElement.element("book");
   
   // asXML可以将标签地xml源代码原封不动地转化为字符串
   String xmlBook = book.asXML();
   ```

7. 遍历子元素，转化为相应类的对象

   ```java
   for (Element book : bookd) {
       // 先获取子元素，再获取元素中的文本内容
       Element nameElement = book.element("name"); // 获取子元素 - name标签对象
       String bookName = nameElement.getText(); // 获取标签对象中的文本内容
       
       // 也可以直接获取子元素中的文本内容
       String priceText = book.elementText("price");
       String authorText = book.elementText("author");
       
       // 获取标签中的属性
       String sn = book.attributeValue("sn");
       // 根据这些值创建bookd
       Book book = new Book(bookName, priceText, authorText, sn);
   }
   ```


# 5. Tomcat服务器

Tomcat是Apace提供的免费web服务器

## 5.0 JavaEE 三层架构

分层的目的是为了解耦，降低代码的耦合度，方便项目后期的维护和升级

![](./1/5.0JavaEE三层架构.png)

根据这个分层结构，需要在工程中创建以下包

- web层

  com.sazer.web/servlet/controller —— Servlet程序

- service层

  com.sazer.service —— service接口包

  com.sazer.service.impl —— service接口实现包

- dao持久层（和数据库交互）

  com.sazer.dao —— Dao接口包

  com.sazer.dao.impl —— Dao接口实现包

- 实体bean对象 —— 在web层Servlet程序中将客户端数据封装为bean对象

  com.atguigu.pojo/entity/domain/bean

- 测试包

  com.sazer.test/junit

- 工具类

  com.sazer.utils

## 5.1 安装和启动

**安装**

在[官网下载](https://tomcat.apache.org/whichversion.html)需要版本的压缩包，直接解压到想要安装的目录即完成安装

目录介绍

- bin：存放Tomcat服务器的可执行程序
- conf：存放配置文件
- lib：存放jar包，Tomcat提供给java的jar包
- logs：Tomcat服务器运行时输出的日志
- temp：用于存放Tomcat运行时产生的临时数据
- webapps：存放部署的web工程
- works：Tomcat工作目录，用来存放Tomcat运行时jsp翻译为Servlet的源码，和Session钝化的目录

**启动**

- 找到Tomcat目录下的bin目录下的startup.bat文件，双击即可启动（如果出现命令行窗口一闪而过，是因为没有配置JAVA_HOME环境变量）
- 命令行启动：打开命令行定位到Tomcat bin目录下， 输入 `catalina run`即可启动 （这种方式如果启动失败会显示错误信息）

启动之后打开浏览器输入`localhost:8080`，显示Tomcat的欢迎页面即为启动成功

**关闭**

- 直接关闭启动Tomcat的命令行窗口
- 双击bin目录下的shutdown.bat

**修改Tomcat默认端口号**

Tomcat默认的端口号是8080

打开tomcat目录/conf/server.xml，找到Connector标签，修改里面的port属性即可

修改完端口号后重启Tomcat服务器

## 5.2 部署web工程

浏览器访问时，如果只输入`https://ip:port/`默认访问`webapps/ROOT`文件夹

当访问一个项目时，如果没有指定资源名，默认访问项目路径中的`index.html`

### 5.2.1 直接拷贝项目工程目录

之前提到tomcat目录下的webapps文件夹用于存放部署的web工程，因此可以直接把工程目录拷贝到webapps文件夹里实现部署

访问时输入`localhost:8080`后会进入webapps目录，在地址中继续输入目录路径即可访问到指定页面，比如`localhost:8080/docs/aio.html`

### 5.2.2 通过配置文件

在Tomcat目录下`./conf/Catalina/localhost`创建配置文件，名字可以任意取

```xml
<Content path="/123" docBase="E:\book">
```

### 5.2.3 IDEA部署

**配置服务器**

File - Settings - Build,Execution,Deployment - Application Servers - 添加（加号） - Tomcat Server - 选择Toncat Home（只用选择到Tomcat根目录即可，不用选择bin目录）

**创建Web项目**

新版Idea没有Java EE选项需要修改注册表：打开idea，按下alt+ctrl+shift+/ 组合键，选择Register注册表 - 找出javaee-legacy.project.wizard 并选中

创建一个项目，右键项目名 - New module - Java EE（Legacy） - 选择Application Server，在Additional Libearies and Frameworks中勾选 Web Application ，并在下方选中Create web.xml - next - 设置Project name

**项目目录说明**

- src：src目录存放编写的Java源代码

- web：存放web工程的资源文件

  比如：html页面，css文件，js文件等

  WEB-INF：受服务器保护的目录，浏览器无法直接访问到此目录的内容

  - lib目录：默认没有，建议创建一个，用于存放第三方jar包
  - web.xml：整个web工程的配置部署描述文件，可以在这里配置很多web工程的组件

**启动配置说明**

在右上角启动按钮的旁边打开Edit Configuration

- Server

  URL表示通过IDEA启动浏览器之后自动输入的网址（一般是本工程的网址）

  On 'Update' action ：热部署，即工程文件发生变化之后执行什么操作

  - Update resources
  - Update classes and resources
  - Redeploy
  - Restart server：重启Tomcat服务器

- Deployment

  可以在这里添加多个server，即启动Tomcat服务器之后部署多个工程

  Application context：修改工程的地址，即输入`ip:port`之后再输入`/address`能访问到此工程

# 6. Servlet

Servlet是JavaEE规范（即接口）之一，运行在服务器上，可以接收客户端发送过来的请求，并响应给客户端

## 6.1 实现servlet程序

### 6.1.1 实现Servlet接口

**实现过程**

1. 创建一个类实现Servlet接口

   创建`HelloServlet.java`文件

2. 实现service方法

   service方法专门用于处理请求和相应

   ```java
   public class HelloServlet implements Servlet {
       @Override
       public void service(ServletRequest servletRequest, 
                          ServletResponse servletResponse) 
           throws servletException, IOException {
           sout("Hello Servlet被访问了");
       }
   }
   ```

3. 配置xml文件

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <web-app>
       <!-- 给Tomcat配置Servlet程序 -->
       <servlet>
           <!-- 给Servlet程序起一个别名，一般是类名 -->
           <servlet-name>HelloServlet</servlet-name>
           <!-- Servlet程序的全类名 -->
           <servlet-class>com.sazer.servlet.HelloServlet</servlet-class>
       </servlet>
       
       <!-- 给servlet程序配置访问地址 -->
       <servlet-mapping>
           <!-- 给哪个servlet程序配置地址 -->
           <servlet-name>HelloServer</servlet-name>
           <!-- 对应的地址 -->
           <!--
   			/ 表示工程路径，即 ip:port/工程路径
   			hello 表示servlet程序的地址
   			通过 ip:port/工程路径/hello 即可访问到HelloServlet程序的service方法
   		-->
           <url-pattern>/hello</url-pattern>
       </servlet-mapping>
   </web-app>
   ```


**客户端访问时执行顺序**

当客户端访问servlet时

1. 访问构造器HelloServlet
2. 执行init函数

以上两步只在第一次访问时才会执行

3. 执行service函数

   这一步每次访问都会执行

4. web工程停止时，执行destroy销毁

```java
public class HelloServlet implements Servlet {

    public HelloServlet() {
        
    }

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}
```

**处理get/post请求**

ServletRequest中提供了getMethod方法可以用来获取此次请求类型，但是ServletRequest是一个接口，因此要类型转化为实现类来使用

```java
@Override
public void service(ServletRequest servletRequest, 
                    ServletResponse servletResponse) 
    throws ServletException, IOException {
    
    HttpServletRequest hsr = (HttpServletRequest) servletRequest;
    String method = hsr.getMethod();
    if ("GET".equals(method)) {
        System.out.println("收到get请求");
    } else if ("POST".equals(method)) {
        System.out.println("收到post请求");
    }
    
}
```

### 6.1.2 继承HttpServlet类

在实际开发中一般使用这种方法 

1. 编写一个类继承HttpServlet类

2. 根据业务需要重写doGet或doPost方法

   ```java
   public class HelloServlet extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, 
                           HttpServletResponse resp)
           throws ServletException, IOException{
           
           sout("收到get请求时调用");
       }
       
       @Override
       protected void doPost(HttpServletRequest req, 
                           HttpServletResponse resp)
           throws ServletException, IOException{
           
           sout("收到post请求时调用");
       }
   }
   ```

3. 到web.xml中配置Servlet程序访问地址

### 6.1.3 用idea创建Servlet程序

自动创建的Servlet程序也是采用继承HttpServlet类的形式

右键src - new - Servlet，在弹出的New Servlet窗口中

- Name：要创建的Servlet程序的类名
- Package：要创建到哪个包下
- Class：创建Servlet程序的全类名

- Create Java EE 6+ annotated class
  - 勾选的话会用注解的方式配置
  - 不勾选的话用web.xml文件配置，推荐这个方式

点击OK，然后会在web.xml文件中自动配置\<servlet>，再手动配置\<servlet-mapping>即可

### 6.1.4 web.xml配置文件

每个web工程对应一个web.xml配置文件，在配置文件中可以配置

- 各个servlet程序的访问地址，各个servlet程序中的init-param

- 整个web工程的context参数 context-param

  每个context-param标签中只能有一组param参数

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app>
    <!-- 整个web工程的context参数 -->
    <context-param>
        <param-name>user</param-name>
        <param-value>root</param-value>
    </context-param>
    
    <context-param>
        <param-name>password</param-name>
        <param-value>123456</param-value>
    </context-param>
    
    <!-- 给Tomcat配置Servlet程序 -->
    <servlet>
        <!-- 给Servlet程序起一个别名，一般是类名 -->
        <servlet-name>HelloServlet</servlet-name>
        <!-- Servlet程序的全类名 -->
        <servlet-class>com.sazer.servlet.HelloServlet</servlet-class>
        
        <!-- 初始化参数，可以有多组 -->
   		<init-param>
            <!-- 参数名 -->
            <param-name>username</param-name>
            <!-- 参数值 -->
            <param-value>root</param-value>       
            <param-name>url</param-name>
            <param-value>jdbc:mysql://localhost/test</param-value>
    	</init-param>
    </servlet>    
    
    <!-- 给servlet程序配置访问地址 -->
    <servlet-mapping>
        <!-- 给哪个servlet程序配置地址 -->
        <servlet-name>HelloServer</servlet-name>
        <!-- 对应的地址 -->
        <!--
			/ 表示工程路径，即 ip:port/工程路径
			hello 表示servlet程序的地址
			通过 ip:port/工程路径/hello 即可访问到HelloServlet程序的service方法
		-->
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
</web-app>
```

## 6.2 Servlet继承体系

查看Servlet源码需要在[官网](https://tomcat.apache.org/download-80.cgi)下载Tomcat source code distributions，下载下来为`apache-tomcat-version-src-zip`

实现servlet程序，选中 Servlet 按下ctrl+B，

![](D:\CS_Source\myNote-of-ComputerStudy\JavaWeb\1\6.2servlet继承体系.png)

1. Servlet接口

   负责定义Servlet程序的访问规范

2. GenericServlet类 --> 实现了Servlet接口

   对接口做了很多空实现

   并持有一个ServletConfig类的引用，并对ServletConfig的使用做一些方法

3. HttpServlet类 --> 继承于GenericServlet类

   主要是实现了service方法，实现各种请求的分发处理

   ```java
   protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
   	// 获取请求类型
       String method = req.getMethod();
   	
       // 根据请求类型分发请求
       if (method.equals(METHOD_GET)) {
           ...
   		doGet(req, resp);
           ...
       } else if (method.equals(METHOD_HEAD)) {
           long lastModified = getLastModified(req);
           maybeSetLastModified(resp, lastModified);
           doHead(req, resp);
   
       } else if (method.equals(METHOD_POST)) {
           doPost(req, resp);
   
       } else if (method.equals(METHOD_PUT)) {
           doPut(req, resp);
   
       } else if (method.equals(METHOD_DELETE)) {
           doDelete(req, resp);
   
       } else if (method.equals(METHOD_OPTIONS)) {
           doOptions(req, resp);
   
       } else if (method.equals(METHOD_TRACE)) {
           doTrace(req, resp);
   
       } else {
   		// 抛出异常
           String errMsg = lStrings.getString("http.method_not_implemented");
           Object[] errArgs = new Object[1];
           errArgs[0] = method;
           errMsg = MessageFormat.format(errMsg, errArgs);
   
           resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
       }
   }
   ```

   在HttpServlet类中的doGet和doPost等方法的实现都只有抛出异常——不支持该类型请求。即如果自定义的类不重写类型请求的处理方法，接收到对应类型的请求时就提示不支持该类型。

4. 自定义Serlvet程序

   根据自己的业务重写各种请求的处理方法

## 6.3 Servlet中一些实用类

### 6.3.1 ServletConfig

Servlet程序的配置信息类，即用于获取web.xml中的配置信息

**获取ServletConfig对象**

每个Servlet程序都有一个Servlet Config对象，由Tomcat负责创建这个对象

- 可以通过init函数获取，在init函数的参数中会传入一个ServletConfig对象

  重写init方法之后，一定要调用父类init方法，并将servletConfig对象传进去。父类GenericServlet中的init方法负责 给GenericServlet中的属性servletConfig赋值，以供getServletConfig函数获取servletConfig对象

```java
class HelloServlet extends HttpServlet {
    
    @Override
    public void init(ServletConfig servletConfig) 
        throws ServletException {
        super(servletConfig);
    }
}
```

- 在其他地方可以通过getServletConfig获取

  这里实际上是从父类GenericServlet中获取，父类中有一个成员属性保存了ServletConfig对象

```java
@Override
protected void doGet(...) {
    ServletConfig servletConfig = getServletConfig();
}
```

**ServletConfig对象的作用**

1. 获取Servlet程序的别名，即web.xml文件中配置的 servlet-name的值

   ```java
   String name = servletConfig.getServletName();
   ```

2. 获取初始化参数 init-param

   要获取首先要在web.xml文件的对应Servlet程序的Servlet标签中添加

   ```xml
   <servlet>
       <servlet-name>HelloServlet</servlet-name> <!-- Servlet程序别名 -->
       <servlet-class>com.sazer.servlet.HelloServlet</servlet-class>
       
       <!-- 初始化参数，可以有多组 -->
       <init-param>
           <!-- 参数名 -->
           <param-name>username</param-name>
           <!-- 参数值 -->
           <param-value>root</param-value>
           
           <param-name>url</param-name>
           <param-value>jdbc:mysql://localhost/test</param-value>
       </init-param>
   </servlet>
   ```

   ```java
   // 获取初始化参数 username的值
   String username = servletConfig.getInitParameter("username");
   // 获取初始化参数 url
   String url = servletConfig.getInitParameter("url");
   ```

3. 获取ServletContext对象

   ```java
   servletConfig.getServletContext();
   ```

### 6.3.2 ServletContext

**概念**

ServletContext是一个接口，表示Servlet上下文对象

一个web工程中只有一个ServletContext对象实例

ServletContext是一个域对象，即可以存取数据

**获取ServletContext对象**

- 使用servletConfig对象调用getServletContext();

  ```java
  ServletContext context = getServletConfig().getServletContext();
  ```

- 直接调用getServletContext()；函数

  ```java
  ServletContext context = getServletContext();
  ```

  这是因为在父类GenericServlet中重写了getServletContext方法，实际上和上面的方法一样

  ```java
  @Override
  public ServletContext getServletContext() {
      return getServletConfig().getServletContext();
  }
  ```

**作用**

1. 获取web.xml中配置的上下文参数 context-param

   （以6.1.4中web.xml文件为例）

   ```java
   String username = context.getInitParameter("username"); // root
   String pwd = context.getInitParameter("password"); // 123456
   ```

2. 获取当前的工程路径，格式为`/工程路径`

   即在浏览器输入 `ip:port/工程路径`访问到当前web工程（访问到的web文件夹）

   ```java
   context.getContextPath();
   ```

3. 获取工程部署后在服务器硬盘上的绝对路径

   参数`/`表示获取到工程根目录的绝对路径，即工程中的web文件夹的路径

   ```java
   context.getRealPath("/");
   // D:\CS_Source\JavaSource\JavaWeb\out\artifacts\webTest_war_exploded\
   ```

4. 存取数据（类似于map一样使用）

   由于一个web工程只有一个ServletContext对象，因此在一个Serlvet程序中添加的数据在其他Servlet程序中都能取到。

   重新部署或者重启服务器都会使这些数据失效

   ```java
   // 存数据
   context.setAttribute("key1", "value1");
   // 取数据
   context.getAttribute("key1");
   // 删除数据
   context.removeAttribute("key1");
   ```

## 6.4 HttpServletRequest类

service方法中有两个参数，一个是HttpServletRequest，一个是HttpServletResponse

当有请求进入Tomcat服务器时，服务器就会把请求过来的HTTP协议中的信息解析好并封装到HttpServletRequest对象中，然后传递到service方法的参数中供我们使用

### 6.4.1 常用方法

重写service或者doGet/doPost方法之后，在参数中有一个 HttpServletRequest类型的req对象，这个对象中封装了一些方法

- getRequestURI —— 获取请求的资源路径

  ```java
  String URI = req.getRequestURI(); // 只返回ip:port/ 斜杠后面的部分，即资源路径
  ```

- getRequestURL —— 获取请求的统一资源定位符（绝对路径）

  ```java
  String URL = req.getRequestURL(); // 返回完整路径 ip:port/资源路径
  ```

- getRemoteHost —— 获取客户端ip地址

  当在本机访问时，返回127.0.0.1

  其他客户端访问时返回客户端的真实ip

  ```java
  String host = req.getRemoteHost();
  ```

- getHeader —— 获取请求头中各种信息

  参数中填写需要请求头中的哪个值

  ```java
  String user_agent = req.getHeader("User-Agent");
  ```

- getMethod —— 获取请求的方式（GET/POST）

  ```java
  String method = req.getMe
  ```

- getParameter —— 获取客户端传来的参数

  函数中的参数为 客户端传来参数的name

- getParameterValues —— 当参数值有多个时使用这个

  返回一个String数组

  ```html
  <!-- 表单示例 -->
  <form action="http://localhost:8080/servlet/HelloServlet" method="post">
      用户名：<input type="text" name="username"><br/>
      密码：<input type="password" name="password"><br/>
      <!-- 多选框 -->
      兴趣爱好：<input type=checkbox name="hoppy" value="cpp">C++
      <input type=checkbox name="hoppy" value="java">Java
      <input type=checkbox name="hoppy" value="js">JavaScript<br/>
      <input type="submit">
  </form>
  ```

  ```java
  String username = req.getParameter("username");
  String password = req.getParameter("password");
  String[] hobbies = req.getParameterValues("hobby");
  ```

- setCharacterEncoding —— 解决post请求的中文乱码问题

  需要在获取所有请求参数之前设置才有效

  ```java
  req.setCharacterEncoding("UTF-8");
  ```

### 6.4.2 请求转发

请求转发指：服务器收到请求之后，从一个资源转到另一个资源

比如一个功能需要先执行Servlet1再执行Servlet2，客户端的请求传到Servlet1之后，Servlet1再将请求转发到Servlet2程序就叫请求转发

两个Servlet程序之间传递消息要使用域数据

**Servlet1**

```java
public class Servlet1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, 
                         HttpServletResponse resp)
        throws ServletException, IOException {
        
        // 客户端发来的数据
        String username = req.getParameter("username");
        
        // 不同Servlet程序之间通信使用域数据
        req.setAttribute("key1", "Servlet1要传的数据");
        
        // 请求转发
        // 这里的地址必须以 / 打头，/ 表示 http://ip:port/工程名/ ，映射到web工程的web目录
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("/servlet2");
        requestDispatcher.forward(req, resp);
    }
}
```

**Servlet2**

```java
public class Servlet2 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, 
                         HttpServletResponse resp)
        throws ServletException, IOException {
        
        // 也可以直接获取客户端发来的数据
        String username = req.getParameter("username");
        
        // servlet1传来的数据
		String value1 = req.getAttribute("key1");
    }
}
```

特性：

- 请求转发 对客户端来说不可见，即客户端认为这是一次请求

  所以浏览器中地址栏的地址并不会发生改变

- 可以转发到WEB-INF目录中（这个目录是受服务器保护的，无法直接访问）

- 转发路径必须以/打头，因此只能转发到工程内部，不能转发到外部服务器

**相对路径和base标签**

（也可以直接使用绝对路径，就不存在这个问题了，在框架中一般使用绝对路径）

请求转发之后浏览器中地址栏的地址并不会发生改变，也就是说浏览器访问`localhost:8080/Servlet1`，Servlet1程序再请求转发到Servlet2之后，浏览器地址栏中显示的依然是Servlet1的地址。

而由于浏览器在解析相对路径时时按照当前浏览器中的地址定位的，所以这样会导致转发后的页面的相对路径全部失效

可以通过设置base标签，来使得当前页面的所有相对路径都以base标签中设置的路径为基准，而不再以当前浏览器中地址定位。注意一个html页面中的base标签只能管理当前页面的所有相对路径。

```html
<head>
    <base href="http://localhost:8080/servlet/">
</head>
```

base标签的值一般设置为工程路径，即对应项目中的web目录下。

路径必须加`http://` 最后一个目录后面必须加`/` 。

## 6.5 HttpServletResponse类

和HttpServletRequest类一样，当客户端发送请求时，服务器会生成一个HttpServletResponse类供我们使用

该类用于表示所有服务器响应回客户端的信息，可以用它来设置返回给客户端的信息

可以用于：

- 设置响应头

  ```java
  resp.setHeader("Content-Type", "test/html; charset=UTF-8");
  ```

- 给客户端回传数据

  - 字节流数据：用于传输二进制文件，客户端请求下载时使用

    ```java
    resp.getOutputStream();
    ```

  - 字符流数据：给客户端回传字符串

    ```java
    resp.getWriter();
    ```

### 6.5.1 往客户端回传数据

**字符流数据**

1. 获取流对象

   ```java
   PrintWriter writer = resp.getWriter();
   ```

2. 向客户端回传数据

   ```java
   writer.write("123456");
   writer.println("123456");
   ```

3. 解决中文乱码问题

   需要同时改变服务器端和客户端的编码方式

   ```java
   // 改变服务器端编码方式
   resp.setCharacterEncoding("UTF-8");
   // 通过响应头改变客户端编码方式
   resp.setHeader("Content-Type", "test/html; charset=UTF-8");
   ```

   还有一种写法，可以一行代码同时设置服务器和客户端（这个方法必须在获取流对象之前使用才有效）

   ```java
   resp.setContentType("text/html; charset=UTF-8");
   ```

### 6.5.2 请求重定向

当客户端请求的资源已经被废弃并移动至新的地址时，服务器端需要告诉客户端新地址在哪里并让客户端重新访问，这个就是处理请求重定向请求

首先需要返回响应码302表示请求重定向，然后需要在响应头Location中告诉新地址

**示例**

Response1已经废弃，改用Response2响应客户端请求

```java
public class Response1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, 
                         HttpServletResponse resp)
        throws ServletException, IOException {
        
		// 设置响应状态码302
        resp.setStatus(302);
        
        // 在响应头中Loaction字段设置新地址
        resp.setHeader("Location", "http://localhost:8080/servlet/Response2");
    }
}
```

第二种方法

```java
resp.setRedirect("http://localhost:8080/servlet/Response2");
```

**特点**

- 对于客户端来说，这是两次不同的请求
- 不能访问WEB-INF中的资源
- 可以访问服务器外部的资源

# 7. jsp

jsp —— Java Server Pages

jsp的格式和用法都和HTML页面类似，主要作用是代替servlet实现给客户端回传html页面的功能。

当服务器需要回传给客户端一个页面时，如果使用Servlet程序，那就只能把页面源代码一行一行地通过resp对象回传过去，非常地麻烦且难以维护。

## 7.0 jsp本质

jsp本质上其实是一个Servlet程序，访问jsp页面时会创建一个 `文件名_jsp.java `的类这个类间接继承于HttpServlet类

在工程中创建一个index.jsp文件

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
这是一个jsp网页
</body>
</html>
```

之后启动Tomcat服务器，在浏览器中访问该jsp。

当第一次访问jsp页面时，Tomcat服务器会将jsp页面翻译成为一个java源文件，并再编译为一个.class字节码文件。

启动Tomcat服务器时控制台会打印一栏 CATALINE_BASE，这是Tomcat服务器部署时使用的目录，打开这个目录，在该目录下的`./work/Catalina/localhost/工程名/org/apache/jsp`中可以看到jsp文件名对应的java文件`index_jsp.java`。

打开这个文件，可以发现翻译后的java源代码为

```java
public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

                     
      public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {      
                         ...
          response.setContentType("text/html;charset=UTF-8");
          pageContext = _jspxFactory.getPageContext(this, request, response,
                    null, true, 8192, true);
          _jspx_page_context = pageContext;
          application = pageContext.getServletContext();
          config = pageContext.getServletConfig();
          session = pageContext.getSession();
          out = pageContext.getOut();
          _jspx_out = out;

          out.write("\r\n");
          out.write("\r\n");
          out.write("<html>\r\n");
          out.write("<head>\r\n");
          out.write("    <title>Title</title>\r\n");
          out.write("</head>\r\n");
          out.write("<body>\r\n");
          out.write("这是一个jsp网页\r\n");
          out.write("</body>\r\n");
          out.write("</html>\r\n");
                         ...
     }             

}
```

- 首先可以看到这个类继承于`org.apache.jasper.runtime.HttpJspBase`类，HttpJspBase类又继承于HttpServlet类，所以这是一个Servlet程序。

  ```java
  public abstract class HttpJspBase extends HttpServlet implements HttpJspPage {
      
  }
  ```

- 再往下可以看到jsp页面翻译后也是将HTML源码一行一行传输给客户端。和我们用Servlet程序回传HTML页面使用的方式相同。只不过服务器帮我们完成了这个工作

## 7.1 page指令

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

jsp页面的头部有一行，叫做page指令。

用于修改jsp页面中的重要属性和行为

### 7.1.1 常用属性

- language —— 表示jsp页面翻译后是什么语言，只支持java

- contentType —— 表示jsp返回给客户端的数据类型是什么。也是翻译后的java源码中 response.setContentType()的参数值

- pageEncoding —— jsp文件本身使用的编码

- import —— 导包，和java中的import一样

  ```jsp
  <%@ page import="java.util.Map" %>
  ```

- autoFlush —— 当out输出缓冲区满了之后，是否自动刷新

  默认为true

  out即给客户端回传数据的流对象，用于回传jsp页面源码

- buffer —— 设置out缓冲区的大小，默认为8kb

- errorPage —— 用于指定errorPage的路径，当页面出错时自动跳转到errorPage

  ```jsp
  <%@ page errorPage="/error.jsp" %>
  <!--
  路径以 / 打头，斜杠表示请求地址为 http://ip:port/工程路径，映射到工程中的web目录下
  -->
  ```

- isErrorPage —— 设置当前jsp页面是否是errorPage，默认是false

  如果置为true，该页面中会产生一个exception异常对象，来保存错误信息

- session —— 设置访问当前的jsp页面时是否会创建HttpSession对象。默认是true

- extends —— 指定jsp翻译出来的java类默认继承哪个类

## 7.2 脚本

脚本用于在jsp页面中写java代码

这些脚本都是写在jsp页面的body体中，翻译之后在java代码的 _jspService方法中

### 7.2.1 声明式脚本

jsp页面运行时会被翻译为java中的一个类，声明脚本就是在这个类中声明 变量、方法、代码块

格式为 `<%!  %>`

- 创建属性

  ```jsp
  <%!
  	public int age;
  	private String name;
  	private static Map<String, Integer> map;
  %>
  ```

- 创建方法

  ```jsp
  <%!
  	public int sum (int a, int b) {
      	return a + b;
  	}	    
  %>
  ```

- 创建静态代码块

  ```jsp
  <%!
  	static {
      	map = new HashMap<String, Integer>();
      	map.put("key1", 1);
  	}    
  %>
  ```

- 声明内部类

  ```jsp
  <%!
  	public class A {
          private Integer id = 1;
          public String name = "a";
      }	   
  %>
  ```

### 7.2.2 表达式脚本

用于在jsp页面上输出数据，直接显示在jsp页面上

基本格式为：`<%=表达式%>`

```jsp
<%=12 %> 空格也会被输出
<%=12.12%>
<%="字符串"%>
<%=map%>  输出一个map对象
<%=request.getParameter("username")%> _jspService方法中对象都可以直接使用，注意语句结尾不能加分号
```

在翻译后的java源代码中，都转化为了

```java
out.print(12 ); // 空格也会被输出
out.print(12.12);
out.print("字符串");
out.print(map);
```

### 7.2.3 代码脚本

作用是在jsp页面中编写java语句实现功能，可以使用判断、循环等结构语句

基本格式为`<%java代码%>`

```java
<%
    int i = 1;
	if (i == 1) {
        System.out.println("1"); // 这里是打印到控制台
    } else {
        sout("2");
    }
%>
```

还可以由多个代码脚本组合完成一个语句，翻译成java代码之后没有区别

```jsp
<%
    int i = 1;
	if (i == 1) {
%>
<%
        System.out.println("1"); // 这里是打印到控制台
    } else {
        sout("2");
    }
%>
```

这样就可以配合表达式脚本实现在页面上输出数据

```java
<%
    int i = 1;
	for (; i < 10; i++);
%>
    <%=i %>
<%
    }
%>

// 在jsp页面上打印 1~9
```

再和html标签配合可以实现非常复杂的页面输出

## 7.3 内置对象

内置对象是指翻译成Java程序之后，_jspService中提供的九个可供使用的内置对象

- request —— 请求对象
- response —— 响应对象
- pageContext —— jsp上下文对象
- session —— 会话对象
- application —— ServletContext对象
- config —— ServletConfig对象
- out —— jsp输出流对象
- page —— 指向当前jsp对象
- exception —— 异常对象

### 7.3.1 域对象

域对象用于存储数据。

四个域对象功能相同，只是存储的数据能访问到的范围不同

- request —— 请求对象，HttpServletRequest类
- application —— ServletContext对象
- pageContext —— jsp上下文对象，PageContextImpl类
- session —— 会话对象， HttpSession类

### 7.3.2 用于输出的对象

- out
- response.getWriter

## 7.4 JSP常用标签

### 7.4.1 静态包含

当网站中的多个页面都要用到同一页面时（比如页脚部分）

就可以将页脚部分单独写为一个页面，并在其他页面使用静态包含引用这个部分

```jsp
<%@ include file="/include/footer.jsp" %>
```

翻译之后的代码其实会把被引用页面直接复制过去

### 7.4.2 动态包含

动态包含和静态包含作用相同，只是原理不同

```jsp
<jsp:include page="/include/footer.jsp"></jsp:include>
```

翻译之后的代码变为了以下形式来调用被引用的页面

```java
JspRuntimeLibrary.inclue(request, response, "/include/footer.jsp", out, false);
```

### 7.4.3 请求转发

```jsp
<jsp:forward page="/page2.jsp"></jsp:forward>
```

转发到page2页面

## 7.5 Listener监听器

Listener是JavaEE的规范，即接口。

作用是监听某种事物的变化，然后触发回调函数。

### 7.5.1 ServletContextListener监听器

监听ServletContext对象的创建和销毁，监听到之后调用响应的函数

**使用步骤**

1. 实现ServletContextListener接口

2. 重写方法

   ```java
   public class MyServletContextListenerImpl implements ServletContextListener {
       @Override
       public void contextInitialized(ServletContextEvent sce) {
           sout("ServletContext对象被创建");
       }
       @Override
       public void contextDestroyed(ServletContextEvent sce) {
           sout("ServletContext对象被销毁"):
       }
   }
   ```

3. 在web.xml文件中配置

   ```xml
   <listener>
       <listener-calss>com.sazser.listener.MyServletContexxtListenerImpl</listener-calss>
   </listener>
   ```

## 7.6 EL表达式

用于代替jsp的表达式脚本，往页面上输出数据

EL表达式会简便很多

### 7.6.1 基本用法

1. 主要用于输出域对象中的数据

```jsp
<%
	pageContext.setAttribute("key", "pageContext");
%>
${key} // 输出pageContext
```

当多个域中都有相同的key时，会按照域的作用范围大小 从小到大 找到范围最小的来输出

2. 还可以进行一些运算，并直接输出运算结果

   关系运算、逻辑运算、算术运算

```jsp
$(12==12)
${12eq12}
```

### 7.6.2 11个隐含对象

**获取jsp九大内置对象**

pageContext，获取jsp的九大内置对象

```jsp
${pageContext.servletConfig}
${pageContext.request.scheme} // 获取jsp中的request对象，进而获取使用的协议 
```

**获取域对象中数据**

- pageScope —— 获取pageContext域中数据

  `${pageScope.key1}`

- requestScope —— 获取Request域中数据

  `${requestScope.key1}`

- sessionScope —— 获取Session域中的数据

- applicationScope —— 获取ServletContext域中的护具

**获取请求参数的值**

- param
- paramValues

**获取请求头信息**

- header
- headerValues

**获取Cookie信息**

cookie

**获取InitParam**

initParam，获取在web.xml中配置的\<context-param>的数据

## 7.7 JSTL标签库

JSTL标签库 全称：JSP Standard Tag Library

主要是为了替换代码脚本，使得整个jsp页面更加简洁

使用标签库之前要先导入jar包，再使用taglib指令引入标签库

- CORE标签库：核心标签库

  ```jsp
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  ```

- FML标签库：格式化标签库

  ```jsp
  <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
  ```

- FUNCTIONS标签库：函数

  ```jsp
  <%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
  ```

- SQL标签库：数据库（不使用）

  因为在jsp页面直接访问SQL数据库破坏了JavaEE三层结构，应该经过DAO层访问数据库

  ```jsp
  <%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>
  ```

- XML标签库：不使用，现在传数据一般用json

### 7.7.1 core核心库

- **set标签**：往域中保存数据

  - scope：设置保存在哪个域对象中

  - var：设置key是多少
  - value：设置value

  ```jsp
  <c:set scope="page" var="key1" value="value1" />
  ```

- **if标签**：做if判断

  中间的判断使用EL表达式，如果判断为真，则指定if标签中间的部分

  不支持if-else，只能做一次if判断

  ```jsp
  <c:if test="${12 == 12}">
      <h1>12等于12</h1>
  </c:if>
  ```

- **choose-when-otherwise** ： 做多路判断

  类似于switch-case-default

- **forEach标签**：遍历容器

## 7.8 文件上传

客户端上传文件到服务器

### 7.8.1 基本流程

想接收客户端上传的文件时，需要注意以下四点

1. 要有一个form标签，method=post

   因为get请求有长度限制

2. form标签的encType属性值必须为 multipart/form-data

   该属性值表示提交的数据以多段的形式进行拼接，每个表单项为一段，中间以分隔符进行分隔。（在接收到的HTTP表单中的Content-Type项中会有boundary指定此次使用的分隔符）

   数据以二进制流的形式发送给服务器

3. 在form标签中使用 `<input type=file>` 标签添加上传的文件

   ```html
   <form action="" method="post" enctype="multipart/form-data">
       <input type="file" name="photo" >
   </form>
   ```

4. 在服务器端编写Servlet程序进行接收并处理上传的数据

   由于是以流的形式发送，因此服务器端要用输入流来接收

   ```java
   ServletInputStream inputStream = req.getInputStream();
   
   byte[] buffer = new byte[102400];
   int read = inputStream.read(buffer);
   sout(new String(buffer, 0, read));
   ```

### 7.8.2 使用第三方jar包

现在已经有很多第三方jar包可以用于处理服务器处理上传文件

commons-fileupload.jar 和 commons-io.jar（处理输入流）

**使用步骤**

```java
// 创建对象
FileItemFactory fileItemFactory = new DiskFileItemFactory();
ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
// 解析，每一个FileItem代表一个表单项
List<FileItem> list = servletFileUpload.parseRequest(req);

// 遍历解析好的表单项
for (FileItem fileItem : list) {
    if (fileItem.isFormField()) { // 如果是普通的表单项
        sout(fileItem.getFieldName() + " : " + fileItem.getString("UTF-8"));
    } else { // 如果是上传的文件
        // getName是上传的文件名
        sout(fileItem.getFieldName() + " : " + fileItem.getName());
        
        // 将上传的文件保存到服务器指定目录
        fileItem.write(new File("filePath"));
    }
}
```

## 7.9 文件下载

客户端从服务器下载文件

### 7.9.1 基本步骤

1. 服务器从客户端获取要下载的文件名

   ```java
   String downloadFileName;
   ```

2. 获取要下载的文件内容

   通过ServletContext对象读取

   ```java
   ServletContext servletContext = getServletContext();
   InputStream resourceAsStream = servletContext.getResourceAsStream("/file/" + downloadFileName);
   ```

3. 在回传前，要通过响应头告诉客户端返回的数据类型，还要告诉客户端此次收到的数据是用于下载使用

   ```java
   // 获取文件类型
   String mimeType = servletContext.getMimeType("/file/" + downloadFileName);
   // 设置响应头，告诉客户端返回数据的mime类型
   resp.setContentType(mimeType);
   // 告诉客户端收到的数据是用于下载使用
   // Content-Disposition - 表示收到的数据怎么处理
   resp.setHeader("Content-Disposition", "attachment; filename=" + downloadFileName);
   ```

   如果传输的文件名是中文，需要进行url编码

   ```java
   resp.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode("中国.jpg", "UTF-8"));
   ```

4. 把文件内容回传给客户端

   ```java
   // 获取输出流
   OutputStream outputStream = resp.getOutputStream();
   // 将输入流中的全部数据复制给输出流，并输出给客户端
   // IOUtils在 commons-io.jar包中
   IOUtils.copy(resourceAsStream, outputStream);
   ```

   

# 8. 书城项目思路

在之前已经实现：

**注册**

1. 注册时的页面检测

   在用户输入完用户名密码点击提交之后，真正提交给服务器之前，使用JavaScript检测用户名密码是否符合要求。如果不符合要求就不做跳转（但是无任何提示信息）

2. Servlet程序

   将客户端发来的用户名密码等信息存储为一个Pojo/Bean对象（User对象）

3. DAO层

   Servlet程序打包好User对象之后，调用DAO层存储进数据库进行持久化保存

**登录**

## 8.1 使用jsp

将所有html页面都替换为jsp页面，并将页面的相同部分（base标签、css样式、引用的js代码、页眉页脚等相同部分）提取出来使用静态包含

### 8.1.1 回显错误信息和表单项信息

客户端发送登录或注册请求之后，经过Servlet程序去访问数据库验证用户名是否存在以及用户名和密码是否匹配

如果发生错误，则Servlet程序将错误信息保存在Request域中，之后通过请求转发到原来的登录或注册页面中。而登录/注册页面就将request域中的错误信息显示到页面中（通过jsp打印），这样就完成了错误信息回显

用户原先填在表单中的信息也可以同理进行回显

### 8.1.2 使用反射优化if-else

之前对登录和注册的实现是，创建了一个LoginServlet程序和RegistServlet程序，登录表单就发给LoginServlet程序，注册表单就提交给RegistServlet程序

之后进行优化，将用户相关操作都统一到UserServlet程序进行处理，使用一个隐藏的input标签`<input type="hidden" name="action" value="login" />`的value值来回传此次提交的是什么表单，之后在UserServlet类的doPost方法中通过判断来决定调用哪个方法

但是当以后需要添加更多用户操作，比如修改用户名、修改密码等时，势必每次都需要修改doPost的代码，添加if-else判断来调用不同操作对应的函数。

此时就应该使用反射机制来优化if-else，同时避免对doPost的修改。这样的话以后再添加用户相关的功能只需要在UserServlet类中添加函数即可

```java
protected void login (HttpServletRequest req, HttpServletResponse resp){
	// 实现登录功能的函数
}

@Override
protected void doPost (HttpServletRequest req, HttpServletResponse resp){
    String action = req.getParameter("action"); 

    // 通过反射机制拿到action对应的函数
    // 通过函数名称和函数的参数列表拿到对应函数
    Mehod method = this.getClass().getDeclaredMthod(action, HttpServletRequest.class, HttpServletResponse.class); 
    
    // 调用目标业务的方法
    method.invoke(this, req, resp);
}
```

