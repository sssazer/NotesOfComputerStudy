# MyBatis

# 1. QuickStart

MyBatis是一个基于Java的持久层框架，原名ibatis

可以说是JDBC的封装，使用简单的XML或注解完成对数据库数据的操作

## 1.1 搭建开发环境

### 1.1.1 引入MyBatis依赖

```xml
<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.7</version>
</dependency>
```

### 1.1.2 创建MyBatis核心配置文件

文件名可以自定义，习惯上命名为 mybatis-config.xml，存放在`src/main/resources`目录下

整合Spring后这个配置文件可以省略

主要用于配置连接数据库的环境以及MyBatis的全部配置信息

这个配置文件的内容可以在官方文档中复制，官方文档可以在github中查看

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/mybatistest?serverTimezone=UTC"/>
        <property name="username" value="root"/>
        <property name="password" value="wangyize201"/>
      </dataSource>
    </environment>
  </environments>
<!--  引入mybatis的映射文件-->
  <mappers>
    <mapper resource="mappers/UserMapper.xml"/>
  </mappers>
</configuration>
```

在映射文件中写具体的mysql语句，因此需要将映射文件配置到核心配置文件中

### 1.1.3 创建mapper接口

mapper接口相当于以前的DAO层，区别在于mapper接口无需实现。mybatis会创建代理实现类，来将接口与配置文件中的sql语句相关联

接口命名规则：要操作的实体类+Mapper，比如UserMapper

```java
package com.sazer.ssm.mapper;

public interface UserMapper {
    int insertUser();
}
```

### 1.1.4 创建MyBatis映射文件

ORM：Object Relationship Mapping 对象关系映射 

比如一个pojo类对应一张表、一个属性对应一个字段（列）、一个对象对应一条记录（行）

**映射文件和mapper接口的映射：**

一个映射文件对应一个mapper接口，最好和对应的接口同名

- 同时需要保证mapper标签的namespace和mapper接口的全类名一致
- sql语句标签的id值要和对应的接口名一致

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sazer.ssm.mapper.UserMapper">
<!--    int insertUser();-->
    <insert id="insertUser">
        insert into t_user values(null, 'admin', '123456', 23, '男', 'admin@qq.com')
    </insert>
</mapper>
```

### 1.1.5 执行sql语句

1. 获取核心配置文件的输入流

   ```java
   InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
   ```

2. 获取sqlSessionFactoryBuilder对象

   顾名思义，用于sqlSessionFactory对象的构造

3. 获取sqlSessionFactory对象

   顾名思义，是sqlSession的工厂，用于生产sqlSession

4. 获取sqlSession对象

   sql会话对象，是MyBatis提供的操作数据库的对象

5. 获取mapper接口的代理实现类对象

   接口没办法直接创建对象，所以获取mapper对象是mybatis底层创建了实现类

6. 调用mapper接口中的方法操作数据库

7. 手动提交事务

   使用sqlSession默认是回滚，不会自动提交

   可以在创建sqlSession对象时设置自动提交

   ```java
   SqlSession sqlSession = sqlSessionFactory.openSession(true);
   ```

8. 关闭sqlSession

```java
@Test
public void testInsert() throws IOException {
    // 1. 获取核心配置文件输入流
    InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
    // 2. 获取SqlSessionFactoryBuilder对象
    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
    // 3. 获取sqlSessionFactory对象
    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
    // 4. 获取sqlSession对象
    SqlSession sqlSession = sqlSessionFactory.openSession();
    // 5. 获取mapper接口的代理对象
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    // 6. 指定对应方法操作数据库
    int result = mapper.insertUser();
    System.out.println(result);
    // 7. 提交事务
    sqlSession.commit();
    // 8. 关闭sqlSession对象
    sqlSession.close();
}
```

还有一种通过sqlSession对象，直接找到对应方法名进行执行的方法（getMapper底层也是调用这个方法）

```java
int result = sqlSession.insert("com.sazer.ssm.mapper.UserMapper.insertUser");
```

## 1.2 执行查询操作

**查询单个用户**

- UserMapper

```java
User getUserById();
```

- 映射文件

  需要使用resultType属性，指定查询结果的类型，即查询的结果要转化为的实体类

```xml
<!-- User getUserById()-->
<select id="getUserById" resultType="com.sazer.ssm.pojo.User">
	select * from t_user where id = 1
</select>
```

- 执行操作

```java
User user = mapper.getUserById();
```

**查询所有用户**

- UserMapper

```java
List<User> getAllUsers();
```

- 映射文件

  和查询单个用户相同

```java
<!-- User getAllUsers()-->
<select id="getAllUsers" resultType="com.sazer.ssm.pojo.User">
	select * from t_user
</select>
```

- 执行操作

```java
List<User> list = mapper.getAllUser();
```

## 1.3 核心配置文件

配置文件中标签的配置顺序是有要求的 顺序为：properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?

配置文件的内容可以在idea中创建一个模板，在settings - File and Code Templates，右边选择Files下添加模板

**environments**

在这个标签内部使用environment标签 配置连接数据库的环境，可以配置多个

使用default标签来表明当前要连接的数据库

**typeAliases**

设置类型别名，即为某个具体的类设置一个别名，在MyBatis范围中就可以使用别名表示一个具体的类型

如果不指定alias属性，则别名默认为类名，且不区分大小写

还可以使用package标签指定一个类名，则指定包下的所有类型将全部拥有默认别名（即类名，且不区分大小写）

```xml
<typeAliases>
    <typeAlias type="com.sazer.ssm.pojo.User" alias="abc"></typeAlias>
    <package name="com.sazer.ssm.pojo" />
</typeAliases>

<!-- 使用别名-->
<select id="getAllUser" resultType="abc">
	select * from t_user
</select>
```

**mappers**

引入mybatis的映射文件

由于每个mapper接口都要对应一个映射文件，配置起来比较麻烦

因此可以通过package标签来将一个目录下的映射文件全部自动配置

但是要保证 映射文件的位置 和mapper接口的位置一样。比如mapper接口在 main/java/com/sazer/ssm/mapper 目录下，则映射文件也要放在 resources/com/sazer/ssm/mapper目录下。并且mapper接口的名字和映射文件的名字必须一致

放在同一目录下之后，打包之后就在同一文件夹下了

```xml
<mappers>
	<package name="com.sazer.ssm.mapper" />
</mappers>
```

**properties**

可以使用properties标签引入配置文件，这样就可以在标签中通过`${变量名}`使用配置文件的内容

```xml
<properties resource="jdbc.properties" />

<environments default="development">
    <environment id="development">
        <transactionManager type="JDBC"/>
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.Driver}"/>
            <property name="url" value="${jdbc.url}"/>
            <property name="username" value="${jdbc.username}"/>
            <property name="password" value="$"/>
        </dataSource>
    </environment>
</environments>
```

# 2. 获取sql语句的参数

MyBatis提供了两种方式来为sql语句注入参数，`${}`和`#{}`，前面的本质是字符串拼接，后面的本质是占位符赋值

## 2.1 获取单个变量

比如通过用户名查询用户

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User getUserByUsername(String username);
}
```

**MyBatis映射文件**

其实在{}中可以通过任意字符来获取参数，但是建议使用形参的名字

```xml
<select id="getUserByUsername" resultType="User">
	select * from t_user where username = #{username}
</select>
```

如果使用${}也就是字符串拼接时，要手动加单引号

```xml
<select id="getUserByUsername" resultType="User">
	select * from t_user where username = '${username}'
</select>
```

**调用函数实现功能**

```java
User user = mapper.getUserByUsername("admin");
```

## 2.2 获取多个变量

### 2.2.1 使用多个形参

比如通过用户名和密码验证登录

需要多个变量时，MyBatis会将参数放在map集合中，以两种key来保存

- arg0、arg1、arg2......
- param0、param1、param2......

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User checkLogin(String username, String password);
}
```

**MyBatis映射文件**

由于在{}中可以通过任意字符来获取参数，所以其实就是不能使用形参名来获取参数

可以使用arg0，arg1或者param0，param1来获取指定位置的参数

```xml
<select id="checkLogin" resultType="User">
	select * from t_user where username = #{arg0} and password = ${arg1}
</select>
```

${}依然需要加单引号

**调用函数实现功能**

```java
User user = mapper.getUserByUsername("admin", "123456");
```

### 2.2.2 使用Map集合

也可以手动传入一个map集合来作为参数，这样的话就可以使用自定义的键来获取参数

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User checkLogin(Map<String, String> map);
}
```

**MyBatis映射文件**

由于在{}中可以通过任意字符来获取参数，所以其实就是不能使用形参名来获取参数

可以使用arg0，arg1或者param0，param1来获取指定位置的参数

```xml
<select id="checkLogin" resultType="User">
	select * from t_user where username = #{username} and password = #{password}
</select>
```

${}依然需要加单引号

**调用函数实现功能**

```java
Map<String, String> map = new HashMap<>();
map.put("username", "admin");
map.put("password", "123456");
User user = mapper.getUserByUsername("admin", "123456");
```

### 2.2.3 使用注解命名参数

可以使用@Param注解在value属性中指定键，来让MyBatis创建map集合时使用指定的键

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    User checkLogin(@Param("username") String username, @Param("password") String password);
}
```

## 2.3 获取实体类变量

比如添加用户时，需要传入一个User实体类对象

**mapper接口**

在接口中声明形参，来接收参数并传给MyBatis

```java
public interface UserMapper {
    void insertUser(User user);
}
```

**MyBatis映射文件**

可以直接使用属性名访问对应属性

```xml
<select id="checkLogin" resultType="User">
	insert into t_user values(null, #{username}, #{password}, #{age}, #{gender}, #{email})
</select>
```

${}依然需要加单引号

**调用函数实现功能**

```java
User user = new User(属性值);
User user = mapper.getUserByUsername(user);
```

# 3. 查询操作

## 3.1 查询一行数据

**mapper接口**

查询一行数据时，返回的应该是一个实体类对象

```java
public interface UserMapper {
    User getUserById(@Param("id") Integer id);
}
```

**MyBatis映射文件**

需要指定返回值类型为User类型

```xml
<select id="getUserById" resultType="User">
	select * from t_user where id = #{id}
</select>
```

**调用函数实现功能**

```java
User user = mapper.getUserById(0);
```

## 3.2 查询多行数据

**mapper接口**

查询多行数据时，返回的应该是一个List集合

```java
public interface UserMapper {
    List<User> getAllUsers(@Param("id") Integer id);
}
```

**MyBatis映射文件**

只需要指定返回值类型为User类型

```xml
<select id="getAllUsers" resultType="User">
	select * from t_user
</select>
```

**调用函数实现功能**

```java
List<User> users = mapper.getAllUsers();
```

## 3.3 查询一个数据值

**mapper接口**

查询一个数据时，返回的结果类型应该是那个数据的类型

```java
public interface UserMapper {
    Integer getCount();
}
```

**MyBatis映射文件**

只需要指定返回值类型为int类型

这个int实际上是MyBatis提前设置好的别名，原本应该写 java.lang.Integer

```xml
<select id="getCount" resultType="int">
	select count(*) from t_user
</select>
```

**调用函数实现功能**

```java
Integer count = mapper.getCount();
```

## 3.4 查询多个数据值

当查询的结果为多个数据时，比如查询员工总数、工资总和、工资平均值，或者查询的一行数据没有对应的实体类时，就将这一行数据保存为一个map，最终将所有数据保存在一个map集合中

### 3.4.1 保存为一个map

在表没有对应实体类的情况下，查询一行数据时，也可以将这一行数据保存为一个map，属性（字段）名就是key，值就是value。查询多行数据时，可以将多个User对象保存为map集合，每行对应一个map

**mapper接口**

```java
public interface UserMapper {
    Map<String, Object> getUserById(@Param("id") Integer id);
}
```

**MyBatis映射文件**

这个map实际上是MyBatis提前设置好的别名

```xml
<select id="getUserById" resultType="map">
	select * from t_user where id = #{id}
</select>
```

**调用函数实现功能**

```java
Map<String, Object> map = mapper.getUserById();
sout(map); //{password=123456, gender=男, id=1, age=23, email=admin@qq.com, username=admin}
```

### 3.4.2 保存为map集合

**mapper接口**

```java
public interface UserMapper {
    List<Map<String, Object>> getAllUsers();
}
```

**MyBatis映射文件**

这个map实际上是MyBatis提前设置好的别名

```xml
<!--    Map<String, Object> getUserById(@Param("id") Integer id);-->
<select id="getUserById" resultType="map">
    select * from t_user where id = #{id}
</select>
```

**调用函数实现功能**

```java
List<Map<String, Object>> res = mapper.getAllUsers();
System.out.println(res);
/* [{password=123456, gender=男, id=1, age=23, email=admin@qq.com, username=admin}, 
{password=123456, gender=男, id=2, age=23, email=admin@qq.com, username=admin}, 
{password=123456, gender=女, id=3, age=12, email=Tom@153.com, username=Tom}] */
```

### 3.4.2 保存为map嵌套map

一行数据对应一个map，在获取多行数据时，也可以将对应的map作为value保存，此时需要再将某个字段的值指定为key

**mapper接口**

```java
public interface UserMapper {
    @MapKey("id") // 指定key为数据中的id值
    Map<String, Object> getAllUsersToMap();
}
```

**MyBatis映射文件**

这个map实际上是MyBatis提前设置好的别名

```xml
<!--    Map<String, Object> getAllUsersToMap();-->
<select id="getAllUsersToMap" resultType="map">
    select * from t_user
</select>
```

**调用函数实现功能**

```java
Map<String, Map<String, Object>> res = mapper.getAllUsersToMap();
System.out.println(res);
/*{1={password=123456, gender=男, id=1, age=23, email=admin@qq.com, username=admin}, 
 2={password=123456, gender=男, id=2, age=23, email=admin@qq.com, username=admin}, 
 3={password=123456, gender=女, id=3, age=12, email=Tom@153.com, username=Tom}} */
```

# 4. 特殊SQL执行

## 4.1 模糊查询

模糊查询就是使用LIKE关键字，来找到符合匹配规则的记录

比如要查询用户名中包含指定字母的记录

**mapper接口**

```java
public interface UserMapper {
    List<User> getUserByLike(@Param("like") String like);
}
```

**MyBatis映射文件**

如果使用#{}来获取参数，也就是`like '%#{like}%'` ，由于#{}在单引号中，因此它会被当做字符串的一部分，而不会被当作是一个占位符来解析，因此无法完成赋值，有三种方式可以解决

1. 但是用${}是可以的，因为${}被当作字符串拼接

2. 或者用mysql中提供的字符串拼接函数concat

3. 用双引号 + #{}

```xml
<select id="getUserByLike" resultType="User">
    select * from t_user where user like '%${like}%'
</select>

<select id="getUserByLike" resultType="User">
    select * from t_user where user like concat('%', #{mohu}, '%')
</select>

<select id="getUserByLike" resultType="User">
    select * from t_user where user like "%"#{mohu}"%"
</select>
```

**调用函数实现功能**

找用户名中包含字母a的用户

```java
List<User> list = mapper.getUserByLike("a");
```

## 4.2 批量删除

`delete from t_user where id in (7,8)`

**mapper接口**

```java
public interface UserMapper {
    void deleteMultiUser(@Param("deleteId") String deleteId);
}
```

**MyBatis映射文件**

如果使用#{}，它会自动为获取的参数加上单引号，也就是变成 `delete from t_user where id in('9,10')`，无法执行

所以只能使用${}

```xml
<select id="getUserByLike" resultType="User">
    delete from t_user where id in (${deleteId})
</select>
```

**调用函数实现功能**

```java
mapper.deleteMultiUser("9,10");
```

## 4.3 动态设置表名

对于一个查询请求，可能有时候要从普通用户表中查询，有时候要从vip用户表中查询，因此需要动态指定表名

此时只能使用${}指定表名，因为表名不能加单引号

## 4.4 获取自增主键

在完成一个插入操作之后，获取刚刚插入的那条对应的id（因为id是自增自动分配的，而不是手动指定的）

**mapper接口**

自增主键不能作为方法返回值，因为对于更新操作，方法返回值只能是受影响的行数

```java
public interface UserMapper {
    void insertUser(User user);
}
```

**MyBatis映射文件**

通过useGeneratedKeys属性获取自增id

通过keyProperty属性设置将获取到的自增id保存在参数的哪个属性中，比如保存在传入的User参数的id属性中

```xml
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    insert into t_user values(null, #{username}, #{password}, #{age}, #{gender}, #{email})
</insert>
```

**调用函数实现功能**

```java
User user = new User(null, "Tom", "123456");
mapper.insertUser(user);
Integer id = user.getId(); // 创建该对象时没有id，但是添加完成之后，就将自增的id存入了user对象中
```

# 5.  映射关系（多表查询）

## 5.0 字段和属性名映射

MySQL的命名规则是下划线，而java的命名规则是驼峰，名称不同会发生无法直接完成映射的情况

### 5.0.1 使用全局配置

在MyBatis的核心配置文件中设置一个全局配置，将下划线映射为驼峰

全局配置使用settings标签，settings标签的位置在properties标签之后

开启之后可以自动将mysql字段名 emp_id 映射为 empId

```xml
<settings>
	<setting name="mapUnderscoreToCamelCase" value="true" />
</settings> 
```

### 5.0.2 resultMap自定义映射

在MyBatis核心配置文件的标签中，不使用resultType指定返回类型，而是使用resultMap指定映射

**resultMap标签**

指定映射关系

- type属性：标明这个映射关系处理的是哪个实体类的映射关系
- id标签：处理主键和实体类中属性的映射关系
- result标签：处理普通字段和实体类中属性的映射关系

```xml
<resultMap id="empResultMap" type="Emp"> // type标明这是关于Emp类的映射
	<id column="emp_id" property="empId"></id> // id标签指定主键的映射关系
    <result column="emp_name" property="empName"></result> //result标签指定普通字段的映射关系
    <result column="age" property="age"></result>
</resultMap>
```

**select标签**

在resultMap属性中指定要使用的resultMap的id

```xml
<select id="getEmpById" resultMap="empResultMap">
	select * from t_emp where emp_id = #{empId}
</select>
```

## 5.1 多对一关系

多个员工在同一个部门中就是多对一关系，如果想在员工对象中保存该员工所在的部门信息，就需要使用一个 Dept 类型的属性

因此多对一关系就对应一个实体类对象

**需求：**

查询员工信息，并将员工所在的部门也查询出来保存在员工对象的属性中

如果想在查询员工信息时将Emp对象中的Dept属性也进行赋值，就需要进行多表查询，将员工所在部门信息也查到并注入成为一个Dept对象。

```xml
对应的查询语句：

<select id="getEmpById" resultMap="empAndDeptResultMap">
	select * from t_emp 
    left join t_dept on t_emp.dept_id = t_dept.dept_id
    where emp_id = #{empId}
</select>
```

现在要解决的问题就是将查到的Dept字段属性注入到Emp的一个Dept类型的属性中。

resultType肯定无法完成这个映射，只能使用resultMap

### 5.1.1 使用级联

**resultMap**

将dept中的字段，直接和emp的dept属性中的字段进行映射

```xml
<resultMap id="empAndDeptResultMap" type="Emp">
    <!--emp中的属性-->
	<id column="emp_id" property="empId"></id>
    <result column="emp_name" property="empName"></result>
    <!--dept中的属性-->
    <result column="dept_id" property="dept.deptId"></result>
    <result column="dept_name" propert="dept.deptName"></result>
</resultMap>
```

### 5.1.2 association标签

association标签专门用于处理多对一映射，也就是属性为实体类属性时

- property属性：指定要处理的属性名
- javaType属性：指定要处理的属性名对应的实体类

```xml
<resultMap id="empAndDeptResultMap" type="Emp">
    <!--emp中的属性-->
	<id column="emp_id" property="empId"></id>
    <result column="emp_name" property="empName"></result>
    <!--dept中的属性-->
    <association property="dept" javaType="Dept">
    	<id column="dept_id" property="deptId"></id>
        <result column="dept_name" property="deptName"></result>
    </association>
</resultMap>
```

### 5.1.3 分步查询

用多个语句分步查询，实际上就是用另一个查询的结果来填充一些属性值

比如先查出来员工，再根据员工表的部门id去部门表中查出部门信息

1. 通过员工id查询员工信息

   ```java
   public interface EmpMapper {
       Emp getEmpAndDeptByStepOne(@Param("empId") Integer empId);
   }
   ```

   在association中，用select指定要调用哪个查询语句来获得填入dept属性的信息，column表示要填入查询语句的参数

   ```xml
   <resultMap id="empAndDeptByStepResultMap" type="Emp">
       <!--emp中的属性-->
   	<id column="emp_id" property="empId"></id>
       <result column="emp_name" property="empName"></result>
       <!--dept中的属性-->
       <association property="dept"        select="com.sazer.ssm.mapper.DeptMapper.getEmpAndDeptByStepTwo"
                    column="dept_id">
       	
       </association>
   </resultMap>
   
   <select id="getEmpAndDeptByStepOne" resultMap="empAndDeptByStepResultMap">
   	select * from t_emp where emp_id = #{empId}
   </select>
   ```

2. 通过员工所在的部门id查询部门信息

   可以写在一个方法或者一个接口中，但是最好保持一张表对应一个mapper接口

   ```java
   public interface DeptMapper {
       Dept getEmpAndDeptByStepTwo(@Param("deptId") Integer deptId);
   }
   ```

   ```xml
   <select id="getEmpAndDeptByStepTwo" resultType="Dept">
   	select * from t_dept where dept_id = #{deptId}
   </select>
   ```

### 5.1.4 延迟加载

分步查询的一个好处是可以实现延迟加载

比如要查询带有部门属性的员工信息，如果开启延迟加载，则只会查询员工信息。只有使用到部门属性时（`emp.dept`），才会执行第二步去部门表中查询并给员工对象的dept属性赋值

**开启延迟加载**

需要在配置文件中设置两个属性

- lazyLoadingEnabled：延迟加载的全局开关

  默认为false，开启之后所有对象都会延迟加载

- aggressiveLazyLoading

  默认为false，开启时，所有方法的调用都会加载该对象的所有属性（也就是不延迟加载）

```xml
<!--需要将lazyLoadingEnabled设置为true，同时aggressiveLazyLoading设置为false才能开启延迟加载-->
<settings>
	<setting name="lazyLoadingEnabled" value="true"></setting>
    <setting name="aggressiveLazyLoading" value="false"></setting>
</settings>
```

**控制单个属性的延迟加载**

在开启全局延迟加载之后，还可以在单独的sql语句中指定是延迟加载还是立即加载

在association标签的fetchType属性中指定，lazy表示延迟加载、eager表示立即加载

```xml
<resultMap id="empAndDeptByStepResultMap" type="Emp">
    <!--emp中的属性-->
	...
    <!--dept中的属性-->
    <association property="dept" fetchType="eager"        select="com.sazer.ssm.mapper.DeptMapper.getEmpAndDeptByStepTwo"
                 column="dept_id">
    	
    </association>
</resultMap>
```

## 5.2 一对多关系

一个部门对应多个员工就是一对多关系，如果想在部门对象中保存部门中所有的员工，就需要使用 `List<Emp>` 

因此一对多关系就对应集合

**需求：**

根据部门id查询部门信息，并将该部门中的所有员工作为List集合保存在部门对象的属性中

查询语句：

```xml
<!--Dept getDeptAndEmpByDeptId(@Param("deptId") Integer deptId)-->
<select id="getDeptAndEmpByDeptId" resultMap="deptAndEmpResultMap">
	select * from t_dept 
    left join t_emp on t_dept.dept_id = t_emp.dept_id
    where t_dept.dept_id = #{deptId}
</select>
```

### 5.2.1 collection标签

专门用于一对多映射关系，即处理集合类型的属性

- property属性表示给对象中的哪个属性赋值

- ofType表示集合中保存的元素的类型

```xml
<resultMap id="deptAndEmpResultMap" type="Dept">
	<id column="dept_id" property="deptId"></id>
    <result column="dept_name" property="deptName"></result>
    <collection property="emps" ofType="Emp">
    	<id column="emp_id" property="empId"></id>
        <result column="emp_name" property="empName"></result>
    </collection>
</resultMap>
```

### 5.2.2 分步查询

1. 根据部门id查询对应的id

   ```xml
   <resultMap id="deptAndEmpResultMap" type="Dept">
   	<id column="dept_id" property="deptId"></id>
       <result column="dept_name" property="deptName"></result>
       <collection property="emps" 
                   select="com.sazer.ssm.mapper.EmpMapper.getDeptAndByStepTwo"
                   column="dept_id">
       	<id column="emp_id" property="empId"></id>
           <result column="emp_name" property="empName"></result>
       </collection>
   </resultMap>
   
   <!--Dept getDeptAndEmpByStepOne(@Param("deptId") Integer deptId)-->
   <select id="getDeptAndEmpByStepOne" resultMap="deptAndEmpResultMap">
   	select * from t_dept where t_dept.dept_id = #{deptId}
   </select>
   ```

2. 根据部门id查询部门内的员工

   ```xml
   <!--List<Emp> getDeptAndByStepTwo(@Param("deptId") Integer deptId)-->
   <select id="getDeptAndByStepTwo" resultType="Emp">
   	select * from t_emp where dept_id = #{deptId}
   </select>
   ```


# 6. 动态SQL

解决拼接SQL语句字符串的难题

## 6.1 if - 多条件查询

多条件查询，就是有多个where条件使用and连接

如果服务器传来了这个参数，就要加上这个条件，如果没有传来这个参数（此时值为null或者""空字符串），就不加这个条件查询

**if标签**

test属性表示如果满足test的表达式，就将if标签内的语句拼接到SQL语句中。在test属性中可以直接通过属性名访问参数

为了避免所有条件都不成立时，sql语句变为 `select * from t_emp where`，可以在where后面加一个恒成立的条件

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp where 1=1
    <if test="empName != null and empName != ''">
    	and emp_name = #{empName}
    </if>
    <if test="age != null and age !=''">
    	and emp_age = #{empAge}
    </if>  
</select>
```

**where标签**

也可以使用where标签解决上面条件不成立时多一个where的问题

可以实现的功能

- 有条件成立时，自动加上where关键字
- 没条件成立时，自动去除where关键字
- 当拼接的语句前有多余的and时，可以去除（只能去除语句前的and，语句后去不掉）

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp
    <where>
        <if test="empName != null and empName != ''">
            emp_name = #{empName}
        </if>
        <if test="age != null and age !=''">
            and emp_age = #{empAge}
        </if> 
    </where>
</select>
```

**trim标签**

用于在字符串前后添加或去掉前后缀

- prefix/suffix：在标签内容前/后 添加指定内容
- prefixOverrides/suffixOverrides：在标签内容前/后 去掉指定内容

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp
    <trim prefix="where" suffixOverride="and">
        <if test="empName != null and empName != ''">
            emp_name = #{empName} and
        </if>
        <if test="age != null and age !=''">
            emp_age = #{empAge}
        </if> 
    </trim>
</select>
```

**choose、when、otherwise**

when和otherwise标签是choose标签的子标签，相当于if-else if-else

当找到test属性为true的when标签之后，就不会继续判断下面的when标签，所以最多只会添加一个查找条件

```xml
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select * from t_emp
    <where>
		<choose>
        	<when test="empName != null and empName != ''">
            	emp_name = #{empName}
            </when>
            <when test="age != null and age != ''">
            	age = #{age}
            </when>
        </choose>
    </where>
</select>
```

## 6.2 foreach

用于遍历集合类型的参数，有以下属性

- collection：要遍历的集合

  如果参数由@Param修饰，则使用@Param指定的值访问

  如果没有，则默认要填 list

- item：声明一个变量名，用于表示集合中遍历到的数据

- separator：foreach拼接的语句之间的分隔符

- open：拼接的字符串以什么开始

- close：拼接的字符串以什么结束

- index：获取当前遍历到的下标

### 6.2.1 批量添加

```xml
<!--void insertMultiEmp(@Param("emps") List<Emp> emps)-->
<insert id="insertMultiEmp">
	insert into t_emp values
    <foreach collection="emps" item="emp" separator=",">
    	(null, #{emp.empName}, #{emp.age})
    </foreach>
</insert>
```

执行完之后拼接好的sql语句为 `insert into t_emp values (null, "Tom", 18),(null, "Jerry", 25),(null, "Mary", 30)`

### 6.2.2 批量删除

**使用 in 关键字**

```xml
<!--void deleteMultiEmp(@Param("empIds") Integer[] empIds);-->
<delete id="deleteMultiEmp">
	delete from t_emp where emp_id in
    <foreach collection="empIds" item="empId" separator="," open="(" close=")">
        #{empId}
    </foreach>
</delete>
```

拼接之后的sql语句为：`delete from t_emp where emp_id in(1, 2, 3)`

**使用 or 关键字**

```xml
<!--void deleteMultiEmp(@Param("empIds") Integer[] empIds);-->
<delete id="deleteMultiEmp">
	delete from t_emp where 
    <foreach collection="empIds" item="empId" separator="or">
        emp_id = #{empId}
    </foreach>
</delete>
```

拼接之后的sql语句为：`delete from t_emp where emp_id = 1 or emp_id = 2 or emp_id = 3`

## 6.3 sql标签

可以用sql标签来记录一个sql语句片段，之后在需要使用的地方用include标签来引入

比如将表中所有字段名记录下来，就可以代替 * 

```xml
<sql id="empColumns">
	emp_id, emp_name, age, gender
</sql>

<select id="getAllEmp" resultType="Emp">
	select <include refid="empColumns"></include> from t_emp
</select>
```

# 7. 缓存

将查询到的数据进行缓存，这样下次执行相同的查询时，就可以直接返回结果，而不用再去数据库中查询

## 7.1 一级缓存

一级缓存是SqlSession级别的，即通过同一个SqlSession查询的数据会被缓存。一级缓存默认开启

下次使用相同的SqlSession查询相同的数据，才会从缓存中直接获取

**一级缓存失效的情况**

使用不同的SqlSession进行查询 或者 同一个SqlSession但是查询条件不同 时，不符合缓存条件

- 同一个SqlSession两次查询期间执行了任意一个增删改操作

- 手动清除缓存

  `sqlSession.clearCache();`

## 7.2 二级缓存

二级缓存是SqlSessionFactory级别，即通过同一个SqlSessionFactory创建的SqlSession查询的结果都会被缓存。二级缓存默认不会开启

**开启二级缓存**

1. 在核心配置文件中，设置全局配置属性cacheEnabled为true

   这个默认就是true，不需要设置

2. 在mapper映射文件中设置标签 `<cache/>`

   就在映射文件写上  `<cache />` 即可

3. 二级缓存必须在SqlSession关闭或提交之后有效

   一个SqlSession完成查询之后，会先把结果保存至一级缓存中。此时必须关闭（调用close函数）该SqlSession才会将结果上传至二级缓存。

4. 查询的数据所转换的实体类类型必须实现序列化接口

   ```java
   public class Emp implements Serializable {
       
   }
   ```

**二级缓存失效情况**

二级缓存不能手动清除

- 两次查询期间执行了任意一个增删改操作（会使一级和二级缓存同时失效）

## 7.3 整合第三方缓存EHCache

MyBatis的二级缓存可以使用第三方缓存，比如EHCache

# 8. MyBatis逆向工程

正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。比如Hibernate框架

逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成 Java实体类、Mapper接口、Mapper映射文件

在实际开发中，一般新建一个项目使用逆向工程生成，然后将生成的文件复制到自己所需的工程中，避免覆盖原有代码

## 8.1 生成简单的逆向工程

简单的逆向工程能生成五个方法，即增删改，查询全部和查询单个对象

1. 导入依赖

   使用build标签和plugin标签可以自定义maven插件，也就是可以在项目构建过程中执行特定的任务

   ```xml
       <build>
           <plugins>
               <plugin>
                   <groupId>org.mybatis.generator</groupId>
                   <artifactId>mybatis-generator-maven-plugin</artifactId>
                   <version>1.3.0</version>
   
                   <dependencies>
                       <!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core -->
                       <dependency>
                           <groupId>org.mybatis.generator</groupId>
                           <artifactId>mybatis-generator-core</artifactId>
                           <version>1.4.0</version>
                       </dependency>
                       <!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j -->
                       <dependency>
                           <groupId>com.mysql</groupId>
                           <artifactId>mysql-connector-j</artifactId>
                           <version>8.0.33</version>
                       </dependency>
                   </dependencies>
               </plugin>
           </plugins>
       </build>
   ```

   配置完并更新项目之后，在Plugins下会有一个mybatis-generator功能

2. 创建生成逆向工程的配置文件 generatorConfig.xml 名字固定

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE generatorConfiguration
           PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
           "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
   
   <generatorConfiguration>
       <context id="testTables" targetRuntime="MyBatis3Simple">
           <commentGenerator>
               <!-- 是否去除自动生成的注释。true：是;false:否 -->
               <property name="suppressAllComments" value="true" />
           </commentGenerator>
           <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->
           <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                           connectionURL="jdbc:mysql://localhost:3306/mybatistest?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8"
                           userId="root"
                           password="wangyize201">
           </jdbcConnection>
   
           <!-- 默认false，把JDBC DECIMAL和NUMERIC类型解析为Integer，为true时把JDBC DECIMAL 和
               NUMERIC 类型解析为java.math.BigDecimal -->
           <javaTypeResolver>
               <property name="forceBigDecimals" value="false" />
           </javaTypeResolver>
   
           <!-- targetProject:POJO类生成的位置 -->
           <javaModelGenerator targetPackage="com.sazer.mybatis.pojo"
                               targetProject="./src/main/java">
               <!--设置为true之后，上面Package中的每个. 都会被解析为一层目录-->
               <property name="enableSubPackages" value="true" />
               <!-- 从数据库返回的值被清理前后的空格 -->
               <property name="trimStrings" value="true" />
           </javaModelGenerator>
           <!-- targetProject:mapper映射文件生成的位置 -->
           <sqlMapGenerator targetPackage="com.sazer.mybatis.mapper"
                            targetProject="./src/main/resources">
               <!-- enableSubPackages:是否让schema作为包的后缀 -->
               <property name="enableSubPackages" value="true" />
           </sqlMapGenerator>
           <!-- targetPackage：mapper接口生成的位置 -->
           <javaClientGenerator type="XMLMAPPER"
                                targetPackage="com.sazer.mybatis.mapper"
                                targetProject="./src/main/java">
               <property name="enableSubPackages" value="false" />
           </javaClientGenerator>
           <!-- 指定生成哪些数据库表，要和数据库中对应，不能写错了，这里以t_user表为例，可以写多个；domainObjectName是要生成的实体类名称-->
           <table schema="mybatis" tableName="t_user" domainObjectName="User"/>
   
           <!-- 有些表的字段需要指定java类型
            <table schema="" tableName="">
               <columnOverride column="" javaType="" />
           </table> -->
       </context>
   </generatorConfiguration>
   ```

3. 在Maven窗口，找到该项目 - Plugins - mybatis-generator，双击即可执行生成逆向工程的操作。

   执行完之后就会根据表生成对应的 Pojo、Mapper类和mapper配置文件

## 8.2 生成完整逆向工程

完整版可以生成带条件的CRUD，基本可以实现对单表的所有操作，但是多表还得自己实现

需要将context标签的targetRuntime属性改为MyBatis3

除了pojo类、mapper类和mapper映射文件之外，还会生成一个pojoExample类，用于编写条件

### 8.2.1 Selective

**insert**

提供两个insert方法，一个insert和一个insertSelective，两个方法参数都是一个pojo对象

`int insert(User record);`

`int insertSelective(User record);`

区别为：

- 使用insert方法时，如果revord对象的某个属性值为null，则会手动给该字段赋值为null

- 使用insertSelective方法时，如果record对象某个属性值为null，则不会为该字段赋值，而是交给MySQL来赋默认值

**update**

update方法中，Selective的意义和insert类似

- 方法名不带Selective：如果record对象某个属性值为null，则会将该字段的值修改为null
- 方法名带Selective：如果record对象某个属性值为null，则不修改该字段

### 8.2.2 ByExample

需要查询的操作一般会提供两个函数，一个是ByPrimaryKey，这种方法就只能传入主键并通过主键查询

另一种是ByExample，这种方法需要传入一个Example对象，并按照规则进行查询

**查询所有数据**

在ByExample方法中传入参数null，就是无条件查询，就可以查到所有数据

```java
List<Emp> list = mapper.selectByExample(null);
```

**根据条件查询**

这里查询使用的是QBC，Query By Criteria

1. 创建一个Example对象

   ```java
   EmpExample example = new EmpExample();
   ```

2. 用example对象创建一个Criteria

3. 在Criteria后面添加条件

   条件的命名就是 and + 要查询的属性名 + 条件

   如果想用or，就再起一行直接写 or，后面写or之后的条件

   ```java
   example.createCritera().andEmpNameEqualTo("张三").andAgeGreaterThan(18);
   example.or().andGenderEqualTo("男");
   ```

   这个就相当于SQL语句 `select * from t_emp where (emp_name = '张三' and age > 18) or (gender = '男');`

# 9 分页插件

使用插件来完成分页显示操作

1. 添加依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper -->
   <dependency>
       <groupId>com.github.pagehelper</groupId>
       <artifactId>pagehelper</artifactId>
       <version>5.2.0</version>
   </dependency>
   ```

2. 配置插件

   在MyBatis的核心配置文件中配置插件，相当于是一个拦截器，拦截分页请求

   （plugins标签需要在environment标签上方）

   ```xml
   <plugins>
   	<plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
   </plugins>
   ```

3. 在查询操作之前使用分页功能

   ```java
   PageHelper.startPage(pageNum:1, pageSize:4); // 获取第一页，每页四条数据
   List<User> list = mapper.selectByExample(null);
   ```

4. 查询之后获取分页相关的所有数据

   navigatePages是指定在页码导航栏中显示多少页，比如5页，当前是第三页，则导航栏为 [1,2,**3**,4,5]

   ```java
   PageInfo<User> pageInfo = new PageInfo<>(list, navigatePages:5);
   
   /*
   PageInfo{pageNum=1, pageSize=2, size=2, 
   startRow=1, endRow=2, total=3, pages=2,
   list=Page{count=true, pageNum=1, pageSize=2, startRow=0, endRow=2, total=3, pages=2, reasonable=false, pageSizeZero=false}[User{id=1, username='admin', password='123456', age=23, gender='男', email='admin@qq.com'}, User{id=2, username='admin', password='123456', age=23, gender='男', email='admin@qq.com'}],
   prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, 
   hasPreviousPage=false, hasNextPage=true, navigatePages=5, 
   navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}
   */
   ```

   在数据中可以显示

   - pageNum：当前页码
   - pageSize：每页显示的条目数
   - size：当前页实际显示的条目数（最后一页可能条目数不够显示）
   - prePage：上一页的页码
   - nextPage：下一页的页码
   - isFirstPage：当前页是首页
   - isLastPage：当前页是末页
   - navigatePageNums：导航栏中要显示的页码列表

   根据这些信息就能更方便地制作页码导航栏

# 10 SSM整合

SSM整合就是整个Spring、SpringMVC和MyBatis，并让 Spring SpringMVC分别用各自地配置文件（也就是用两个IOC容器）管理各自的bean对象

- SpringMVC：

  SpringMVC是表述层的解决方案，因此它主要负责 控制层（Servlet程序）对象的管理

- Spring：

  Spring负责service层对象的管理

- MyBatis：

  MyBatis负责操作数据库，因此负责DAO层对象的管理

## 10.1 整合SS

**Spring加载时间**

SpringMVC负责控制层，需要调用Service层的方法，因此需要一个Service对象。

如果想要自动注入该Service对象，就需要先创建Service对象，因此需要先加载Spring的配置，创建Spring的IOC容器，并注册Service对象，才能完成自动注入。

所以加载Spring配置文件放在监听器中完成，可以在服务器启动时先加载Spring的配置文件，再完成对SpringMVC中Service对象的注入。

SpringMVC为ServletContextListener监听器接口提供了一个ContextLoaderListener实现类，用于加载Spring配置文件，在web.xml配置文件中直接配置该监听器即可

**整合步骤**

1. 配置maven工程pom.xml 依赖

    ```
    servlet：
    javax.servlet-api
    
    spring:
    spring-context —— spring的依赖
    spring-webmvc —— springmvc的依赖
    spring-jdbc —— DataSourceTransactionManager事务管理器在这个包中
    spring-aspects —— 管理切面
    spring-test —— spring整合junit测试类
    
    mybatis：
    mybatis —— mybatis依赖
    mybatis-spring —— mybatis和spring整合
    
    数据库连接：
    mysql-connector-j —— 连接mysql
    druid —— druid数据库连接池
    
    junit：
    junit-jupiter-api —— junit测试类
    
    日志：
    logback-classic
    log4j-core
    
    其他：
    jackson-databind —— 在springMVC中处理json数据
    commons-fileupload —— 用于文件上传
    
    thymeleaf视图：
    thymeleaf-spring5 —— thymeleaf和spring整合
    ```

2. 配置web.xml

    ```xml
    <!--编码过滤器 CharacterEncodingFilter-->
    <!--put/delete方法 HiddenHttpMethodFilter-->
    <!--DispatcherServlet-->
    
    <!--配置spring的监听器，以在服务器启动时加载Spring配置文件-->
    <listener>
        <listener-class>org.springframeword.web.contest.ContextLoaderListener</listener-class>
    </listener>
    <!--配置spring配置文件的位置和名称-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring.xml</param-value>
    </context-param>
    ```

3. 配置springmvc.xml

   ```xml
   开启扫描组件(只用扫描控制层)
   配置视图解析器
   配置默认servlet处理静态资源
   开启MVC注解驱动 annotation-driven
   配置视图控制器 view-controller
   配置文件上传解析器
   配置拦截器
   配置异常处理器
   ```

4. 配置spring.xml

   将除了springMVC管理的对象都交给spring管理

   ```xml
   开启扫描组件（除了控制层）
   <context:component-scan base-package="com.sazer.spring5">
       <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
   </context:component-scan>
   
   配置druid数据源对象
   ```

## 10.2 整合M

Spring整合MyBatis的核心就是，将SqlSession对象甚至是Mapper对象交给Spring进行管理，简化开发流程

1. 创建MyBatis核心配置文件 mybatis-config.xml

2. 将SqlSessionFactoryBean对象交给Spring管理，通过该对象可以直接获得SqlSessionFactory对象

   方式一：通过引入mybatis-config配置文件创建

   ```xml
   <bean class="org.mybatis.spring.SqlSessionFactoryBean">
       <property name="configLocation" value="classpath:mybatis-config.xml"></property>
   </bean>
   ```

   方式二：直接在创建对象时配置相应属性，这样可以省略掉mybatis配置文件中的相应配置

   比如配置dataSource，这样在mybatis配置文件中就可以省略environment标签

   ```xml
   <bean class="org.mybatis.spring.SqlSessionFactoryBean">
       <property name="configLocation" value="classpath:mybatis-config.xml"></property>
       <property name="dataSource" ref="dataSource"></property>
   </bean>
   ```

3. 将mapper对象交给Spring管理

   需要配置一个MapperScannerConfigurer对象，作用是 通过上面SqlSessionFactoryBean对象获得的SqlSessionFactory对象，再获得SqlSession对象，进而获得mapper包下的接口对应的代理实现类mapper对象，并将这些对象交给spring IOC管理

   ```xml
   <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
       <property name="basePackage" value="com.sazer.ssm.mapper"></property>
   </bean>
   ```

   property中指定mapper接口所在的包

4. 配置完之后，就可以在service层中直接自动注入相应的mapper对象

   ```java
   public class EmployeeServiceImpl {
       @Autowired
       EmployeeMapper employeeMapper;
       
   }
   ```

5. 配置事务管理器

   在spring.xml中配置

   ```xml
   <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
       <property name="dataSource" ref="dataSource"></property>
   </bean>
   
   <tx:annotation-driven transaction-manager="transactionManager" />
   ```


# MyBatisPlus

# 1. QuickStart

1. 创建springboot工程

2. 引入依赖

   - mybatis-plus-boot-starter依赖
   - lombok依赖 （还需要在idea中下载lombok插件，用于简化实体类开发）
   - mysql-connector-java依赖

   ```xml
   <dependency>
       <groupId>com.baomidou</groupId>
       <!--下面坐标根据自己使用的SpringBoot版本二选一-->
       <!--SpringBoot2使用此版本-->
       <artifactId>mybatis-plus-boot-starter</artifactId>
       <version>3.5.1</version>
   </dependency>
   
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
       <optional>true</optional>
   </dependency>
   
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <scope>runtime</scope>
   </dependency>
   ```

3. 在springboot核心配置文件application.yml中配置数据源信息

   ```yml
   spring:
     datasource:
       # 配置数据源类型
       type: com.zaxxer.hikari.HikariDataSource
       # 配置连接数据库的信息
       driver-class-name: com.mysql.cj.jdbc.Driver
       url: jdbc:mysql://localhost:3306/mybatisplustest?characterEncoding=utf-8&userSSL=false
       username: root
       password: wangyize201
   ```

4. 创建数据库表和对应的实体类

   可以使用lombok简化实体类开发，只需要在实体类上加@Data注解即可根据属性自动生成构造器、get/set方法、toString方法、equals方法

   ```java
   @Data
   public class User {
       private Long id;
       private String name;
       private Integer age;
       private String email;
   }
   ```

5. 编写mapper接口

   mybatis-plus提供了BaseMapper接口，该接口中提供了大部分单表操作，因此继承这个类即可实现大部分单表操作

   BaseMapper接口的泛型，一是指定了要操作的实体类，二是指定了要操作的表名（也就是说表名要和实体类名相同）

   同时

   ```java
   @Mapper
   public interface UserMapper extends BaseMapper<User> {
       
   }
   ```

6. 测试

   可以自动注入UserMapper对象

   ```java
   @SpringBootTest
   public class UserMapperTest {
   
       @Autowired
       private UserMapper userMapper;
   
       @Test
       public void testQueryList() {
           List<User> list = userMapper.selectList(null); // 参数是查询的条件
           list.forEach(System.out::println);
       }
   }
   ```

**service层接口**

mybatis-plus还提供了service层的接口 IService，可以直接继承该接口及其实现类，使用其中实现好的单表操作方法

- UserService

  UserService接口继承mybatis-plus提供的IService接口

  ```java
  public interface UserService extends IService<User> {
  }
  ```

- UserServiceImpl

  UserServiceImpl实现类首先要实现UserService接口，之后还要继承IService的实现类

  IService的实现类ServiceImpl有两个泛型，第一个是使用的Mapper的类型，第二个是实体类的类型

  ```java
  
  public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
  }
  ```

- Test

  ```java
  @SpringBootTest
  public class UserServiceTest {
  
      @Autowired
      private UserService userService;
  
      @Test
      public void testQueryCount() {
          System.out.println(userService.count());
      }
  
  }
  ```


# 2. 常用注解

## 2.1 @TableName 实体类和表名映射

BaseMapper操作的数据库表名有实体类来决定，默认情况下操作和实体类同名的数据库表

可以使用@TableName属性来指定实体类对应的表名

```java
@Data
@TableName("t_user")
public class User{
    
}
```

如果所有表名都和实体类有某种映射关系，比如表名都是 t_实体类名 ，那么也可以通过全局配置来指定这种映射，就可以不用每个实体类都添加@TableName注解

```yml
mybatis-plus:
	global-config:
		db-config:
			table-prefix: t_
```

## 2.2 @TableId 设置主键

mybatisplus默认将id作为主键，如果主键字段名不叫id就会找不到主键

此时可以使用@TableId注解指定主键

```java
public class User {
    @TableId
    private Long uid;
    
    private String name;
}
```

**value属性**

如果主键字段名和对应实体类的属性名不一致，可以在value属性中指定属性对应的字段名

```java
public class User {
    // 表中主键字段名为 uid
    @TableId(value="uid")
    private Long id;
}
```

**type属性**

指定主键生成策略（mybatis-plus中默认生成策略是雪花算法 IdType.ASSIGN_ID）

比如，将主键生成策略改为递增（IdType.AUTO），注意数据库中也要设置为递增

```java
public class User {
    // 表中主键字段名为 uid
    @TableId(value="uid", type=IdType.AUTO)
    private Long id;
}
```

也可以通过全局配置来设置统一的主键生成策略

值和type的值相同，自增是auto，默认的雪花算法是assign_id

```yml
mybatis-plus:
	global-config:
		db-config:
			id-type: auto
```

**雪花算法**

## 2.3 @TableField 设置字段

将实体类中的属性名和对应表中的字段名做映射

```java
public class User {
    @TableFiled("user_name")
    private String name; // 将属性名name和字段名user_name做映射
}
```

## 2.4 @TableLogic 逻辑删除

逻辑删除即假删除，将数据库中对应数据标记为被删除状态，之后在数据库中仍然可以看到此条记录，但是无法查询到，作用为可以进行数据恢复

可以在表中添加一个字段名 is_deleted ，表示是否被逻辑删除，在实体类的对应属性上加上@TableLogic注解，之后删除数据时，就会执行逻辑删除（即不会真正删除，而是将isDeleted值修改为1）

```java
public class User {
    @TableLogic
	private int isDeleted;
}
```

## 2.5 @EnumValue 使用枚举

对于一些数据，比如性别，可以使用枚举类型增加可读性

但是如果直接将实体类中某个字段类型设置为枚举类型，则默认存储进数据库的数据是String类型的枚举名称，如果想要将枚举值存储进数据库中，就需要

1. 在枚举值变量上加@EnumValue注解

```java
@Getter
public enum SexEnum {
    MALE(1, "男"),
    FEMALE(2, "女");
    
    @EnumValue
    private Integer sex;
   	
    private String sexName;
    
    SexEnum(Integer sex, String sexName){
        this.sex = sex;
        this.sexName = sexName;
    }
}
```

2. 在配置中开启扫描通用枚举的包

   ```yml
   type-enums-package: com.sazer.mybatisplus.enums
   ```

3. 之后就可以将实体类中枚举类型的属性 映射到 数据库中数值类型的字段

# 3 条件构造器wrapper

wrapper用于指定查询或者插入语句中的条件

![wrapper继承结构](D:\CS_Source\myNote-of-ComputerStudy\JavaWeb\7\wrapper继承结构.png)

## 3.1 QueryWrapper

### 3.1.1 查询条件

QueryWrapper类中提供了很多条件方法，并且支持链式使用。

条件参数：

- condition：拼接该条件的条件，就是满足这个参数中的条件，才会在where中拼接上这个条件

- column：该条件应用在数据库哪一列中
- 具体的条件

删除功能中也使用查询条件

```java
// 查询用户名包含a并且年龄在20~30之间 或 邮箱信息为null的用户信息
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
int ageBegin = 20, ageEnd = 30;
queryWrapper.like("user_name", "%a%")
    .between(condition:ageBegin != null, column:"age", ageBegin, ageEnd)
    .or()
    .isNull("email");
userMapper.selectList(queryWrapper);
```

### 3.1.2 排序条件

```java
// 先按照年龄降序排序，再按照id升序排序
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
queryWrapper.orderByDesc("age")
    .orderByAsc("uid");
userMapper.selectList(queryWrapper);
```

### 3.1.3 条件优先级

就是实现SQL语句中的小括号

比如 

- 用户名包含a并且年龄在20~30之间 或 邮箱信息为null
- 用户名包含a 并且 （年龄在20~30之间 或 邮箱信息为null）

如果使用默认连接按顺序添加条件，就是第一个意思

如果想要第二个意思就需要小括号，在mybatis-plus中使用and + lambda表达式表示优先执行

```java
// 查询用户名包含a并且年龄在20~30之间 或 邮箱信息为null的用户信息
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
queryWrapper.like("user_name", "%a%")
    and(i->i.gt("age", 20).or().isNull("email"));
userMapper.selectList(queryWrapper);
```

### 3.1.4 设置查询字段

不查询所有字段，只查询指定字段。

这样的查询结果是map类型，不能是实体类对象

```java
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
queryWrapper.select("user_name", "age", "email");
List<Map<String, Object>> maps = userMapper.selectMaps(queryWrapper);
```

### 3.1.5 子查询

```java
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
// 相当于select * from t_user where uid in (select uid from t_user where uid <= 100);
queryWrapper.inSql("uid", "select uid from t_user where uid <= 100");
```

## 3.2 UpdateWrapper

更新操作可以通过QueryWrapper + 实体类对象完成，一个指定要更新哪条记录，一个指定更新后的数据

`userMapper.update(newUser, queryWrapper);`

也可以通过UpdateWrapper实现

```java
UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();
updateWrapper.like("user_name", "a");
updateWrapper.set("user_name", "Tom");
int result = userMapper.update(null, updateWrapper); // 这样就可以不用传入实体类对象了
```

## 3.3 LambdaQueryWrapper

防止把字段名写错，所以将字段名参数的类型从String改为了一个函数式接口，要传入一个要操作的类型对应实体类的get方法

```java
LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
String username = "a";
queryWrapper.like(username != null, User::getName, username);
List<User> userList = userMapper.selectList(queryWrapper);
```

## 3.4 LambdaUpdateWrapper

```java
LambdaUpdateWrapper<User> updateWrapper = new LambdaUpdateWrapper<>();
updateWrapper.like(User::getName, "a");
updateWrapper.set(User::getName, "Tom");
int result = userMapper.update(null, updateWrapper); // 这样就可以不用传入实体类对象了
```

# 4. 插件

## 4.1 分页插件

### 4.1.1 使用分页插件

**配置分页插件**

```java
@Configuration
@MapperScan("com.sazer.mybatisplus.mapper")
public class MyBatisPlusConfig {
    @Bean
    public MyBatisPlusInterceptor mybatisPlusInterceptor() {
        // 创建interceptor拦截器对象
        MyBatisPlusInterceptor interceptor = new MyBatisPlusInterceptor();
        // 在拦截器对象中添加分页拦截器
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```

**使用分页插件**

直接使用selectPage方法

```java
// 第一个参数是当前要显示的页码，第二个参数是分页大小
Page<User> page = new Page<>(current:1, size:3);
userMapper.selectPage(page, queryWrapper:null); // 执行完之后，分页数据和信息都存储在page对象中
list<User> users = page.Records();
```

### 4.1.2 自定义sql语句使用分页插件

自定义查询函数要想使用分页插件提供的分页功能，必须保证返回值是Page<>, 第一个参数也是 Page<>

```xml
<! Page<User> selectPageVo(@Param("page") Page<User> page, @Param("age") Integer age); >

<select id="selectPageVo" resultType="User">
    select uid, user_name, age, email from t_user where age > #{age}
</select>
```

这样定义之后，使用方法和上面使用分页插件的方法完全一样

## 4.2 乐观锁

### 4.2.1 什么是乐观锁

与乐观锁对应的是悲观锁，悲观锁就是在访问共享资源之前先上锁，即不允许多个进程同时访问共享资源。互斥锁、读写锁等都属于悲观锁。

乐观锁的工作方式则是：所有进程都可以先修改共享资源，修改完之后，再验证这段时间有没有发生冲突。如果没有其他线程在修改资源，那么操作完成；如果提交时发现有其他线程已经修改过这个资源，就直接放弃本次操作。

乐观锁发生冲突后放弃本次操作并充实的成本很高，所以乐观锁的应用场景为发生冲突的概率足够低的情况。并且乐观锁全程其实都没有加锁，因此也叫无锁编程。

**乐观锁的实现**

乐观锁通过版本号来判断提交时是否有其他线程修改过这个资源。

比如在数据库中，可以添加version字段，在更新数据库时要检查version字段是否是指定的version，如果更新成功，还要更新版本号，将version值+1

```sql
update product set price=price+50, `version` = `version` + 1 where id=1 and `version`=1;
```

### 4.2.2 乐观锁插件

乐观锁插件可以自动完成version字段的维护，并在数据更新时检查 更新时字段的版本号和使用查询语句取出字段时的版本号是否一致

1. 标识version字段

使用乐观锁表中要有version字段

对应的实体类中的version属性上要加@Version注解，用来标识这是乐观锁的版本号字段

```java
@Data
public class Product {
    private Long id;
    private String name;
    private Integer price;
    @Version
    private Integer version;
}
```

2. 在配置类中添加乐观锁插件

```java
@Configuration
@MapperScan("com.sazer.mybatisplus.mapper")
public class MyBatisPlusConfig {
    @Bean
    public MyBatisPlusInterceptor mybatisPlusInterceptor() {
        // 创建interceptor拦截器对象
        MyBatisPlusInterceptor interceptor = new MyBatisPlusInterceptor();
        // 在拦截器对象中添加分页拦截器
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        // 添加乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
}
```

# 5. 代码生成器

和逆向工程类似，根据数据库表生成自动生成mapper、service、pojo等代码

## 5.1 代码生成

1. 首先需要引入依赖

   ```xml
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus-generator</artifactId>
       <version>3.5.3.1</version>
   </dependency>
   ```

   ```xml
   <dependency>
       <groupId>org.freemarker</groupId>
       <artifactId>freemarker</artifactId>
       <version>2.3.31</version>
   </dependency>
   ```

2. 使用官方文档提供的代码模板快速生成

   ```java
   public class FastAutoGeneratorTest {
   
       public static void main(String[] args) {
           FastAutoGenerator.create("jdbc:mysql://localhost:3306/mybatisplustest?characterEncoding=utf-8&userSSL=false", "root", "wangyize201")
                   .globalConfig(builder -> {
                       builder.author("sazer") // 设置作者
   //                            .enableSwagger() // 开启 swagger 模式
                               .fileOverride() // 覆盖已生成文件
                               .outputDir("D:\\CS_Source\\JavaSource\\MybatisPlusTest"); // 指定输出目录
                   })
                   .dataSourceConfig(builder -> builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -> {
                       int typeCode = metaInfo.getJdbcType().TYPE_CODE;
                       if (typeCode == Types.SMALLINT) {
                           // 自定义类型转换
                           return DbColumnType.INTEGER;
                       }
                       return typeRegistry.getColumnType(metaInfo);
   
                   }))
                   .packageConfig(builder -> {
                       builder.parent("com.sazer") // 设置父包名
                               .moduleName("mybatisX") // 设置父包模块名
                               .pathInfo(Collections.singletonMap(OutputFile.xml, "D:\\CS_Source\\JavaSource\\MybatisPlusTest")); // 设置mapperXml生成路径
                   })
                   .strategyConfig(builder -> {
                       builder.addInclude("t_user") // 设置需要生成的表名
                               .addTablePrefix("t_", "c_"); // 设置过滤表前缀
                   })
                   .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                   .execute();
       }
   }
   ```

更改配置之后，MyBatisplus就会根据连接的数据库和表名将表对应的 service、mapper、pojo、controller包 和 mapper.xml配置文件 在指定目录下创建完成并自动打开相应目录，之后就可以将文件复制到项目中使用

## 5.2 mybatisX插件生成

首先要在Idea的Database窗口中添加数据库连接，之后在Database窗口中右键相应的表即可进行代码生成

# 6. 多数据源

用于需要同时向操作多个数据库时的场景

1. 引入依赖

   ```xml
   <dependency>
   	<groupId>com.baomidou</groupId>
       <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
       <version>3.5.0</version>
   </dependency>
   ```

2. 在springboot配置文件中配置多数据源

   ```yml
     datasource:
       dynamic:
         primary: master
         # 是否严格匹配，如果设置为false，则匹配不到指定数据源时就会使用上面的主数据源；如果设置为true，则匹配不到数据源时报错
         strict: false
         datasource:
           master:
             url: jdbc:mysql://localhost:3306/mybatisplustest?characterEncoding=utf-8&userSSL=false
             driver-class-name: com.mysql.cj.jdbc.Driver
             username: root
             password: wangyize201
           slave_1:
             url: jdbc:mysql://localhost:3306/mybatisplustest_1?characterEncoding=utf-8&userSSL=false
             driver-class-name: com.mysql.cj.jdbc.Driver
             username: root
             password: wangyize201 
   ```

3. 在用户service中使用@DS注解指定使用的数据源

   ```java
   @DS("master") // 指定使用的数据源为配置中名为master的数据源
   @Service
   public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService{
       
   }
   ```

   ```java
   @DS("slave_1") // 指定使用的数据源为配置中名为slave_1的从数据源
   @Service
   public class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> implements ProductService{
       
   }
   ```

   
