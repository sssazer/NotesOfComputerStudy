# 1. C++ Sockets简介

## 1.1 名词解释

- Winsock：Sockets最初是为Unix系统开发的，之后Windos系统对其做了实现，称为Winsock

- WSA：Windows Sockets API

- ws2_32.dll：(C:\WINDOWS\System32)，Winsock的核心组件，实现软件到硬件的底层交互功能

  是一个动态链接库文件（dll——dynamic link library），里面包含了编译好的代码，可以被不同的应用直接拿来复用

## 1. 2 端口号

- 开发网络程序时，服务器端的端口号一般是在代码中指定，而客户端的端口号由操作系统分配
- 端口号有16位，可以是1~65535的任何整数
- 1~1023是熟知端口号，被保留用作特定的应用
- 推荐使用大于1024的端口号，以确保想要的端口号没有被占用

## 1.3 Sockets

**定义：**

A pipe between two computers on a network through which data flows —— by Mulholland 2004

**特点：**

- Sockets是双向的，在一个socket中既可以发送数据也可以接收数据
- socket有两种常见的形式：tcp和udp
- 基本上Winsock中的所有函数都运行在socket上

# 2. Create A Socket Of Server

## 2.1 创建过程概述

### 2.1.1 Status of a Server

1. Unbound：刚创建一个新的Server，但是还没有绑定IP和端口号

2. Bound：给服务器端绑定一个合法的ip地址和端口号

3. Listening：在指定端口监听连接请求

4. Connected：当发现连接请求时，服务器端会建立（复制）一个新的socket来与客户端建立连接，而原来的socket会继续监听来自其他客户端的请求

   复制出来的socketip和端口号都和原来相同

   ![](./12/2.1.1-1connected.png)

### 2.1.2 Server Functions

1. Initialize WSA 初始化：`WSAStartup()`
2. Create a socket 创建：`socket()`
3. Bind the socket 绑定IP和端口: `bind()`
4. Listen on the socket 监听: `listen()`
5. Accept a connection 建立连接: `accept()`, `connect()`
6. Send and receive data 发送和接收数据: `recv()`, `send()`, `recvfrom()`, `sendto()`
7. Disconnect 断开连接: `closesocket()`

## 2.2 Step0 - 配置环境

**配置VS依赖**

打开Visual Studio

项目 - 最下面一项 <项目名>属性 - 链接器 - 输入 - 附加依赖项 - 编辑

输入`ws2_32.lib`之后保存

**引入头文件**

```c++
#include<winsock2>
#include<ws2tcpip.h>
```

## 2.3 Step1 - Load DLL

**函数原型**

`int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);`

- 参数一：要使用的协议的版本
- 参数二：一个LPWSADATA类型的指针，用于存放WSAStartup返回的东西
- 返回值：初始化成功返回0，失败返回错误代码

**WSAData**

The WSADATA structure contains information about the Windows Sockets implementation

```C++
typedef struct WSAData{
    WORD wVersion;
    WORD wHighVersion;
    char szDesciption[WSADESCRIPTION_LEN+1];
    char szSystemStatus[WSASYS_STATUS_LEN+1];
    unsigned short iMaxSockets;
    unsigned short iMaxUdpDg;
    char FAR* IpVendorInfo;
}
```

这个结构体中的属性并不用我们指定，只需要传入一个WSAData类型指针，WSAStartup会将初始化好的结构存放到这个指针中

**使用实例**

```C++
WSADATA wsaData;
int wsaerr;
WORD wVersionRequested = MAKEWORD(2, 2); // 版本2.2
wsaerr = WSAStartup(wVersionRequested, &wsaData);
if(wsaerr != 0){ // 返回非0说明初始化失败
    cout << "The Winsock dll not found!" << endl;
    return 0;
}
else{ // 初始化成功
    cout << "The Winsock dll found!" << endl;
    cout << "The status:" << wsaData.szSystemStatus << endl; // 打印当前状态
}
```

## 2.4 Step2 - Create Socket

创建一个Socket，指定Socket属性，比如使用的协议等

**函数原型**

```c++
SOCKET WSAAPI socket(int af,
                    int type,
                    int protocol);
```

- af：The address family specification

  这里需要传入`AF_INET`，表示该Socket接收IPv4地址

- type：The type specification for the new socket

  指定创建的socket的传输类型

  - SOCK_STREAM for TCP
  - SOCK_DGRAM for UDP

- protocol：The protocol to be used

  使用到的传输协议

  - IPPROTO_TCP for TCP

- 返回值：创建成功返回创建好的Socket对象，创建失败返回错误代码

**Deregister Windock2 DLL**

加载DLL并创建Socket成功之后，应该释放掉对DLL的占用

`int WSACleanup(void);`

**使用实例**

```C++
SOCKET serverSocket = INVALID_SOCKET;
serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if(serverSocket == INVALID_SOCKET){ // 创建失败
    cout << "Error at socket():" << WSAGetLastError() << endl;
    WSACleanup(); // 创建失败要释放掉对WinSock的占用
    return 0;
}
else{
    cout << "socket() is OK!" << endl;
}

// .........
WSACleanup(); // 使用完后也要释放WinSokcet
```

## 2.5 Step3 - Bind the Socket

给创建好的Socket指定IP地址和端口号

**函数原型**

```C++
int bind(SOCKET s,
        const struct sockaddr* name,
        int socklen);
```

- s：要绑定的Socket对象，SOCKET类型，即Step2中创建好的Socket

- sockaddr*：结构体指针

  在该结构体中包含了socket要绑定的地址，包括IP地址和端口号

- socklen：第二个参数中address structure的长度，可以直接用sizeof函数获取
- 返回值：绑定成功返回0，失败返回SOCKET_ERROR

**SOCKADDR_IN**

该结构体用于Windows Sockets指定一个Server Socket地址用于让本地或远程其他主机连接，用于IPv4

```C++
struct sockaddr_in{
    short sin_family; // Address family, must be AF_INEF(因为这个结构体专用于IPv4)
    unsigned short sin_port; // 端口号
    struct in_addr sin_addr; // IPv4地址
    char sin_zero[8]; // 用于填充结构体到某个指定大小
};
```

**使用实例**

```C++
sockaddr_in service; 
service.sin_family = AF_INET;
InetPton(AF_INET, _T("127.0.0.1"), &service.sin_addr.s_addr); // 这里_T需要引入头文件 #include<tchar.h>
service.sin_port = htons(55555); // htons函数用于将端口号填充到指定大小，这里端口号为55555，可以自由指定
if (bind(serverSocket, (SOCKADDR*)&service, sizeof(service)) == SOCKET_ERROR){ // 绑定失败
    cout << "bind() failed:" << WSAGetLastError() << endl;
    closesocket(serverSocket); // 关闭socket
    WSACleanup(); // 释放socket资源
    return 0;
}
else{ // 绑定成功
    cout << "bind() is OK!" << endl;
}
```

## 2.6 Step4 - Listen

让一个socket进入监听状态，准备接收一个即将到来的连接

**函数原型**

`int listen(SOCKET s, int backlog);`

- s：要进入监听状态的socket，这个socket应该已经在Step2中被成功创建并在Step3中被成功绑定
- backlog：允许的最大连接数（与操作系统有关）
- 返回值：如果没有错误发生返回0， 否则返回SOCKET_ERROR

**使用实例**

```C++
if(listen(serverSocket, 1) == SOCKET_ERROR)
    cout << "listen():Error listening on socket" << WSAGetLastError() << endl;
else
    cout << "listen() is OK, I'm waiting for connections..." << endl;
```

## 2.7 Step5 - Accept

允许一个到来的连接进入server

accept is a blocking function，它会阻塞server进程的执行，直到与客户端建立连接。在阻塞期间server保持listening状态，但其实不是listen函数阻塞的

**函数原型**

```c++
SOCKET accpet(SOCKET s,
             struct sockaddr* addr,
             int * addrlen)
```

- s：一个处于监听状态的server socket对象
- addr：Optional，可以置为null
- Addrlen：Optional，第二个参数的长度
- 返回值：返回一个server socket的复制，这个复制体中建立了与client的连接，而原socket则继续监听

**使用实例**

```c++
SOCKET acceptSocket;
acceptSocket = accept(serverSocket, NULL, NULL); // 创建一个新的socket，用acceptSocket变量接收
if(acceptSocket == INVALID_SOCKET){ // 如果连接失败
    cout << "accept failed:" << WSAGetLastError() << endl;
    WSACleanup();
    return -1;
}
```



# 3. Client

## 3.1 创建过程概述

### 3.1.1 Status of Client

1. Unbound
2. Bound：其中端口号是自动分配的
3. Connected

### 3.1.2 Client Functions

1. Initialize WAS 初始化: `WSAStartup()`
2. Create a socket 创建: `socket`
3. Connect to the server 向服务器端发出连接请求：`connect()`
4. Send and receive data 发送和接收数据：`recv()`, `send()`, `recvfrom()`, `sendto()`
5. Disconnect 关闭连接：`closesocket()`

## 3.2 Step3 - Connect

Step1初始化和Step2创建client socket的方法和server中一样，由于client socket是系统自动分配ip地址和端口号，因此不用手动绑定

**函数原型**

```c++
int connect(
    SOCKET s,
    const struct sockaddr* addr,
    socklen_t addrlen
);
```

- s：client socket对象

- addr：包含了要连接的服务器IP地址和端口号的结构体

  这个结构体和2.4bind函数中的第二个参数相同

- addrlen：addr结构体的大小

- 返回值：如果成功连接返回0，否则返回SOCKET_ERROR

  默认等待服务器响应75s

**使用实例**

```c++
sockaddr_in clientService;
clientService.sin_family = AF_INET;
InetPton(AF_INET, _T("127.0.0.1"), &clientService.sin_addr.s_addr); // 服务器地址为127.0.0.1
clientService.sin_port=htons(55555); // 服务器端口号为55555
if(connect(clientSocket, (SOCKADDR*)&clientService, sizeof(clientService)) == SOCKET_ERROR){ // 连接失败
    cout << "Client: connent() - Failed to connect." << endl;
    WSACleanup();
    return 0;
}
else{
    cout << "Client: connect() is OK." << endl;
    cout << "Client: Can start sending and receiving data..." << endl;
}
```

