# C++核心编程
## 内存分区模型
*意义：不同区域存放的数据，赋予不同的声明周期，给我们更大空间的灵活编程*

   - 代码区：存放函数体的二进制代码，由操作系统进行管理\

    **特点**
     - 共享：打开多个exe程序内存中只有一份代码
     - 只读：防止程序意外地修改了它的指令

   - 全局区：存放**全局变量**和**静态变量**以及**常量**
     - **全局变量**：写在函数体中(包括main函数)的变量都是局部变量，函数体外的就是全局变量
     - **静态变量**：在普通变量前面加static\
     `static int s_a = 10;`
     - **常量**：包括字符串常量和其他常量（const修饰的变量） 
       - 字符串常量：双引号引起来的字符串都是字符串常量\
       `cout << &"hello world << endl;"`
       - const修饰的全局变量——全局常量
       - **const修饰的局部变量——局部常量（不存放在全局区）**
   - 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\
     **注意：不要返回局部变量的地址，因为栈区开辟的地址函数执行完就释放了** 
     ```C++
        int* func(){  // 形参数据也会放在栈区
            int a = 10;
            return &a;  //返回局部变量的地址
        }
     
        int main(){
            int *p = fun();
     
            cout<< *p << endl; // 第一次可以打印正确的数字，是因为编译器做了保留
            cout<< *p << endl;  // 第二次这个数据就不会保留了
     
            system("pause");
            return 0;
        }
     ```
   - 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
     - 在C++中主要利用new在堆区开辟内存，返回开辟内存的地址
     - 指针本质上也是局部变量，放在栈上，但是指针指向的数据是放在堆区
     ```C++
        int * func(){
     
            int *p = new int(10);  // new会返回开辟的内存空间的地址
            return p;
        }
     
        int main(){
            int *p = func();
            cout << *p << endl;
            cout << *p << endl;
     
            return 0;
        }
     ```
   - new操作符
     1. new的基本语法
          - `new 数据类型(默认值);`
          - `delete 指针;`
     2.  在堆区利用new开辟数组
         - `int * arr = new int[10];`  
         - `delete[] arr;`
            不加中括号的话只会释放首地址
## 引用 
  1. 引用的基本使用
     - 本质：给变量起别名
     - 语法：`数据类型 &别名 = 原名;` \
        `int a = 10;`\
        `int &b = a;`
  2. 引用的注意事项
     1. 引用必须要初始化\
        `int &b;`错误
        
     2. 引用一旦初始化后，就不可以更改了\
        `b = c;` 这是赋值操作而不是更改引用 
  3. 引用做函数参数
     - 作用：函数传参时，可以利用引用来让形参修改实参的值
     - 可以简化指针修改实参
        ```C++
           int swap(int &a, int &b){//通过引用传参其实是给实参起了一个别名
               int temp = a;
               a = b;
               b = temp;
           } 
           int main(){
               int a = 10;
               int b = 20;
               swap(a,b);  // 引用传递形参会修饰实参
           }
        
        ```
  4. 引用做函数返回值
     1. 不要返回局部变量的引用
        ```C++
            int& test(){
                int a = 10;
                return a;  // 错误示范
            }
        ```
     2. 函数的调用可以作为左值（只有返回值类型是引用类型才可以）
        ```C++
            int& test(){
                static int a = 10;//静态变量，存放在全局区，整个程序结束由系统释放
                return a;
            }
            int main(){
                int &ref = test();
                test() = 1000;
                cout << ref << endl; // 打印出来是1000，修改的实际上是a的值
            }
        ```
  5. 引用的本质
     - 本质：引用的本质在C++内部实际上是一个指针常量,所以引用只可以修改指针指向的值不可修改指向
        - 代码写出来的：`int& ref = a;`
        - 编译器内部自动转换的：`int * const ref = &a;`
        - 代码写出来的：`ref = 20;`
        - 编译器内部自动转换的：`*ref = 20;`
  6. <span id="常量引用">常量引用</span>
  
     **作用**：常量引用主要用来修饰形参，防止误操作
     
      ***创建引用变量时***
       - `int & ref = 10;` 不合法，引用必须引一块合法的内存空间，而10是字面量，在常量池中
       - `const int & ref = 10;` 合法，因为实际上编译器将代码修改为\
           `int temp = 10; const int & ref = temp;`此时原名temp不知道，只能用别名ref操作这个变量了

        ***用于函数形参时***
     - 在函数形参列表中加const修饰形参，防止形参改变实参\
        `void print(const int &val);`\
        **和值传递比好处是不用申请额外空间来复制实参**


