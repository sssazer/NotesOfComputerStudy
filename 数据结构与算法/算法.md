# 1. 摩尔投票法

## 1.1 作用

 Boyer-Moore投票算法 用于寻找众数，即出现次数超过数组元素个数一半的元素

## 1.2 算法思想

核心思想为对拼消耗

设置一个候选人candidate，初始为nums[0]，count为1；

遍历整个数组，当遍历到的元素与candidate相等时，count++，不等时count--；如果count减到0，那么就推举下一个遇到的元素作为候选人，令count = 1并重新开始计数。

由于众数出现的次数大于整个数组长度的一半，所以最后留下的一定是众数。

**思想扩展**

用对拼消耗的思想，可以有多个候选者的摩尔投票法

n票，要求每个候选者得票数大于n/k票，那么最多能选出k-1个候选者（比如在长度为n的数组中找出其中出现次数超过n/3的元素，最多有两个）

维护一个长度为k-1的数组candidates，遍历给出的长度为n的数组。假设当前遍历到的数组元素为i，如果此时candidates中空位置（票数为0），则让 i 作为候选人，票数置为1。如果没有空位置，那么如果这个 i 与某一个候选者相等，那个候选者的票数+1，如果都不相等，那么所有候选者票数 -1。

注意遍历完成后，留在候选者数组中的元素不一定都满足要求，需要再遍历一遍原数组确定每个候选者出现的次数是否满足要求。

## 1.3 例题及代码

### 1.3.1 169.多数元素

题目描述：

```
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/majority-element
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

代码：

```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
		int candidate, count = 0; // 声明候选人和计数变量
        for(auto &i : nums){ // 遍历数组
            if(count == 0){ // 如果遍历到某个元素时count为0，说明前面都抵消完了，就推举这个新遇到的元素作为候选人
                candidate = i;
                count = 1;
                continue;
            }
            if(i == candidate){ // 如果遇到的元素与candidate相同，count++
                count++;
            }else{ // 否则count--
                count--;
            }
        }
        return candidate; // 最后candidate的值即为所求众数
    }
};
```





